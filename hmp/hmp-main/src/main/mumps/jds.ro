Cache for Windows^INT^JSON data store 20Nov2012^~Format=Cache.S~^RAW
%RO on 20 Nov 2012   6:04 PM
VPRJ^INT^1^62766,56362.850393^0
VPRJ ;SLC/KCM -- Menu for JSON data store utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Menu to run various utilities for the JSON data store:  D ^VPRJ
 ;
MENU ; Allow utilities to be selected from a menu
 G DOMENU^VPRJ1
 ;
START ; Start the HTTP listener
 I $$STATUS^VPRJRCL="running" W !,"Listener is already running.",! Q
 ;
 W !,"Starting listener on port ",$$PORT^VPRJRCL
 D GO^VPRJRCL
 H 1
 W !,"Listener status:  ",$$STATUS^VPRJRCL,!
 Q
STOP ; Stop the HTTP listener
 N X
 I $G(^VPRHTTP(0,"listener"))="stopped" W !,"Listener is already stopped.",! Q
 D STOPW^VPRJRCL
 Q
WAIT ;
 N I,X
 S X=$$STATUS^VPRJRCL
 W !,"Listener status: ",X
 F I=1:1:12 Q:X="stopped"  D
 . H 1
 . S X=$$STATUS^VPRJRCL
 . W "."
 . I X="stopped" W X
 Q
PORT ; Change the listening port number
 N PORT
 W !,"Enter port number: "
 R PORT:300 E  Q
 I '$L(PORT) Q
 I (PORT<1024)!(PORT>65000) W " ??" G PORT
 D STOP
 D SPORT^VPRJRCL(PORT)
 D START
 Q
LOG ; Set the logging level
 N X
 W !,"Log level will be changed on the next connection.",!
 W !,"0: no logging except errors"
 W !,"1: log headers"
 W !,"2: log raw request"
 W !,"3: log body"
 W !
 W !,"Enter log level: "
 R X:300 E  Q
 I '$L(X) Q
 I X'?1N W " ??" G LOG
 I X>3 W " ??" G LOG
 D SLOG^VPRJRCL(X)
 Q
CLEAR ; Clear the current logs
 W !,"Clearing all logs",!
 D CLEAR^VPRJRCL
 Q
ERROR ; List errors
  N DT,JOB,ID
  S DT=0 F  S DT=$O(^VPRHTTP("log",DT)) Q:'DT  D
  . S JOB=0 F  S JOB=$O(^VPRHTTP("log",DT,JOB)) Q:'JOB  D
  . . S ID=0 F  S ID=$O(^VPRHTTP("log",DT,JOB,ID)) Q:'ID  D
  . . . S X=$G(^VPRHTTP("log",DT,JOB,ID,"error"))
  . . . Q:'$L(X)
  . . . W !,ID,?10,$$HTE^XLFDT(DT),?14,X
  Q
VPRSTAT ; VPR statistics
 D STATUS^VPRJPM
 Q
PIDSTAT ; PID statistics
 N PID S PID=$$ASKPID^VPRJPM Q:'PID
 D STATUS^VPRJPM(PID)
 Q
RIDXALL ; Re-index entire VPR
 D RIDXALL^VPRJPM
 Q
RIDXPID ; Re-index by PID
 N PID S PID=$$ASKPID^VPRJPM Q:'PID
 D RIDXPID^VPRJPM(PID)
 Q
RIDXONE ; Build a single index
 Q
RBLDALL ; Re-build entire VPR
 D RBLDALL^VPRJPM
 Q
RBLDPID ; Re-build by PID
 N PID S PID=$$ASKPID^VPRJPM Q:'PID
 D RBLDPID^VPRJPM(PID)
 Q
LISTPTA ; List patients alphabetically
 D LISTPTS(1)
 Q
LISTPTP ; List patients by PID
 D LISTPTS(0)
 Q
LISTPTS(ALPHA) ; List all the patients in the VPR
 N PID,DFN,UID,NAME,ICN,SSN,LIST,X
 S ALPHA=$G(ALPHA)
 S PID=0 F  S PID=$O(^VPRPT("PID",PID)) Q:'PID  D
 . S DFN="" F  S DFN=$O(^VPRPT("PID",PID,"DFN",DFN)) Q:DFN=""  D
 . . S UID="urn:va:"_DFN_":pat:"_$P(DFN,":",2)
 . . S NAME=^VPRPT(PID,UID,"fullName"),ICN=$G(^("icn")),SSN=$G(^("ssn"))
 . . I ALPHA S LIST(NAME,PID)=SSN_"^"_ICN_"^"_DFN Q
 . . S LIST(PID,NAME)=SSN_"^"_ICN_"^"_DFN
 I ALPHA D
 . W !,"Name",?30,"PID",?35,"SSN",?50,"ICN",?65,"DFN"
 . S NAME="" F  S NAME=$O(LIST(NAME)) Q:NAME=""  D
 . . S PID=0 F  S PID=$O(LIST(NAME,PID)) Q:'PID  D
 . . . S X=LIST(NAME,PID)
 . . . W !,NAME,?30,PID,?35,$P(X,"^"),?50,$P(X,"^",2),?65,$P(X,"^",3)
 E  D
 . W !,"PID",?5,"NAME",?35,"SSN",?50,"ICN",?65,"DFN"
 . S PID=0 F  S PID=$O(LIST(PID)) Q:'PID  D
 . . S NAME="" F  S NAME=$O(LIST(PID,NAME)) Q:NAME=""  D
 . . . S X=LIST(PID,NAME)
 . . . W !,PID,?5,NAME,?35,$P(X,"^"),?50,$P(X,"^",2),?65,$P(X,"^",3)
 Q
DELPID ; Delete a patient from the VPR
 N PID S PID=$$ASKPID^VPRJPM Q:'PID
 D CLEARPT^VPRJP(PID)
 Q
RESET ; Reset the VPR (kill the database an re-initialize)
 I '$$ISYES("Are you sure you want to delete the database? ") Q
 D KILLDB^VPRJPM
 Q
 ;
ASKFRBLD ; ask first before rebuilding everything
 I '$$ISYES("Are you sure you want rebuild all data stores? ") Q
 D FULLRBLD
 Q
ASKFRSET ; ask first before deleting all data
 I '$$ISYES("Are you sure you want to delete all data stores? ") Q
 D FULLRSET
 Q
FULLRBLD ; do a full rebuild of VPR and non-patient data
 D RBLDALL^VPRJPM
 D RBLDALL^VPRJDM
 Q
FULLRSET ; reset (delete data and re-init) for VPR and non-patient data
 D KILLDB^VPRJPM
 D KILLDB^VPRJDM
 Q
ISYES(MSG) ; returns 1 if user answers yes to message, otherwise 0
 N X
 W !,MSG
 R X:300 E  Q 0
 I $$UP^XLFSTR($E(X))="Y" Q 1
 Q 0
 ;

VPRJ1^INT^1^62756,62812.793801^0
VPRJ1 ;SLC/KCM -- Menu Handling for JSON Store Utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
DOMENU ; display menu and execute choice
 N SEL
 D HEADER
 F  D SHOWMENU S SEL=$$CHOICE() Q:SEL=""  D
 . D @SEL
 . D PAUSE
 . I SEL="START^VPRJ" D HEADER
 . I SEL="LOG^VPRJ" D HEADER
 . I SEL="PORT^VPRJ" D HEADER
 . I SEL="DELPID^VPRJ" D HEADER
 Q
HEADER ; display header information
 W !
 W "Listener Port: ",$$PORT^VPRJRCL,"   "
 W "Status: ",$$STATUS^VPRJRCL,"   "
 W "Log Level: ",$$LOG^VPRJRCL,"   "
 W "VPR Patients: ",$G(^VPRPTX("count","patient","patient"))
 W !
 Q
SHOWMENU ; display menu
 N X,I
 S I=0 F  S I=I+1,X=$P($T(MENULST+I),";;",2,99) Q:X="zzzzz"  W !,X
 W !
 Q
CHOICE() ; prompt for menu choice
 N X,I,MENU,DONE
 S I=0 F  S I=I+1,X=$P($T(MENUNUM+I),";;",2,99) Q:X="zzzzz"  S MENU($P(X,";"))=$P(X,";",2)
 F  D  Q:DONE
 . S X=$$PROMPT("Enter Selection","","N","Enter a number from the menu above")
 . I X="" S DONE=1 Q
 . I '$D(MENU(X)) W !,X," is not a valid selection." Q
 . I $D(MENU(X)) S X=MENU(X),DONE=1
 Q X
 ;
PROMPT(PROMPT,DEFAULT,TYPE,HELP) ; Return value for a prompt
 N X
 S DEFAULT=$G(DEFAULT),HELP=$G(HELP)
RETRY ;
 W !,PROMPT,": ",$S($L(DEFAULT):" "_DEFAULT_"//",1:" ")
 R X:300
 I X="?",$L(HELP) W !,HELP,! G RETRY
 I X="" S X=DEFAULT
 I TYPE="N",$L(X),'X W !,"Numeric input required."
 Q X
 ;
PAUSE ; Pause for a return
 N X
 W !,"Press return to continue"
 R X:300
 Q
MENULST ;; menu display list
 ;;-- Listener --                          -- Logging --
 ;; 1 Start HTTP Listener on Port 9080      4 Change Logging Level
 ;; 2 Stop HTTP Listener                    5 Clear Logs
 ;; 3 Change HTTP Listener Port             6 List Errors
 ;;              
 ;;-- VPR Info --                          -- Data Info --
 ;;11 List Patients (alpha)                21 List Collections (non-patient)
 ;;12 List Patients (by PID)               22 Statistics (non-patient)        
 ;;13 Statistics for PID                             
 ;;14 Statistics for VPR (may be slow)                                        
 ;;               
 ;;-- VPR Tools --                         -- Data Tools --
 ;;31 Re-index VPR                         41 Re-index Data (non-patient)
 ;;32 Rebuild VPR                          42 Rebuild Data (non-patient)
 ;;33 Delete Patient from VPR              43 Delete Collection       
 ;;34 Reset VPR (deletes VPR data)         44 Reset Non-Patient (deletes data)
 ;;
 ;;50 Rebuild All (VPR and non-patient)    70 Reset All (VPR and non-patient)
 ;;zzzzz
MENUNUM ;; menu selection numbers
 ;;1;START^VPRJ
 ;;2;STOP^VPRJ
 ;;3;PORT^VPRJ
 ;;4;LOG^VPRJ
 ;;5;CLEAR^VPRJ
 ;;6;ERROR^VPRJ
 ;;11;LISTPTA^VPRJ
 ;;12;LISTPTP^VPRJ
 ;;13;PIDSTAT^VPRJ
 ;;14;STATUS^VPRJPM
 ;;21;LSTCTN^VPRJDM
 ;;22;STATUS^VPRJDM
 ;;31;RIDXALL^VPRJPM
 ;;32;RBLDALL^VPRJPM
 ;;33;DELPID^VPRJ
 ;;34;RESET^VPRJ
 ;;41;RIDXALL^VPRJDM
 ;;42;RBLDALL^VPRJDM
 ;;43;DELCTN^VPRJDM
 ;;44;RESET^VPRJDM
 ;;50;ASKFRBLD^VPRJ
 ;;70;ASKFRSET^VPRJ
 ;;zzzzz
 ;

VPRJAQ^INT^1^62766,51518.861036^0
VPRJAQ ;SLC/KCM -- Query for JSON objects across patients
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
QCOUNT(CNTNM) ; Return a set of counts across patients
 ; return tallies as data:{items:[{"topic":"med","count":4}
 I '$L(CNTNM) D SETERROR^VPRJRUT(101) Q
 N BUFFER S BUFFER=""
 K ^TMP($J)
 ;
 N TOPIC,DATA,COUNT,X
 S DATA=0,TOPIC=""
 F  S TOPIC=$O(^VPRPTX("count",CNTNM,TOPIC)) Q:TOPIC=""  D
 . S COUNT=+^VPRPTX("count",CNTNM,TOPIC)
 . S X=$S('DATA:"",1:",")_"{""topic"":"""_TOPIC_""",""count"":"_COUNT_"}"
 . S DATA=DATA+1,DATA(DATA)=X
 S X=$$BLDHEAD^VPRJPQ(DATA) D STAGE^VPRJPQ(X)
 S DATA=0 F  S DATA=$O(DATA(DATA)) Q:'DATA  D STAGE^VPRJPQ(DATA(DATA))
 D STAGE^VPRJPQ("]}}"),OUT^VPRJPQ
 Q
QINDEX(INDEX,TEMPLATE) ; Query across patients by index
 ; only supporting /vpr/all/index/pid/pid to return all PIDs for now
 I $G(INDEX)'="pid" D SETERROR^VPRJRUT(102) Q
 I $G(TEMPLATE)'="pid" D SETERROR^VPRJRUT(105) Q
 ;
 K ^TMP($J)
 N COUNT,PID,LINE,BUFFER
 S COUNT=0,PID=0,LINE=2,BUFFER=""
 F  S PID=$O(^VPRPT(PID)) Q:'PID  D
 . S COUNT=COUNT+1
 . I $L(BUFFER)>4000 S ^TMP($J,LINE)=BUFFER,LINE=LINE+1,BUFFER=""
 . S BUFFER=BUFFER_$S(COUNT>1:",",1:"")_PID
 S ^TMP($J,LINE)=BUFFER_"]}}"
 S ^TMP($J,1)=$$BLDHEAD^VPRJPQ(COUNT)
 Q
QFIND(COLL,ORDER,BAIL,TEMPLATE,FILTER) ; Query across patients using filter criteria
 N VPRDATA,CLAUSES,PREFIX,PID,DFN,KEY
 S ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 I $L(FILTER) D PARSE^VPRJPQF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDF^VPRJCU(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 S PID=0 F  S PID=$O(^VPRPT(PID)) Q:'PID  D
 . S DFN="" F  S DFN=$O(^VPRPT("PID",PID,"DFN",DFN)) Q:DFN=""  D
 . . S PREFIX="urn:va:"_DFN_":"_COLL_":",KEY=PREFIX
 . . F  S KEY=$O(^VPRPT(PID,KEY)) Q:$E(KEY,1,$L(PREFIX))'=PREFIX  D ADDONE^VPRJPQA(KEY,0)
 D BUILD^VPRJCU
 K ^TMP("VPRDATA",$J)
 Q
 Q

VPRJCU^INT^1^62766,54427.732907^0
VPRJCU ;SLC/KCM -- Common Utilities for Patient and Non-Patient Stores
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SETORDER(ORDER) ; set up the order subscripts
 ; expects INDEX to be defined
 ; returned structure:
 ;   ORDER(0)=#                ; sort levels
 ;   ORDER(#)=#|name           ; level # or field name
 ;   ORDER(#,"dir")=1 or -1    ; asc or desc
 ;   ; if the field is not part of the subscripts
 ;   ORDER(#,"ftype")=1|2|3|4  ; field name structure
 ;   ORDER(#,"field")=name     ; field name
 ;   ORDER(#,"mult")=name      ; multiple name
 ;   ORDER(#,"sub")=name       ; subfield name
 ;   ORDER(#,"instance")=level ; which field to use for multiple instance
 ;
 N I,X,F,D,T,S                           ; F=field, D=direction, T=type
 S S=0                                   ; S=number of sort levels
 S X=$$LOW^XLFSTR($$TRIM^XLFSTR(ORDER))  ; if only "asc" or "desc" passed
 I X="asc"!(X="desc") S ORDER=$P($G(INDEX("order"))," ")_" "_X
 I '$L(ORDER) S ORDER=$G(INDEX("order")) ; use default if no ORDER parameter
 I '$L(ORDER) S ORDER(0)=0 Q             ; no sorting
 F I=1:1:$L(ORDER,",") S X=$P(ORDER,",",I) Q:'$L(X)  D  Q:$G(HTTPERR)
 . S S=S+1
 . S F=$$TRIM^XLFSTR($P(X," "))
 . S D=$$LOW^XLFSTR($$TRIM^XLFSTR($P(X," ",2))) S:'$L(D) D="asc"
 . S ORDER(I)=$S($D(INDEX("field",F)):INDEX("field",F),1:F)
 . I +ORDER(I),$G(INDEX("collate",ORDER(I)))="V" S D=$S(D="asc":"desc",1:"asc")
 . S ORDER(I,"dir")=$S(D="desc":-1,1:1)
 . I $D(INDEX("key",ORDER(I))) S ORDER(I,"instance")=INDEX("key",ORDER(I))
 . Q:+ORDER(I)
 . N FTYPE
 . D BLDFTYP^VPRJPQU(F,.FTYPE) M ORDER(I,"ftype")=FTYPE
 . I '$D(FTYPE) D SETERROR^VPRJRUT(108,ORDER(I)) Q  ; unknown type
 S ORDER(0)=S
 Q
SETORDF(ORDER) ; set up order subscripts without index
 N I,X,F,D,T,S                           ; F=field, D=direction, T=type
 S S=0                                   ; S=number of sort levels
 S X=$$LOW^XLFSTR($$TRIM^XLFSTR(ORDER))  ; if only "asc" or "desc" passed
 I X="asc"!(X="desc") D SETERROR^VPRJRUT(110) Q  ; missing order field
 I '$L(ORDER) S ORDER(0)=0 Q             ; no sorting
 F I=1:1:$L(ORDER,",") S X=$P(ORDER,",",I) Q:'$L(X)  D  Q:$G(HTTPERR)
 . S S=S+1
 . S F=$$TRIM^XLFSTR($P(X," "))
 . S D=$$LOW^XLFSTR($$TRIM^XLFSTR($P(X," ",2))) S:'$L(D) D="asc"
 . S ORDER(I)=F,ORDER(I,"dir")=$S(D="desc":-1,1:1)
 . N FTYPE
 . D BLDFTYP^VPRJPQU(F,.FTYPE) M ORDER(I,"ftype")=FTYPE
 . I '$D(FTYPE) D SETERROR^VPRJRUT(108,ORDER(I)) Q  ; unknown type
 S ORDER(0)=S
 Q
UNKARGS(ARGS,LIST) ; returns true if any argument is unknown
 N X,UNKNOWN
 S UNKNOWN=0,LIST=","_LIST_",start,limit,"
 S X="" F  S X=$O(ARGS(X)) Q:X=""  I LIST'[(","_X_",") D
 . S UNKNOWN=1
 . D SETERROR^VPRJRUT(111,X)
 Q UNKNOWN
 ;
BUILD ; Build the return records in the proper sort order
 ; Expects:  ORDER, TEMPLATE
 Q:+$G(HTTPERR)>0
 N KEY,KINST,SORT,RECNUM
 ;
 S RECNUM=-1
 ; case
 I ORDER(0)=0 D  G X0
 . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,KEY)) Q:KEY=""  D
 . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=1 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),KEY)) Q:KEY=""  D
 . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=2 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY)) Q:KEY=""  D
 . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=3 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY)) Q:KEY=""  D
 . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=4 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S SORT(4)="" F  S SORT(4)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4)),ORDER(4,"dir")) Q:SORT(4)=""  D
 . . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY)) Q:KEY=""  D
 . . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=5 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S SORT(4)="" F  S SORT(4)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4)),ORDER(4,"dir")) Q:SORT(4)=""  D
 . . . . . S SORT(5)="" F  S SORT(5)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5)),ORDER(5,"dir")) Q:SORT(5)=""  D
 . . . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY)) Q:KEY=""  D
 . . . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=6 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S SORT(4)="" F  S SORT(4)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4)),ORDER(4,"dir")) Q:SORT(4)=""  D
 . . . . . S SORT(5)="" F  S SORT(5)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5)),ORDER(5,"dir")) Q:SORT(5)=""  D
 . . . . . . S SORT(6)="" F  S SORT(6)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6)),ORDER(6,"dir")) Q:SORT(6)=""  D
 . . . . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY)) Q:KEY=""  D
 . . . . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=7 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S SORT(4)="" F  S SORT(4)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4)),ORDER(4,"dir")) Q:SORT(4)=""  D
 . . . . . S SORT(5)="" F  S SORT(5)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5)),ORDER(5,"dir")) Q:SORT(5)=""  D
 . . . . . . S SORT(6)="" F  S SORT(6)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6)),ORDER(6,"dir")) Q:SORT(6)=""  D
 . . . . . . . S SORT(7)="" F  S SORT(7)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7)),ORDER(7,"dir")) Q:SORT(7)=""  D
 . . . . . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY)) Q:KEY=""  D
 . . . . . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
X0 ; end case
 S ^TMP($J,"total")=RECNUM+1 ; add 1 since RECNUM is 0 based
 S ^TMP($J,"template")=TEMPLATE
 Q
ADDOBJ(VAL) ; add object/template in sequence to the return list
 S RECNUM=RECNUM+1
 S ^TMP($J,"data",RECNUM,KEY,KINST)=VAL ; right now the VAL is just the PID
 Q
 ;

VPRJD^INT^1^62756,64955.976583^0
VPRJD ;SLC/KCM -- Save JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SAVE(JSON) ; Save a JSON encoded object
 N UID,COLL,KEY,OBJECT,OLDOBJ,VPRJERR,INDEXER,TLTARY
 ;
 ; decode JSON into object and extract required fields
 D DECODE^VPRJSON("JSON","OBJECT","VPRJERR")
 I $L($G(VPRJERR)) D SETERROR^VPRJRUT(202,VPRJERR) QUIT ""
 S UID=$G(OBJECT("uid")) I '$L(UID) D SETERROR^VPRJRUT(207) QUIT ""
 ;
 ; Parse out the collection, and key from the UID
 ; Currently assuming UID is urn:va:type:vistaAccount...
 ; For example:  urn:va:fresh:93EF
 N COLL S COLL=$P(UID,":",3)
 I '$L(COLL) D SETERROR^VPRJRUT(210,UID) QUIT ""
 ;
 L +^VPRJD(UID):2 E  D SETERROR^VPRJRUT(502) QUIT ""
 ; kill the old indexes and object
 S OLDOBJ="" M OLDOBJ=^VPRJD(UID)
 D BLDTLT(COLL,.OBJECT,.TLTARY)
 TSTART
 K ^VPRJD(UID)
 K ^VPRJD("JSON",UID)
 ;
 M ^VPRJD("JSON",UID)=JSON
 M ^VPRJD("TEMPLATE",UID)=TLTARY
 M ^VPRJD(UID)=OBJECT
 D INDEX^VPRJDX(UID,.OLDOBJ,.OBJECT)
 TCOMMIT
 L -^VPRJD(UID)
 ;
 Q $$URLENC^VPRJRUT(UID)  ; no errors
 ;
DELETE(KEY) ; Delete an object given its UID
 N OLDOBJ,OBJECT,COLL
 S COLL=$P(KEY,":",3)
 I '$L(COLL) D SETERROR^VPRJRUT(210,KEY) QUIT ""
 ;
 L +^VPRJD(KEY):2 E  D SETERROR^VPRJRUT(502) QUIT ""
 ; kill the old indexes and object
 S OBJECT=""
 S OLDOBJ="" M OLDOBJ=^VPRJD(KEY)
 TSTART
 K ^VPRJD(KEY)
 K ^VPRJD("JSON",KEY)
 K ^VPRJD("TEMPLATE",KEY)
 D INDEX^VPRJDX(KEY,.OLDOBJ,.OBJECT)
 TCOMMIT
 L -^VPRJD(KEY)
 Q
BLDTLT(COLL,OBJECT,TLTARY) ; Build JSON objects for associated templates
 Q
DELCTN(COLL) ; Delete a collection given its name
 I '$L(COLL) D SETERROR^VPRJRUT(215) QUIT ""
 N PREFIX,X
 S PREFIX="urn:va:"_COLL_":",X=PREFIX
 F  S X=$O(^VPRJD(X)) Q:$E(X,1,$L(PREFIX))'=PREFIX  D DELETE(X)
 I $G(^VPRJDX("count","collection",COLL)) D SETERROR^VPRJRUT(216) QUIT ""
 K ^VPRJDX("count","collection",COLL)
 Q

VPRJDM^INT^1^62766,48857.885829^0
VPRJDM ;SLC/KCM -- Management utilities for JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
RIDXALL ; Reindex data
 W !!,"Re-indexing all non-patient data",!
 N OK,KEY,CNT
 D CLRINDEX(.OK) Q:'OK
 S CNT=0,KEY="urn:" ; to start after "JSON" and "TEMPLATE" nodes
 F  S KEY=$O(^VPRJD(KEY)) Q:KEY=""  D
 . D RIDXOBJ(KEY)
 . S CNT=CNT+1 W:CNT#100=0 "."
 Q
RIDXCTN(CTN) ; Reindex a collection
 ; Can't re-index an object at a time without corrupting the tallys
 ; We don't know which tallies to kill.
 Q
RBLDALL ; Rebuild all patients (includes templates)
 W !!,"Rebuild ALL non-patient data (including templates)",!
 N OK,KEY,CNT
 D CLRINDEX(.OK) Q:'OK
 S CNT=0,KEY="urn:" ; to start after "JSON" and "TEMPLATE" nodes
 F  S KEY=$O(^VPRJD(KEY)) Q:KEY=""  D
 . D RBLDOBJ(KEY)
 . S CNT=CNT+1 W:CNT#100=0 "."
 Q
RBLDCTN(CTN) ; Rebuild single collection (includes templates)
 ; Can't re-buld an object at a time without corrupting the tallys
 ; We don't know which tallies to kill.
 Q
RIDXOBJ(KEY) ; Re-index a single object
 L +^VPRJD(KEY):2 E  W !,"Unable to obtain lock for "_KEY QUIT
 N OBJECT
 M OBJECT=^VPRJD(KEY)
 TSTART
 D INDEX^VPRJDX(KEY,"",.OBJECT)
 TCOMMIT
 L -^VPRJD(KEY)
 Q
RBLDOBJ(KEY) ; Re-build a single object
 L +^VPRJD(KEY):2 E  W !,"Unable to obtain lock for "_KEY QUIT
 N LINE,JSON
 ; get the original JSON object without the templates
 S LINE=0 F  S LINE=$O(^VPRJD("JSON",KEY,LINE)) Q:'LINE  S JSON(LINE)=^VPRJD("JSON",KEY,LINE)
 ; indexes have been killed for whole patient, so remove the original object
 K ^VPRJD(KEY)
 K ^VPRJD("JSON",KEY)
 K ^VPRJD("TEMPLATE",KEY)
 ; call save the replace the object & reset indexes
 D SAVE^VPRJD(.JSON)
 L -^VPRJD(KEY)
 Q
CLRINDEX(OK) ; Clear all the indexes
 K ^VPRJDX,^VPRTMP
 D SETUP^VPRJDMD
 S OK=1
 Q
LSTCTN ; List collections
 N CTN
 W !,"Collections   Items     (UIDs) --"
 S CTN="" F  S CTN=$O(^VPRJDX("count","collection",CTN)) Q:CTN=""  D
 . W !,?2,CTN,?14,$G(^VPRJDX("count","collection",CTN)),?24,"(",$$OBJCTN(CTN),")"
 Q
STATUS ; Show statistics for non-patient data
 W !,"Statistics for non-patient data --"
 W !,?4," Data Nodes: ",$$NODECNT^VPRJPM("^VPRJD")
 W !,?4,"Index Nodes: ",$$NODECNT^VPRJPM("^VPRJDX")
 W !,?4,"Collections: ",$$TOTCTN()
 W !,?4,"Total Items: ",$$TOTCTNI()
 W !,?4,"Unique ID's: ",$$OBJCNT()
 Q
TOTCTN() ; Return the number of collections
 N CTN,COUNT
 S COUNT=0,CTN=""
 F  S CTN=$O(^VPRJDX("count","collection",CTN)) Q:CTN=""  D
 . I $G(^VPRJDX("count","collection",CTN)) S COUNT=COUNT+1
 Q COUNT
 ;
TOTCTNI() ; Return the total number of items in all collections
 N CTN,COUNT
 S COUNT=0,CTN=""
 F  S CTN=$O(^VPRJDX("count","collection",CTN)) Q:CTN=""  D
 . S COUNT=COUNT+$G(^VPRJDX("count","collection",CTN))
 Q COUNT
 ;
OBJCNT() ; Return a count of objects by UID
 N COUNT,UID
 S COUNT=0,UID="urn:" ; to skip "JSON" and "TEMPLATE" nodes
 F  S UID=$O(^VPRJD(UID)) Q:UID=""  S COUNT=COUNT+1
 Q COUNT
 ;
OBJCTN(CTN) ; Return a count of objects by UID for a collection
 N COUNT,PREFIX,UID
 S COUNT=0,PREFIX="urn:va:"_CTN_":",UID=PREFIX
 F  S UID=$O(^VPRJD(UID)) Q:$E(UID,1,$L(PREFIX))'=PREFIX  S COUNT=COUNT+1
 Q COUNT
DELCTN ; Delete a collection
 N HTTPERR,CTN
 S CTN=$$PROMPT^VPRJ1("Collection","","S","Enter string that identifies collection in the UID.")
 Q:CTN=""
 I '$D(^VPRJDX("count","collection",CTN)) W !,"Collection not found." Q
 D DELCTN^VPRJD(CTN)
 I $G(HTTPERR) W !,"Error while deleting collection: ",HTTPERR
 Q
RESET ; Reset the non-patient data store (kill the data and re-initialize)
 N X
 W !,"Are you sure you want to delete the database? "
 R X:300 E  Q
 I $$UP^XLFSTR($E(X))'="Y" Q
 D KILLDB
 Q
KILLDB ; -- Delete and reset the globals for the database
 K ^VPRJD
 K ^VPRJDX
 K ^VPRJMETA
 K ^VPRTMP
 D SETUP^VPRJDMD
 Q

VPRJDMD^INT^1^62756,62812.812791^0
VPRJDMD ;SLC/KCM -- Set up Meta Data for Indexing
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SETUP ;
 K ^VPRJMETA
 S ^VPRJMETA("system")=$$SYSID^VPRJRUT()
 S ^VPRJMETA("version")="1.0 Build 26"
 ;
 D INDEXES
 D TEMPLTS
 Q
INDEXES ; -- build meta data for all indexes
 K ^VPRJMETA("index")
 K ^VPRJMETA("collection")
 D BLDIDXS("IDXTALLY","tally")
 D BLDIDXS("IDXATTR","attr")
 Q
BLDIDXS(TAG,IDXTYPE) ; build meta data for all indexes of a given type
 N I,X
 S I=0 F  S I=I+1,X=$P($T(@TAG+I^VPRJDMX),";;",2,99) Q:X="zzzzz"  I $E(X)]" " D BLDIDX(TAG,I,IDXTYPE)
 Q
BLDIDX(TAG,LINE,IDXTYPE) ; place information for single index into ^VPRJMETA
 N INDEX,IDXNAME,GROUP,I,X,C,VAL,COLL,SORT,SETIF,FIELDS,SUBFLDS,FTYPE,MATCH,ERROR
 S IDXNAME=$$TRIM^XLFSTR($P($P($T(@TAG+LINE^VPRJDMX),";;",2,99)," "))
 S SUBFLDS=0,FIELDS=0,SORT="",SETIF="",COLL=0,ERROR=0
 F  S LINE=LINE+1,X=$P($T(@TAG+LINE^VPRJDMX),";;",2,99) Q:X="zzzzz"  Q:$E(X)]" "  D
 . S GROUP=$$TRIM^XLFSTR($P(X,":")),X=$P(X,":",2,99)
 . I GROUP="collections" D  Q
 . . F I=1:1:$L(X,",") S VAL=$$TRIM^XLFSTR($P(X,",",I)) I $L(VAL) S COLL(VAL)=""
 . I GROUP="sort" S SORT=$$TRIM^XLFSTR(X) Q
 . I GROUP="setif" S SETIF=$$TRIM^XLFSTR(X) Q
 . I GROUP="values" D  Q
 . .  F I=1:1:$L(X,",") S VAL=VAL=$$TRIM^XLFSTR($P(X,",",I)) I $L(VAL) S MATCH(VAL)=""
 . I GROUP="fields" D  Q
 . . F I=1:1:$L(X,",") S VAL=$$TRIM^XLFSTR($P(X,",",I)) I $L(VAL) D
 . . . Q:VAL="<none>"
 . . . S FIELDS=FIELDS+1
 . . . S FIELDS(I)=$$TRIM^XLFSTR($P(VAL,"/")) ; name
 . . . I '$L(FIELDS(I)) S ERROR=1 W !,"Error: field name in ",IDXNAME
 . . . S FIELDS(I,"collate")=$$TRIM^XLFSTR($P(VAL,"/",2))
 . . . I '$L(FIELDS(I,"collate")) S FIELDS(I,"collate")=$S(IDXTYPE="tally":"p",1:"s")
 . . . S FIELDS(I,"ifNull")=$$TRIM^XLFSTR($P(VAL,"/",3))
 . . . I VAL["[]" S VAL=$P(VAL,"[]") I $L(VAL),'$D(SUBFLDS(VAL)) D
 . . . . S SUBFLDS=SUBFLDS+1,SUBFLDS(SUBFLDS)=VAL,SUBFLDS(VAL)=""
 . I $E(GROUP,1,7)="fields." D  Q
 . . S C=$P(GROUP,".",2)
 . . F I=1:1:$L(X,",") S VAL=$$TRIM^XLFSTR($P(X,",",I)) I $L(VAL) S FIELDS(C,I)=VAL
 ;
 S INDEX(IDXNAME)=IDXNAME
 F I=1:1:FIELDS S INDEX(IDXNAME,"common","collate",I)=FIELDS(I,"collate")
 F I=1:1:FIELDS S INDEX(IDXNAME,"common","field",FIELDS(I))=I
 F I=1:1:FIELDS S INDEX(IDXNAME,"common","ifNull",I)=FIELDS(I,"ifNull")
 S INDEX(IDXNAME,"common","method")=IDXTYPE
 S INDEX(IDXNAME,"common","levels")=FIELDS
 I $L($G(SORT)),(SORT'="<none>") S INDEX(IDXNAME,"common","order")=SORT
 I $L($G(SETIF)) S INDEX(IDXNAME,"common","setif")=SETIF
 F I=1:1:SUBFLDS S INDEX(IDXNAME,"common","subkey",SUBFLDS(I))=I
 ;
 S C="" F  S C=$O(COLL(C)) Q:C=""  D
 . S ^VPRJMETA("collection",C,"index",IDXNAME)=""
 . F I=1:1:FIELDS D
 . . K FTYPE
 . . I $D(FIELDS(C))>1 D:$D(FIELDS(C,I)) BLDFTYP^VPRJPQU(FIELDS(C,I),.FTYPE) I 1
 . . E  D BLDFTYP^VPRJPQU(FIELDS(I),.FTYPE)
 . . I $D(FTYPE) M INDEX(IDXNAME,"collection",C,I,"ftype")=FTYPE
 . . S INDEX(IDXNAME,"collection",C,I,"collate")=FIELDS(I,"collate")
 . . S INDEX(IDXNAME,"collection",C,I,"field")=$S($D(FIELDS(C))>1:$G(FIELDS(C,I)),1:FIELDS(I))
 . . S INDEX(IDXNAME,"collection",C,I,"ifNull")=$S($D(FIELDS(C))>1:$S($D(FIELDS(C,I)):FIELDS(I,"ifNull"),1:""),1:FIELDS(I,"ifNull"))
 . . S MATCH="" F  S MATCH=$O(MATCH(MATCH)) Q:MATCH=""  S ^VPRJMETA("match",C,FIELDS(I),MATCH,IDXNAME)=""
 M ^VPRJMETA("index")=INDEX
 Q
TEMPLTS ; -- Set the meta-information for the templates
 N I,J,X,COLL,TYPE,NAME,FIELDS
 K ^VPRJMETA("template")
 S I=1 F  S I=I+1,X=$P($T(TEMPLATE+I^VPRJDMT),";",3,99) Q:X="zzzzz"  D
 . S COLL=$P(X,","),TYPE=$P(X,",",2),NAME=$P(X,",",3),FIELDS=$P(X,",",4,99)
 . S ^VPRJMETA("template",COLL,NAME,"exclude")=+(TYPE="exclude")
 . F J=1:1:$L(FIELDS,",") S ^VPRJMETA("template",COLL,NAME,"fields",$P(FIELDS,",",J))=""
 Q

VPRJDMT^INT^1^62756,62812.817206^0
VPRJDMT ;SLC/KCM -- Meta data for JSON templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
EN ;
 Q
TEMPLATE ;;
 ;;coll,type,name,fields
 ;;test,include,test-summary,uid,name
 ;;zzzzz
 ;

VPRJDMX^INT^1^62766,48612.603398^0
VPRJDMX ;SLC/KCM -- Meta data for JSON indexes
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Types of collation:
 ;       V: Inverse HL7 Time (appends "=" after complementing time)
 ;       T: Forward HL7 Time (appends " " to time)
 ;       N: Numeric          (+value)
 ;       S: String           (appends " " to ensure string)
 ;       s: String           (case insensitive, appends " " to ensure string)
 ;       P: Plain            (uses value as is)
 ;       p: Plain            (case insensitive, use value as is)
 ;
 ; --------------------------------------------------------
 ; Tally time indexes maintain counts of each value a field takes on
 ; The definition structure is:
 ;
 ;;indexName
 ;;    fields.{collection}: {tallyField}
IDXTALLY ; tally type indexes
 ;;test-name-count
 ;;    collections: test
 ;;    fields: name
 ;;zzzzz
 ;
 ; --------------------------------------------------------
 ; Attribute type indexes index first by field, then by sort
 ; The first collation is the field collation, followed by the sort collation.
 ; The default is s,s (both case-insensitive strings) if no other collation
 ; is defined.
IDXATTR ;
 ;;test-name
 ;;    collections: test
 ;;    fields: name/s, updated/V/0
 ;;    sort: updated desc
 ;;vprupdate
 ;;    collections: vprupdate
 ;;zzzzz
 ;

VPRJDQ^INT^1^62781,64641.598897^0
VPRJDQ ;SLC/KCM -- Query for JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
QKEY(KEY,TEMPLATE) ; Return an object given the key (i.e., urn:va:fresh:93EF:10076)
 N VPRDATA,ORDER
 S TEMPLATE=$G(TEMPLATE)
 I '$D(^VPRJD("JSON",KEY)) D SETERROR^VPRJRUT(104,"UID:"_KEY) Q
 K ^TMP("VPRDATA",$J)
 S ^TMP("VPRDATA",$J,KEY,0)="",VPRDATA=1,ORDER(0)=0
 D BUILD^VPRJCU
 K ^TMP("VPRDATA",$J)
 Q
 ;
QTALLY(CNTNM) ; Return a set of counts
 ; return tallies as data:{items:[{"topic":"MEDICATION,INPT","count":4}
 I '$L(CNTNM) D SETERROR^VPRJRUT(101) Q
 N BUFFER S BUFFER=""
 ;
 N TOPIC,DATA,COUNT,X
 S DATA=0,TOPIC=""
 F  S TOPIC=$O(^VPRJDX("tally",CNTNM,TOPIC)) Q:TOPIC=""  D
 . S COUNT=+^VPRJDX("tally",CNTNM,TOPIC)
 . S X=$S('DATA:"",1:",")_"{""topic"":"""_TOPIC_""",""count"":"_COUNT_"}"
 . S DATA=DATA+1,DATA(DATA)=X
 S X=$$BLDHEAD^VPRJPQ(DATA) D STAGE^VPRJPQ(X)
 S DATA=0 F  S DATA=$O(DATA(DATA)) Q:'DATA  D STAGE^VPRJPQ(DATA(DATA))
 D STAGE^VPRJPQ("]}}"),OUT^VPRJPQ
 Q
 ;
 ;defined at the QINDEX level:
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequece of the returned valuse, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QINDEX(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; query based on index
 I '$L($G(INDEX)) D SETERROR^VPRJRUT(101) Q
 N VPRDATA,METHOD,CLAUSES
 S RANGE=$G(RANGE),ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 M INDEX=^VPRJMETA("index",INDEX,"common")
 S METHOD=$G(INDEX("method")) I '$L(METHOD) D SETERROR^VPRJRUT(102,INDEX) Q
 I $L(FILTER) D PARSE^VPRJPQF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDER^VPRJCU(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 I METHOD="attr" D QATTR^VPRJDQA
 D BUILD^VPRJCU
 K ^TMP("VPRDATA",$J)
 Q
QLAST(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; return most recent item in the list
 N IDXLAST S IDXLAST=1
 D QINDEX(INDEX,$G(RANGE),$G(ORDER),$G(BAIL),$G(TEMPLATE),$G(FILTER))
 Q
QFIND(COLL,ORDER,BAIL,TEMPLATE,FILTER) ; return items from collection without index
 N VPRDATA,CLAUSES,PREFIX,KEY
 S ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 I $L(FILTER) D PARSE^VPRJPQF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDF^VPRJCU(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 S PREFIX="urn:va:"_COLL_":",KEY=PREFIX
 F  S KEY=$O(^VPRJD(KEY)) Q:$E(KEY,1,$L(PREFIX))'=PREFIX  D ADDONE^VPRJDQA(KEY,0)
 D BUILD^VPRJCU
 K ^TMP("VPRDATA",$J)
 Q

VPRJDQA^INT^1^62756,62812.830977^0
VPRJDQA ;SLC/KCM -- Query using attribute indexes for JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;defined at the QINDEX level:
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequece of the returned valuse, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QATTR ; return items where attribute value is in range
 ; Build ^TMP("VPRDATA",$J,sortkey,sortkey,...,key,instances) with keys of objects to return
 ; Expects:  VPRDATA,METHOD,RANGE,INDEX,ORDER,CLAUSES,BAIL
 N START,STOP,DIR,SUB,KEY,INST
 D PARSERNG^VPRJPQU
 I $G(IDXLAST)=1 D  ; handle finding last or latest items
 . S DIR(INDEX("levels"))=$S(INDEX("collate",INDEX("levels"))="V":1,1:-1)
 . I INDEX("levels")=0  D L0 Q
 . I INDEX("levels")=1  D L1 Q
 . I INDEX("levels")=2  D L2 Q
 . I INDEX("levels")=3  D L3 Q
 E  D               ; normal search loops
 . I INDEX("levels")=0  D A0 Q
 . I INDEX("levels")=1  D A1 Q
 . I INDEX("levels")=2  D A2 Q
 . I INDEX("levels")=3  D A3 Q
 Q
A0 ; unsorted list
 S KEY="" F  S KEY=$O(^VPRJDX(METHOD,INDEX,KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
A1 ; sorted list / attribute only
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY="" F  S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST="" F  S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)=START(3) F  S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY="" F  S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST="" F  S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
NXT1() ;
 I START(1,"collate")="L" S SUB(1)=$O(START(1,"list",SUB(1))) Q SUB(1)
 Q $O(^VPRJDX(METHOD,INDEX,SUB(1)),DIR(1))
 ;
NXT2() ;
 I START(2,"collate")="L" S SUB(2)=$O(START(2,"list",SUB(2))) Q SUB(2)
 Q $O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2)),DIR(2))
 ;
NXT3() ;
 I START(3,"collate")="L" S SUB(3)=$O(START(3,"list",SUB(3))) Q SUB(3)
 Q $O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3)),DIR(3))
 ;
L0 ; unsorted list
 S KEY="" S KEY=$O(^VPRJDX(METHOD,INDEX,KEY),-1) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
L1 ; sorted list / attribute only
 S SUB(1)="" S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)="" S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)="" S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
ADDONE(KEY,INST,SUB) ; add uid, calculating new sort key if necessary
 ; Expects: .ORDER,.CLAUSES
 I $D(CLAUSES) Q:'$$EVALAND^VPRJPQF(.CLAUSES,KEY)  ;apply filter, quit if not true
 N I,SORT,KINST
 S I=0 F  S I=$O(ORDER(I)) Q:'I  S SORT(I)=$S(+ORDER(I):SUB(+ORDER(I)),1:$$SORTVAL(I))
 S VPRDATA=VPRDATA+1
 ; case
 I ORDER(0)=0 S ^TMP("VPRDATA",$J,KEY,INST)="" G X1
 I ORDER(0)=1 S ^TMP("VPRDATA",$J,SORT(1),KEY,INST)="" G X1
 I ORDER(0)=2 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY,INST)="" G X1
 I ORDER(0)=3 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY,INST)="" G X1
 I ORDER(0)=4 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY,INST)="" G X1
 I ORDER(0)=5 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY,INST)="" G X1
 I ORDER(0)=6 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY,INST)="" G X1
 I ORDER(0)=7 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY,INST)="" G X1
X1 ; end case
 Q
 ;
SORTVAL(I) ; return the value for the field
 ; Expects: .SUB,.ORDER,.KEY
 N X,FTYPE
 S X=0
 M FTYPE=ORDER(I,"ftype")
 ; case
 I FTYPE=1 S X=$G(^VPRJD(KEY,FTYPE("field")),0) G X2
 I FTYPE=2 S X=$G(^VPRJD(KEY,FTYPE("field"),FTYPE("sub")),0) G X2
 S I=$G(INDEX("key",ORDER(I,"mult")))
 Q:'$G(SUB(I)) 0
 I FTYPE=3 S X=$G(^VPRJD(KEY,FTYPE("mult"),SUB(I),FTYPE("field")),0) G X2
 I FTYPE=4 S X=$G(^VPRJD(KEY,FTYPE("mult"),SUB(I),FTYPE("field"),FTYPE("sub")),0) G X2
X2 ; end case
 I $D(^("\s")) S X=X_" " ; naked set to last $G, append space to force string
 Q X
 ;

VPRJDR^INT^1^62766,48888.816162^0
VPRJDR ;SLC/KCM -- Handle RESTful operations for data objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PUTOBJ(ARGS,BODY) ; PUTs an object into the database
 Q "/data/"_$$SAVE^VPRJD(.BODY)
 ;
NEWOBJ(ARGS,BODY) ; PUTs an object into the database, returning UID
 N OBJECT,ERR,UID,CTN
 S CTN=ARGS("collectionName")
 I '$L(CTN) D SETERROR^VPRJRUT(215) QUIT ""
 D DECODE^VPRJSON("BODY","OBJECT","ERR") I $D(ERR) D SETERROR^VPRJRUT(202) QUIT ""
 I $G(OBJECT("uid"))="" S OBJECT("uid")=$$BLDUID(CTN) I '$L(OBJECT("uid")) QUIT ""
 K BODY
 D ENCODE^VPRJSON("OBJECT","BODY","ERR") I $D(ERR) D SETERROR^VPRJRUT(202) QUIT ""
 Q "/data/"_$$SAVE^VPRJD(.BODY)
 ;
BLDUID(CTN) ; build the uid for a new item in a collection
 N UID
 I '$L(CTN) Q ""
 L +^VPRJD("COLLECTION",CTN):2 E  D SETERROR^VPRJRUT(502) Q ""
 S UID=$G(^VPRJD("COLLECTION",CTN))+1,^VPRJD("COLLECTION",CTN)=UID
 L -^VPRJD("COLLECTION",CTN)
 Q "urn:va:"_CTN_":"_$G(^VPRJMETA("system"))_":"_UID
 ;
GETOBJ(RESULT,ARGS) ; gets an object given a UID
 I $$UNKARGS^VPRJCU(.ARGS,"uid,template") Q
 D QKEY^VPRJDQ($G(ARGS("uid")),$G(ARGS("template")))
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
INDEX(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,range,order,bail,template,filter,start") Q
 N INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 ;
 ; check to see if we can return a cached result
 N HASHSTR,HASHTS,HASH
 S HASHSTR="data/index/"_INDEX_"/"_RANGE_"/"_ORDER_"/"_TEMPLATE_"/"_FILTER
 I $$CACHED(INDEX,HASHSTR,.HASH,.HASHTS) D  Q
 . S RESULT=$NA(^VPRTMP(HASH)),RESULT("pageable")=""
 ;
 ; otherwise prepare cache and do the regular query
 S ^TMP($J,"query")=HASHSTR,^TMP($J,"timestamp")=HASHTS
 S ^TMP($J,"index")=INDEX,^TMP($J,"hash")=HASH
 D QINDEX^VPRJDQ(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
CACHED(INDEX,HASHSTR,HASH,HASHTS) ; return TRUE if query cached and the cache is current
 ; .HASH returns the hashed value of HASHSTR
 ; .HASHTS returns the current $H of the index used
 Q:'$L(INDEX) 0
 N MTHD
 S MTHD=$G(^VPRJMETA("index",INDEX,"common","method"))
 S HASHTS=$G(^VPRJDX(MTHD,INDEX))
 S HASH=$$HASH^VPRJRUT(HASHSTR)
 I '$D(^VPRTMP(HASH,"query")) Q 0        ; no cached data
 I ^VPRTMP(HASH,"query")'=HASHSTR Q 0    ; hash matched, but not original string
 I ^VPRTMP(HASH,"timestamp")=HASHTS Q 1  ; timestamps match, quit true
 Q 0                                     ; default to no cached data
 ;
LAST(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,range,order,bail,template,filter") Q
 N INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 D QLAST^VPRJDQ(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
FIND(RESULT,ARGS) ; GET for objects using 'where' criteria
 I $$UNKARGS^VPRJCU(.ARGS,"collection,order,bail,template,filter") Q
 N COLL,ORDER,BAIL,TEMPLATE,FILTER
 S COLL=$G(ARGS("collection"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 D QFIND^VPRJDQ(COLL,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
COUNT(RESULT,ARGS) ; GET for count of domain objects
 I $$UNKARGS^VPRJCU(.ARGS,"countName") Q
 D QTALLY^VPRJDQ(ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
DELUID(RESULT,ARGS) ; DELETE an object
 I $$UNKARGS^VPRJCU(.ARGS,"uid") Q
 D DELETE^VPRJD(ARGS("uid"))
 S RESULT=$NA(^TMP($J))
 Q
DELCTN(RESULT,ARGS) ; DELETE an entire collection
 I $$UNKARGS^VPRJCU(.ARGS,"collectionName") Q
 D DELCTN^VPRJD(ARGS("collectionName"))
 S RESULT=$NA(^TMP($J))
 Q
DELALL(RESULT,ARGS) ; DELETE the entire non-patient data store
 I $$UNKARGS^VPRJCU(.ARGS,"confirm") Q
 I $G(ARGS("confirm"))'="true" D SETERROR^VPRJRUT(405) Q
 D KILLDB^VPRJDM
 S RESULT=""
 Q

VPRJDX^INT^1^62781,64648.681084^0
VPRJDX ;SLC/KCM -- Index a JSON object
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
INDEX(KEY,OLDOBJ,NEWOBJ) ; Index this object identified by its KEY
 N IDXCOLL,IDXNAME
 ; Currently assuming UID is urn:va:collection:vistaAccount:...
 ; For example:  urn:va:fresh:93EF
 S IDXCOLL=$P(KEY,":",3)
 S IDXNAME="" F  S IDXNAME=$O(^VPRJMETA("collection",IDXCOLL,"index",IDXNAME)) Q:IDXNAME=""  D
 . N IDXMETA
 . M IDXMETA=^VPRJMETA("index",IDXNAME,"collection",IDXCOLL)
 . S IDXMETA("setif")=$G(^VPRJMETA("index",IDXNAME,"common","setif"))
 . S IDXMETA("review")=$G(^VPRJMETA("index",IDXNAME,"common","review"))
 . S IDXMETA("levels")=$G(^VPRJMETA("index",IDXNAME,"common","levels"))
 . S IDXMETA("method")=^VPRJMETA("index",IDXNAME,"common","method")
 . I IDXMETA("method")="tally" D TALLY Q
 . I IDXMETA("method")="attr"  D ATTRIB Q
 D COUNTS
 Q
 ;
 ; ----- Maintain counts of objects -----
 ;
COUNTS ; set counts for different collection types
 N DOMAIN
 D KCOUNT("collection",IDXCOLL,.OLDOBJ)
 D SCOUNT("collection",IDXCOLL,.NEWOBJ)
 Q
SCOUNT(GROUP,TOPIC,OBJECT) ; Increment a count index
 Q:$D(OBJECT)<10
 N TALLY
 L +^VPRJDX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRUT(502,GROUP_" "_TOPIC) QUIT
 S TALLY=+$G(^VPRJDX("count",GROUP,TOPIC))
 S ^VPRJDX("count",GROUP,TOPIC)=TALLY+1 ; incr count across patients
 L -^VPRJDX("count",GROUP,TOPIC)
 Q
KCOUNT(GROUP,TOPIC,OBJECT) ; Decrement a count index
 Q:$D(OBJECT)<10
 N TALLY
 L +^VPRJDX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRUT(502,GROUP_" "_TOPIC) QUIT
 S TALLY=+$G(^VPRJDX("count",GROUP,TOPIC))
 S ^VPRJDX("count",GROUP,TOPIC)=TALLY-1 ; decr count across patients
 L -^VPRJDX("count",GROUP,TOPIC)
 Q
 ;
 ; ----- Index Logic: tally by attribute value -----
 ;
TALLY ; TALLY index ("tally",group,value)=tally
 ; if FIELD has no value, count is not changed
 D KTALLY(.OLDOBJ)
 D STALLY(.NEWOBJ)
 S ^VPRJDX("tally",IDXNAME)=$H
 Q
STALLY(OBJECT) ; Increment a tally index
 Q:$D(OBJECT)<10
 N VALUES,I,TALLY
 D SETVALS^VPRJPX(.OBJECT,.VALUES) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S TALLY=+$G(^VPRJDX("tally",IDXNAME,VALUES(I,1)))
 . S ^VPRJDX("tally",IDXNAME,VALUES(I,1))=TALLY+1
 Q
KTALLY(OBJECT) ; Decrement a tally index
 Q:$D(OBJECT)<10
 N VALUES,I,TALLY
 D SETVALS^VPRJPX(.OBJECT,.VALUES) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S TALLY=+$G(^VPRJDX("tally",IDXNAME,VALUES(I,1)))
 . S ^VPRJDX("tally",IDXNAME,VALUES(I,1))=TALLY-1
 . I ^VPRJDX("tally",IDXNAME,VALUES(I,1))=0 K ^VPRJDX("tally",IDXNAME,VALUES(I,1))
 Q
 ;
 ; ----- Index Logic: attributes -----
 ;
ATTRIB ; ATTRIBUTE index ("attr",group,value,sort,key)
 D KATTRIB(.OLDOBJ)
 D SATTRIB(.NEWOBJ)
 S ^VPRJDX("attr",IDXNAME)=$H
 Q
SATTRIB(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ; SETIF conditional statement is in format "$$TAG^ROUTINE"
 N OK,SETIF
 S OK=1
 I $L(IDXMETA("setif")) S OK=0,SETIF=IDXMETA("setif")_"(.OBJECT)" I @SETIF S OK=1
 Q:'OK
 I $L(IDXMETA("review")) D
 . N REVIEW,REVTM
 . S REVIEW="S REVTM="_REVIEW_"(.OBJECT)" X REVIEW
 . S ^VPRJDX("keyReview",KEY,IDXNAME)=REVTM
 . S ^VPRJDX("review",REVTM,KEY,IDXNAME)=""
 ;
 I IDXMETA("levels")=0  D SA0  Q
 ;
 N VALUES,I
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 Q:'$D(VALUES)
 I IDXMETA("levels")=1  D SA1  Q
 I IDXMETA("levels")=2  D SA2  Q
 I IDXMETA("levels")=3  D SA3  Q
 Q
KATTRIB(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ;
 I $L(IDXMETA("review")) D
 . N REVTM
 . S REVTM=$G(^VPRJDX("keyReview",KEY,IDXNAME)) Q:'$L(REVTM)
 . K ^VPRJDX("keyReview",KEY,IDXNAME)
 . K ^VPRJDX("review",REVTM,KEY,IDXNAME)
 ;
 I IDXMETA("levels")=0  D KA0  Q
 ;
 N VALUES,I
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 Q:'$D(VALUES)
 I IDXMETA("levels")=1  D KA1  Q
 I IDXMETA("levels")=2  D KA2  Q
 I IDXMETA("levels")=3  D KA3  Q
 Q
SA0 ; unsorted list set logic
 S ^VPRJDX("attr",IDXNAME,KEY)=""
 Q
KA0 ; unsorted list kill logic
 K ^VPRJDX("attr",IDXNAME,KEY)
 Q
SA1 ; one attribute set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRJDX("attr",IDXNAME,VALUES(I,1),KEY,I)=""
 Q
KA1 ; one attribute kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRJDX("attr",IDXNAME,VALUES(I,1),KEY,I)
 Q
SA2 ; two attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRJDX("attr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)=""
 Q
KA2 ; two attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRJDX("attr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)
 Q
SA3 ; three attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRJDX("attr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)=""
 Q
KA3 ; three attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRJDX("attr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)
 Q
 ;

VPRJFPS^INT^1^62760,82775.143477^0
VPRJFPS ;SLC/KCM -- Set/Kill Indexes for Medications
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
VALID(MED) ; Return true if required fields for indexing are present
 I '$L($G(MED("facility"))) Q 0
 Q 1
 ;
IACT(MED) ; Return true if active inpatient med
 Q:'$L($G(MED("medStatus"))) 0
 Q:MED("medStatus")'=VPRCONST("SCT_MED_STATUS_ACTIVE") 0
 Q:$G(MED("IMO")) 0 ; inpatient med for outpatient
 Q:$G(MED("medType"))'=VPRCONST("SCT_MED_TYPE_GENERAL") 0
 Q 1
 ;
OACT(MED) ; Return true if active outpatient med
 Q:'$L($G(MED("medStatus"))) 0
 Q:MED("medStatus")'=VPRCONST("SCT_MED_STATUS_ACTIVE") 0
 Q:$G(MED("IMO"))!($G(MED("medType"))=VPRCONST("SCT_MED_TYPE_GENERAL")) 0
 Q 1
 ;
MICRO(LAB) ; Return true if microbiology test
 ;Q:$G(LAB("kind"))="Microbiology" 1  ; can't do this easily -- kind is buried in result
 Q:$E($G(LAB("localId")),1,2)="MI" 1  ; need to change since this is VA-specific
 Q 0
 ;
PATH(LAB) ; Return true if pathology test
 N X S X=$E($G(LAB("localId")),1,2)
 I (X'="CH"),(X'="MI") Q 1            ; temporary work-around -- this is VA-specific
 Q 0
RSLT(LAB) ; Return true if lab result
 I $D(LAB("typeName")) Q 1
 Q 0
ACC(LAB) ; Return true if accession
 I $G(LAB("organizerType"))="accession" Q 1
 Q 0
VS(VITAL) ; Return true if vital sign result
 I $D(VITAL("typeName")) Q 1
 Q 0
CWAD(DOC) ; Return true if CWAD document
 ;Advance Directive,Crisis Note,Allergy/Adverse Reaction,Clinical Warning,ALERT
 N X,DOCFLD
 S X=$P($T(CWAD+1),";",2,99)
 S DOCFLD=$G(DOC("documentTypeName"))
 I $G(DOCFLD)="" S DOCFLD=$G(DOC("kind"))
 I $G(DOCFLD)="" Q 0
 I X[DOCFLD Q 1
 Q 0
CURVISIT(VISIT) ; Return true if checked-in, and not checked-out.
 I $G(VISIT("current"))="true" Q 1
 Q 0

VPRJM^INT^1^62756,62812.851149^0
VPRJM ;SLC/KCM -- Set up Meta Data for VPR Indexing
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SETUP ;
 K ^VPRMETA
 S ^VPRMETA("version")="1.0 Build 26"
 ;
 D INDEXES
 D DOMAINS
 D TEMPLTS
 ;
 ; "every" index is special index that references all the UID's for a patient
 S ^VPRMETA("index","every")="every"
 S ^VPRMETA("index","every","common","levels")=0
 S ^VPRMETA("index","every","common","method")="every"
 ;
 S ^VPRMETA("codes","med","productFormCode")=""
 S ^VPRMETA("codes","med","medStatus")=""
 S ^VPRMETA("codes","med","medType")=""
 S ^VPRMETA("codes","med","products[]","ingredientCode")=""
 S ^VPRMETA("codes","med","products[]","drugClassCode")=""
 S ^VPRMETA("codes","med","products[]","suppliedCode")=""
 S ^VPRMETA("codes","med","products[]","ingredientRole")=""
 S ^VPRMETA("codes","med","dosages[]","routeCode")=""
 S ^VPRMETA("codes","med","dosages[]","bodySite")=""
 S ^VPRMETA("codes","med","fills[]","fillStatus")=""
 ;
 L +^VPRPT("PID"):2 E  QUIT
 I '$G(^VPRPT("PID")) S ^VPRPT("PID")=0 ; initialize PID counter
 I '$D(^VPRPTX("count","patient","patient")) S ^VPRPTX("count","patient","patient")=0
 L -^VPRPT("PID")
 Q
INDEXES ; -- build meta data for all indexes
 K ^VPRMETA("index")
 K ^VPRMETA("collection")
 D BLDIDXS("IDXLIST","attr")
 D BLDIDXS("IDXTALLY","tally")
 D BLDIDXS("IDXTIME","time")
 D BLDIDXS("IDXATTR","attr")
 ;D BLDIDXS("IDXMATCH","match")
 Q
BLDIDXS(TAG,IDXTYPE) ; build meta data for all indexes of a given type
 N I,X
 S I=0 F  S I=I+1,X=$P($T(@TAG+I^VPRJMDX),";;",2,99) Q:X="zzzzz"  I $E(X)]" " D BLDIDX(TAG,I,IDXTYPE)
 Q
BLDIDX(TAG,LINE,IDXTYPE) ; place information for single index into ^VPRMETA
 N INDEX,IDXNAME,GROUP,I,X,C,VAL,COLL,SORT,SETIF,FIELDS,SUBFLDS,FTYPE,MATCH,ERROR
 S IDXNAME=$$TRIM^XLFSTR($P($P($T(@TAG+LINE^VPRJMDX),";;",2,99)," "))
 S SUBFLDS=0,FIELDS=0,SORT="",SETIF="",COLL=0,ERROR=0
 F  S LINE=LINE+1,X=$P($T(@TAG+LINE^VPRJMDX),";;",2,99) Q:X="zzzzz"  Q:$E(X)]" "  D
 . S GROUP=$$TRIM^XLFSTR($P(X,":")),X=$P(X,":",2,99)
 . I GROUP="collections" D  Q
 . . F I=1:1:$L(X,",") S VAL=$$TRIM^XLFSTR($P(X,",",I)) I $L(VAL) S COLL(VAL)=""
 . I GROUP="sort" S SORT=$$TRIM^XLFSTR(X) Q
 . I GROUP="setif" S SETIF=$$TRIM^XLFSTR(X) Q
 . I GROUP="values" D  Q
 . .  F I=1:1:$L(X,",") S VAL=VAL=$$TRIM^XLFSTR($P(X,",",I)) I $L(VAL) S MATCH(VAL)=""
 . I GROUP="fields" D  Q
 . . F I=1:1:$L(X,",") S VAL=$$TRIM^XLFSTR($P(X,",",I)) I $L(VAL) D
 . . . Q:VAL="<none>"
 . . . S FIELDS=FIELDS+1
 . . . S FIELDS(I)=$$TRIM^XLFSTR($P(VAL,"/")) ; name
 . . . I '$L(FIELDS(I)) S ERROR=1 W !,"Error: field name in ",IDXNAME
 . . . S FIELDS(I,"collate")=$$TRIM^XLFSTR($P(VAL,"/",2))
 . . . I '$L(FIELDS(I,"collate")) S FIELDS(I,"collate")=$S(IDXTYPE="tally":"p",1:"s")
 . . . S FIELDS(I,"ifNull")=$$TRIM^XLFSTR($P(VAL,"/",3))
 . . . I VAL["[]" S VAL=$P(VAL,"[]") I $L(VAL),'$D(SUBFLDS(VAL)) D
 . . . . S SUBFLDS=SUBFLDS+1,SUBFLDS(SUBFLDS)=VAL,SUBFLDS(VAL)=""
 . I $E(GROUP,1,7)="fields." D  Q
 . . S C=$P(GROUP,".",2)
 . . F I=1:1:$L(X,",") S VAL=$$TRIM^XLFSTR($P(X,",",I)) I $L(VAL) S FIELDS(C,I)=VAL
 ;
 S INDEX(IDXNAME)=IDXNAME
 F I=1:1:FIELDS S INDEX(IDXNAME,"common","collate",I)=FIELDS(I,"collate")
 F I=1:1:FIELDS S INDEX(IDXNAME,"common","field",FIELDS(I))=I
 F I=1:1:FIELDS S INDEX(IDXNAME,"common","ifNull",I)=FIELDS(I,"ifNull")
 S INDEX(IDXNAME,"common","method")=IDXTYPE
 S INDEX(IDXNAME,"common","levels")=FIELDS
 I $L($G(SORT)),(SORT'="<none>") S INDEX(IDXNAME,"common","order")=SORT
 I $L($G(SETIF)) S INDEX(IDXNAME,"common","setif")=SETIF
 F I=1:1:SUBFLDS S INDEX(IDXNAME,"common","subkey",SUBFLDS(I))=I
 ;
 S C="" F  S C=$O(COLL(C)) Q:C=""  D
 . S ^VPRMETA("collection",C,"index",IDXNAME)=""
 . F I=1:1:FIELDS D
 . . K FTYPE
 . . I $D(FIELDS(C))>1 D:$D(FIELDS(C,I)) BLDFTYP^VPRJPQU(FIELDS(C,I),.FTYPE) I 1
 . . E  D BLDFTYP^VPRJPQU(FIELDS(I),.FTYPE)
 . . I $D(FTYPE) M INDEX(IDXNAME,"collection",C,I,"ftype")=FTYPE
 . . S INDEX(IDXNAME,"collection",C,I,"collate")=FIELDS(I,"collate")
 . . S INDEX(IDXNAME,"collection",C,I,"field")=$S($D(FIELDS(C))>1:$G(FIELDS(C,I)),1:FIELDS(I))
 . . S INDEX(IDXNAME,"collection",C,I,"ifNull")=$S($D(FIELDS(C))>1:$S($D(FIELDS(C,I)):FIELDS(I,"ifNull"),1:""),1:FIELDS(I,"ifNull"))
 . . S MATCH="" F  S MATCH=$O(MATCH(MATCH)) Q:MATCH=""  S ^VPRMETA("match",C,FIELDS(I),MATCH,IDXNAME)=""
 M ^VPRMETA("index")=INDEX
 Q
DOMAINS ; -- Map collections to domains
 N I,X,COLL,DOMAIN
 S I=0 F  S I=I+1,X=$P($T(DOMAIN+I^VPRJMDX),";;",2,99) Q:X="zzzzz"  D
 . S COLL=$P(X,":"),DOMAIN=$P(X,":",2)
 . S ^VPRMETA("collection",COLL,"domain")=DOMAIN
 Q
 ;
TEMPLTS ; -- Set the meta-information for the templates
 N I,J,X,COLL,TYPE,NAME,FIELDS
 K ^VPRMETA("template")
 S I=1 F  S I=I+1,X=$P($T(TEMPLATE+I^VPRJMDT),";",3,99) Q:X="zzzzz"  D
 . S COLL=$P(X,","),TYPE=$P(X,",",2),NAME=$P(X,",",3),FIELDS=$P(X,",",4,99)
 . S ^VPRMETA("template",COLL,NAME,"exclude")=+(TYPE="exclude")
 . F J=1:1:$L(FIELDS,",") S ^VPRMETA("template",COLL,NAME,"fields",$P(FIELDS,",",J))=""
 Q

VPRJMDT^INT^1^62756,62812.855698^0
VPRJMDT ;SLC/KCM -- Meta data for JSON templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
EN ;
 Q
TEMPLATE ;;
 ;;coll,type,name,fields
 ;;art,include,summary,uid,facilityName,summary
 ;;cons,include,summary,uid,typeName,dateTime,facilityName
 ;;tiu,include,summary,uid,facilityName,referenceDateTime,localTitle,subject
 ;;visit,include,summary,uid,kind,facilityName,locationName,specialty
 ;;appt,include,summary,uid,kind,facilityName,locationName,specialty
 ;;hf,include,summary,uid,recorded,summary,facilityName
 ;;imm,include,summary,uid,summary,administeredDateTime,facilityName
 ;;med,include,summary,uid,summary,overallStart,overallStop,medStatusName,facilityName
 ;;obs,include,summary,uid,observed,summary,facilityName
 ;;order,include,summary,uid,summary,start,stop,facilityName
 ;;prob,include,summary,uid,summary,statusName,facilityName
 ;;pat,include,summary,uid,dateOfBirth,familyName,givenNames,genderName,ssn,icn
 ;;proc,include,summary,uid,typeName,dateTime,facilityName
 ;;surgery,include,summary,uid,typeName,dateTime,facilityName
 ;;rad,include,summary,uid,typeName,dateTime,facilityName
 ;;lab,include,summary,uid,facilityName,observed,typeName,specimen,result,units,interpretationName,low,high
 ;;vs,include,summary,uid,facilityName,observed,typeName,result,units,interpretationName,low,high
 ;;tiu,exclude,notext,content,text
 ;;med,include,dose,uid,qualifiedName,kind,medStatusName,facilityName,lastFilled,vaStatus,vaType,overallStart,overallStop,dosages[].dose,dosages[].start,dosages[].stop,dosages[].relativeStop,dosages[].relativeStart,orders[].fillsRemaining,orders[].daysSupply,orders[].quantityOrdered,orders[].predecessor,orders[].successor
 ;;zzzzz
 ;

VPRJMDX^INT^1^62760,82775.15583^0
VPRJMDX ;SLC/KCM -- Meta data for JSON indexes
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Types of collation:
 ;       V: Inverse HL7 Time (appends "=" after complementing time)
 ;       T: Forward HL7 Time (appends " " to time)
 ;       N: Numeric          (+value)
 ;       S: String           (appends " " to ensure string)
 ;       s: String           (case insensitive, appends " " to ensure string)
 ;       P: Plain            (uses value as is)
 ;       p: Plain            (case insensitive, use value as is)
 ;
 ; --------------------------------------------------------
 ; List type indexes are special case of attribute indexes.  The have 0 or 1
 ; fields, used for default sorting.  The definition structure is:
 ;
 ;;indexName
 ;;    collections: {collection}, {collection}, ...
 ;;    fields: {fieldName}({collation},{ifNull})  -or-  <none>
 ;;    sort:  {default orderBy string}  -or-  <none>
IDXLIST ; list type indexes (sortType defaults to string)
 ;;allergy
 ;;    collections: art
 ;;    fields: <none>
 ;;    sort: <none>
 ;;consult
 ;;    collections: cons
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;document
 ;;    collections: tiu
 ;;    fields: referenceDateTime/V/0
 ;;    sort: referenceDateTime desc
 ;;encounter
 ;;    collections: visit, appt
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;healthfactor
 ;;    collections: hf
 ;;    fields: recorded/V/0
 ;;    sort: recorded desc
 ;;imaging
 ;;    collections: rad
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;immunization
 ;;    collections: imm
 ;;    fields: administeredDateTime/V/0
 ;;    sort: adminisiteredDateTime desc
 ;;laboratory
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$RSLT^VPRJFPS
 ;;result
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$RSLT^VPRJFPS
 ;;accession
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$ACC^VPRJFPS 
 ;;medication
 ;;    collections: med
 ;;    fields: overallStop/V/0
 ;;    sort: overallStop desc
 ;;microbiology
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$MICRO^VPRJFPS
 ;;observation
 ;;    collections: obs
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;order
 ;;    collections: order
 ;;    fields: entered/V/0
 ;;    sort: entered desc
 ;;pathology
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$PATH^VPRJFPS
 ;;problem
 ;;    collections: prob
 ;;    fields: <none>
 ;;    sort: <none>
 ;;procedure
 ;;    collections: proc,surgery,rad,cons
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;vitalsign
 ;;    collections: vs
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$VS^VPRJFPS
 ;;notesview
 ;;    collections: tiu, proc, surgery, rad, cons
 ;;    fields: dateTime/V/0
 ;;    fields.tiu: referenceDateTime
 ;;    sort: dateTime desc
 ;;cwad
 ;;    collections: tiu, art, alert
 ;;    fields: referenceDateTime/V/0
 ;;    sort: referenceDateTime desc
 ;;    setif: $$CWAD^VPRJFPS
 ;;med-active-inpt
 ;;    collections: med
 ;;    fields: overallStop/V/9
 ;;    sort: overallStop desc
 ;;    setif: $$IACT^VPRJFPS
 ;;med-active-outpt
 ;;    collections: med
 ;;    fields: overallStop/V/9
 ;;    sort: overallStop desc
 ;;    setif: $$OACT^VPRJFPS 
 ;;appointment
 ;;    collections: appt
 ;;    fields: dateTime/V/9
 ;;    sort: dateTime desc
 ;;curvisit
 ;;    collections: visit
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;    setif: $$CURVISIT^VPRJFPS
 ;;task
 ;;    collections: task
 ;;    fields: <none>
 ;;    sort: <none>
 ;;diagnosis
 ;;    collections: diagnosis
 ;;    fields: <none>
 ;;    sort: <none>
 ;;zzzzz
 ;
 ; --------------------------------------------------------
 ; Tally time indexes maintain counts of each value a field takes on
 ; The definition structure is:
 ;
 ;;indexName
 ;;    fields.{collection}: {tallyField}
IDXTALLY ; tally type indexes
 ;;kind
 ;;    collections: lab, med, vs
 ;;    fields: kind
 ;;lab-count-name
 ;;    collections: lab
 ;;    fields: qualifiedName
 ;;vs-count-name
 ;;    collections: vs
 ;;    fields: typeName
 ;;zzzzz
 ;
 ; --------------------------------------------------------
 ; Time type indexes organize data by start and stop times.
 ; the structure is:
 ; 
 ;;indexName
 ;;    fields.{collection}: {startField}, {stopField}
IDXTIME ; time type indexes
 ;;all-time
 ;;    collections: lab, vs, med
 ;;    fields: start/V/0, stop/V/9
 ;;    fields.lab: observed
 ;;    fields.med: overallStart, overallStop
 ;;    fields.vs: observed
 ;;    sort: observed desc
 ;;lab-time
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;med-time
 ;;    collections: med
 ;;    fields: overallStart/V/0, overallStop/V/9
 ;;    sort: overallStart desc
 ;;vs-time
 ;;    collections: vs
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;visit-time
 ;;    collections:visit
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;zzzzz
 ;
 ; --------------------------------------------------------
 ; Attribute type indexes index first by field, then by sort
 ; The first collation is the field collation, followed by the sort collation.
 ; The default is s,s (both case-insensitive strings) if no other collation
 ; is defined.
IDXATTR ;
 ;;lab-lnc-code
 ;;    collections: lab
 ;;    fields: lnccodes2[].uid/s, observed/V/0
 ;;    sort: observed desc
 ;;lab-type
 ;;    collections: lab
 ;;    fields: typeName/s, observed/V/0
 ;;    sort: observed desc
 ;;vs-type
 ;;    collections: vs
 ;;    fields: typeName/s, observed/V/0
 ;;    sort: observed desc
 ;;lab-qualified-name
 ;;    collections: lab
 ;;    fields: qualifiedName/s, observed/V/0
 ;;    sort: observed desc
 ;;vs-qualified-name
 ;;    collections: vs
 ;;    fields: qualifiedName/s, observed/V/0
 ;;    sort: observed desc
 ;;med-qualified-name
 ;;    collections: med
 ;;    fields: qualifiedName/s, overallStop/V/0
 ;;    sort: overallStop desc
 ;;med-class-code
 ;;    collections: med
 ;;    fields: products[].drugClassCode/s, overallStop/V/0
 ;;    sort: overallStop desc
 ;;med-ingredient-name
 ;;    collections: med
 ;;    fields: products[].ingredientName/s, overallStop/V/0
 ;;    sort: overallStop desc
 ;;med-provider
 ;;    collections: med
 ;;    fields: orders[].provider.name/s, overallStop/V/0
 ;;    sort: overallStop desc
 ;;visit-stop-code
 ;;    collections: visit
 ;;    fields: stopCodeUid/S, dateTime/V
 ;;    sort: dateTime desc
 ;;proc-type
 ;;    collections: cons
 ;;    fields: typeName/s, dateTime/V/0
 ;;imm-name
 ;;    collections: imm
 ;;    fields: name/s, administeredDateTime/V/0
 ;;    sort: adminisiteredDateTime desc
 ;;provider
 ;;    collections: art,cons,tiu,visit,appt,imm,med,order,prob,proc,surgery,rad
 ;;    fields: providerName/s, dateTime/V
 ;;    fields.art: enteredByName, entered
 ;;    fields.art: verifiedByName, entered
 ;;    fields.cons: providers[].provider.name, dateTime
 ;;    fields.tiu: clinicians[].clinician.name, referenceDateTime
 ;;    fields.visit: providers[].provider.name, dateTime
 ;;    fields.appt: providers[].provider.name, dateTime
 ;;    fields.imm: perfomer, administeredDateTime
 ;;    fields.med: orders[].provider.name, overallStop
 ;;    fields.order: providerName, start
 ;;    fields.prob: providerName, updated
 ;;    fields.proc: providers[].provider.name, dateTime
 ;;    fields.surgery: providers[].provider.name, dateTime
 ;;    fields.rad: providers[].provider.name, dateTime
 ;;    sort: dateTime desc, providerName asc
 ;;alert
 ;;    collections: alert
 ;;    fields: links[].uid
 ;;    sort: referenceDateTime desc
 ;;zzzzz
 ;
 ; --------------------------------------------------------
IDXMATCH ; match type indexes (sortType defaults to string)
 ;;condition.hyperlipidemia
 ;;    collections: med
 ;;    fields: products[].ingredientName
 ;;    values: SIMVASTATIN
 ;;condition.cardiac
 ;;    collections: med
 ;;    fields: products[].drugClassCode
 ;;    values: urn:vadc:CV050,urn:vadc:CV100,urn:vadc:CV702,urn:vadc:CV250
 ;;condition.bleedingrisk
 ;;    collections: med
 ;;    fields:products[].drugClassCode
 ;;    values: urn:vadc:BL110
 ;;condition.diabetes
 ;;    collections: med
 ;;    fields: products[].drugClassCode
 ;;    values: urn:vadc:HS502
 ;;zzzzz
 ;
DOMAIN ; map collections to domains
 ;;art:allergy
 ;;tiu:document
 ;;visit:encounter
 ;;appt:encounter
 ;;hf:healthfactor
 ;;imm:immunization
 ;;med:medication
 ;;obs:observation
 ;;order:order
 ;;cons:consult
 ;;proc:procedure
 ;;surgery:procedure
 ;;rad:procedure
 ;;cons:procedure
 ;;prob:problem
 ;;lab:laboratory
 ;;vs:vitalsign
 ;;pat:demographics
 ;;task:task
 ;;diagnosis:diagnosis
 ;;zzzzz

VPRJP^INT^1^62756,62812.868813^0
VPRJP ;SLC/KCM -- Save / Retrieve Patient-Related JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SAVE(PID,JSON) ; Save a JSON encoded object
 N UID,COLL,KEY,OBJECT,OLDOBJ,VPRJERR,INDEXER,TLTARY
 ;
 ; decode JSON into object and extract required fields
 D DECODE^VPRJSON("JSON","OBJECT","VPRJERR")
 I $L($G(VPRJERR)) D SETERROR^VPRJRUT(202,VPRJERR) QUIT ""
 ;I PID'=$G(OBJECT("patient")) D SETERROR^VPRJRUT(205,$G(OBJECT("patient"))) QUIT ""
 S UID=$G(OBJECT("uid")) I '$L(UID) D SETERROR^VPRJRUT(207) QUIT ""
 ;
 ; Parse out the collection, and key from the UID
 ; Currently assuming UID is urn:va:vistaAccount:localId:type...
 ; For example:  urn:va:93EF:34014:medication
 N COLL S COLL=$P(UID,":",5)
 I '$L(COLL) D SETERROR^VPRJRUT(210,UID) QUIT ""
 ;
 L +^VPRPT(PID,UID):2 E  D SETERROR^VPRJRUT(502) QUIT ""
 ; kill the old indexes and object
 S OLDOBJ="" M OLDOBJ=^VPRPT(PID,UID)
 D BLDTLT(COLL,.OBJECT,.TLTARY)
 TSTART
 K ^VPRPT(PID,UID)
 K ^VPRPT("JSON",PID,UID)
 ;
 S ^VPRPT("KEY",UID,PID)=""
 M ^VPRPT("JSON",PID,UID)=JSON
 M ^VPRPT("TEMPLATE",PID,UID)=TLTARY
 M ^VPRPT(PID,UID)=OBJECT
 D INDEX^VPRJPX(PID,UID,.OLDOBJ,.OBJECT)
 TCOMMIT
 L -^VPRPT(PID,UID)
 S ^VPRPTI(PID,"every","every")=$H  ; timestamps latest update for this PID
 ;
 Q $$URLENC^VPRJRUT(UID)  ; no errors
 ;
BLDTLT(COLL,OBJECT,TLTARY) ; Build JSON objects for associated templates
 ; COLL identifies the collection
 ; OBJECT is the decoded JSON object as a MUMPS array
 ; TLTARY is the array of JSON objects that get built based on templates
 N TNAME,TOBJ,TJSON,TERR,EXCLUDE,FIELD
 S TNAME="" F  S TNAME=$O(^VPRMETA("template",COLL,TNAME)) Q:TNAME=""  D
 . S EXCLUDE=$G(^VPRMETA("template",COLL,TNAME,"exclude"))
 . K TOBJ,TJSON,TERR
 . I EXCLUDE M TOBJ=OBJECT
 . S FIELD="" F  S FIELD=$O(^VPRMETA("template",COLL,TNAME,"fields",FIELD)) Q:FIELD=""  D
 . . I EXCLUDE D DELFLD(FIELD,.TOBJ) Q
 . . D ADDFLD(FIELD,.OBJECT,.TOBJ)
 . D ENCODE^VPRJSON("TOBJ","TJSON","TERR")
 . I '$D(TERR) M TLTARY(TNAME)=TJSON
 Q
DELFLD(FIELD,TOBJ) ; exclude fields
 ; if the field is in an array
 I FIELD["[]" D  QUIT
 . N TOP,SUB,NUM,REF
 . S TOP=$P(FIELD,"[]"),SUB=$P(FIELD,"[].",2),REF=""
 . I SUB="*" K TOBJ(TOP) Q        ; remove all fields of the array
 . I $L(SUB,".")>1 S REF=$$BLDREF(FIELD)
 . S NUM="" F  S NUM=$O(TOBJ(TOP,NUM)) Q:'NUM  D
 . . I $L(REF) K @("TOBJ"_REF) Q  ; remove specific subfield of array (complex)
 . . K TOBJ(TOP,NUM,SUB)          ; remove specific subfield of array (simple)
 ;
 ; if the field is top level
 I $L(FIELD,".")=1 K TOBJ(FIELD) QUIT  ; remove top level field (simple)
 ;
 ; if the field is complex
 N REF S REF=$$BLDREF(FIELD)
 K @("TOBJ"_REF)                  ; remove top level field (complex)
 Q
ADDFLD(FIELD,OBJECT,TOBJ) ; include fields
 ; if the field is in an array
 I FIELD["[]" D  QUIT
 . N TOP,SUB,NUM,REF,OREF,TREF
 . S TOP=$P(FIELD,"[]"),SUB=$P(FIELD,"[].",2),REF=""
 . I SUB="*" M TOBJ(TOP)=OBJECT(TOP) Q  ; merge full array
 . I $L(SUB,".")>1 S REF=$$BLDREF(FIELD)
 . S NUM="" F  S NUM=$O(OBJECT(TOP,NUM)) Q:'NUM  D
 . . I $L(REF),$D(@("OBJECT"_REF)) S @("TOBJ"_REF)=@("OBJECT"_REF) Q   ; complex sub-field
 . . I $D(OBJECT(TOP,NUM,SUB)) S TOBJ(TOP,NUM,SUB)=OBJECT(TOP,NUM,SUB) ; simple sub-field
 ;
 ; if the field is top level
 I $L(FIELD,".")=1,$D(OBJECT(FIELD)) S TOBJ(FIELD)=OBJECT(FIELD) QUIT  ; simple field
 ;
 ; if the field is complex
 N REF S REF=$$BLDREF(FIELD)
 I $D(@("OBJECT"_REF)) S @("TOBJ"_REF)=@("OBJECT"_REF)                 ; complex field
 Q
BLDREF(FIELD) ; build a node given a field name
 N I,REF,TOP
 S TOP="",REF=""
 I FIELD["[]" S TOP=""""_$P(FIELD,"[]")_""",NUM,",FIELD=$P(FIELD,"[].",2)
 F I=1:1:$L(FIELD,".") S REF=REF_$S(I=1:"",1:",")_""""_$P(FIELD,".",I)_""""
 Q "("_TOP_REF_")"
 ;
DELETE(PID,KEY) ; Delete an object given its UID
 N OLDOBJ,OBJECT,COLL
 S COLL=$P(KEY,":",5)
 I '$L(COLL) D SETERROR^VPRJRUT(210,KEY) QUIT ""
 I COLL="pat" D SETERROR^VPRJRUT(413,KEY) QUIT "" ; must delete entire patient instead 
 ;
 L +^VPRPT(PID,KEY):2 E  D SETERROR^VPRJRUT(502) QUIT ""
 ; kill the old indexes and object
 S OBJECT=""
 S OLDOBJ="" M OLDOBJ=^VPRPT(PID,KEY)
 TSTART
 K ^VPRPT(PID,KEY)
 K ^VPRPT("KEY",KEY,PID)
 K ^VPRPT("JSON",PID,KEY)
 K ^VPRPT("TEMPLATE",PID,KEY)
 D INDEX^VPRJPX(PID,KEY,.OLDOBJ,.OBJECT)
 TCOMMIT
 L -^VPRPT(PID,KEY)
 S ^VPRPT(PID,"every","every")=$H ; timestamps latest update for the PID
 Q
UPPER(X) ; return uppercase for X
 Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 ;
CLEARPT(PID) ; -- Clear data for patient
 I '$D(^VPRPT(PID)) D SETERROR^VPRJRUT(214) QUIT ""
 L +^VPRPT(PID):5 E  D SETERROR^VPRJRUT(502) QUIT ""
 ;
 N HASH ; remove cached queries
 S HASH="" F  S HASH=$O(^VPRTMP("PID",PID,HASH)) Q:HASH=""  K ^VPRTMP(HASH)
 K ^VPRTMP("PID",PID)
 ;
 N KEY ; remove the xref for UID's
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  K ^VPRPT("KEY",KEY,PID)
 ;
 D CLRCODES^VPRJPM(PID),CLREVIEW^VPRJPM(PID),CLRCOUNT^VPRJPM(PID)
 ;
 N ID,IDX ; remove the patient identifier indexes
 F IDX="ICN","DFN" D
 . S ID="" F  S ID=$O(^VPRPT("PID",PID,IDX,ID)) Q:ID=""  I $L(ID) D
 . . K ^VPRPT("PID",IDX,ID,PID),^VPRPT("PID",PID,IDX,ID)
 ;
 N PCNT ; decrement the count of patients
 L +^VPRPT("PID"):2 E  D SETERROR^VPRJRUT(502,"patient") QUIT
 S PCNT=$G(^VPRPTX("count","patient","patient"),0)
 S ^VPRPTX("count","patient","patient")=PCNT-1
 L -^VPRPT("PID")
 ;
 K ^VPRPTI(PID)           ; kill all indexes for the patient
 K ^VPRPT(PID)            ; kill all the data for the patient
 K ^VPRPT("JSON",PID)     ; kill original JSON objects for the patient
 K ^VPRPT("TEMPLATE",PID) ; kill the pre-compiled JSON objects for the patient
 L -^VPRPT(PID)
 Q

VPRJPM^INT^1^62756,62812.874599^0
VPRJPM ;SLC/KCM -- Management utilities for JSON patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
RIDXALL ; Reindex all patients
 W !!,"Re-indexing VPR for ALL patients",!
 N OK
 D CLRINDEX(.OK) Q:'OK
 N PID,KEY
 S PID=0 F  S PID=$O(^VPRPT(PID)) Q:'PID  D
 . W "."
 . S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D RIDXOBJ(PID,KEY)
 Q
RIDXPID(PID) ; Reindex a single patient
 W !!,"Re-index VPR for a single patient",!
 Q:'$G(PID)
 ;
 L +^VPRPT(PID):5 E  W !,"Unable to lock patient data",! Q
 D CLRCODES(PID),CLREVIEW(PID),CLRCOUNT(PID)
 K ^VPRPTI(PID)
 D SETUP^VPRJM
 N KEY
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D RIDXOBJ(PID,KEY)
 L -^VPRPT(PID)
 Q
RBLDALL ; Rebuild all patients (includes templates)
 W !!,"Re-build VPR (including templates) for ALL patients",!
 N OK
 D CLRINDEX(.OK) Q:'OK
 N PID,KEY
 S PID=0 F  S PID=$O(^VPRPT(PID)) Q:'PID  D
 . W "."
 . S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D RBLDOBJ(PID,KEY)
 Q
RBLDPID(PID) ; Rebuild single patient (includes templates)
 W !!,"Re-build VPR (including templates) for a single patient",!
 Q:'$G(PID)
 ;
 L +^VPRPT(PID):5 E  W !,"Unable to lock patient data",! Q
 D CLRCODES(PID),CLREVIEW(PID),CLRCOUNT(PID)
 K ^VPRPTI(PID)
 D SETUP^VPRJM
 N KEY
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D RBLDOBJ(PID,KEY)
 L -^VPRPT(PID)
 Q
RIDXOBJ(PID,KEY) ; Re-index a single object
 L +^VPRPT(PID,KEY):2 E  W !,"Unable to obtain lock for "_KEY QUIT
 N OBJECT
 M OBJECT=^VPRPT(PID,KEY)
 TSTART
 D INDEX^VPRJPX(PID,KEY,"",.OBJECT)
 TCOMMIT
 L -^VPRPT(PID,KEY)
 Q
RBLDOBJ(PID,KEY) ; Re-build a single object
 L +^VPRPT(PID,KEY):2 E  W !,"Unable to obtain lock for "_KEY QUIT
 N LINE,JSON
 ; get the original JSON object without the templates
 S LINE=0 F  S LINE=$O(^VPRPT("JSON",PID,KEY,LINE)) Q:'LINE  D
 . S JSON(LINE)=^VPRPT("JSON",PID,KEY,LINE)
 ; indexes have been killed for whole patient, so remove the original object
 K ^VPRPT(PID,KEY)
 K ^VPRPT("JSON",PID,KEY)
 K ^VPRPT("TEMPLATE",PID,KEY)
 K ^VPRPT("KEY",KEY,PID)
 ; call save the replace the object & reset indexes
 D SAVE^VPRJP(PID,.JSON)
 L -^VPRPT(PID,KEY)
 Q
CLRINDEX(OK) ; Clear all the indexes, preserving the "put patient" part
 ; since that is not redone with a rebuild or reindex
 N PCNT
 L +^VPRPT("PID"):2 E  W !,"Unable to get lock.",! S OK=0 Q
 S PCNT=$G(^VPRPTX("count","patient","patient"),0)
 K ^VPRPTI,^VPRPTX,^VPRTMP
 S ^VPRPTX("count","patient","patient")=PCNT
 L -^VPRPT("PID")
 D SETUP^VPRJM
 S OK=1
 Q
CLRCODES(PID) ; Clear the cross patient indexes for coded values
 ;remove ^VPRPTX("allCodes",code,field,PID)
 ;remove ^VPRPTX("pidCodes",PID)
 N FLD,CODE,KEY
 S FLD="" F  S FLD=$O(^VPRPTX("pidCodes",PID,FLD)) Q:FLD=""  D
 . S CODE="" F  S CODE=$O(^VPRPTX("pidCodes",PID,FLD,CODE)) Q:CODE=""  D
 . . S KEY="" F  S KEY=$O(^VPRPTX("pidCodes",PID,FLD,CODE,KEY)) Q:KEY=""  D
 . . . K ^VPRPTX("allCodes",CODE,FLD,PID,KEY)
 K ^VPRPTX("pidCodes",PID)
 Q
CLREVIEW(PID) ; Clear the cross patient indexes for re-evaluation times
 ;remove ^VPRPTX("review",reviewTime,PID)
 ;remove ^VPRPTX("pidReview",PID)
 N REVTM
 S REVTM="" F  S REVTM=$O(^VPRPTX("pidReview",PID,REVTM)) Q:REVTM=""  D
 . K ^VPRPTX("review",REVTM,PID)
 K ^VPRPTX("pidReview",PID)
 Q
CLRCOUNT(PID) ; Decrement the cross-patient totals for a patient
 ;reduce ^VPRPTX("count","collection",topic)
 ;    by ^VPRPTI(PID,"tally","collection",topic)
 ;reduce ^VPRPTX("count","domain",topic)
 ;    by ^VPRPTI(PID,"tally","domain",topic)
 N GROUP,TOPIC,CNT4PID,CNT4ALL ; decrement the relevant counts
 F GROUP="collection","domain" I $D(^VPRPTI(PID,"tally",GROUP)) D
 . S TOPIC="" F  S TOPIC=$O(^VPRPTI(PID,"tally",GROUP,TOPIC)) Q:TOPIC=""  D
 . . S CNT4PID=+$G(^VPRPTI(PID,"tally",GROUP,TOPIC))
 . . L +^VPRPTX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRUT(502,GROUP_" "_NAME) QUIT
 . . S CNT4ALL=+$G(^VPRPTX("count",GROUP,TOPIC))
 . . S ^VPRPTX("count",GROUP,TOPIC)=CNT4ALL-CNT4PID ; decr count across patients
 . . L -^VPRPTX("count",GROUP,TOPIC)
 Q
STATUS(PID) ; Show VPR status for a patient
 I $G(PID) D
 . W !,"For PID ",PID," --"
 . W !,?4,"Index Nodes: ",$$NODECNT("^VPRPTI("_PID_")")
 . W !,?4," Data Nodes: ",$$NODECNT("^VPRPT("_PID_")")
 . W !,?4,"Object Counts --"
 . W !,?8,"    Domain: ",$$ITEMCNT("domain",PID)
 . W !,?8,"Collection: ",$$ITEMCNT("collection",PID)
 . W !,?8,"     UID's: ",$$OBJCNT(PID)
 . W !,?4,"Code Refs: ",$$NODECNT("^VPRPTX(""pidCodes"","_PID_")")
 E  D
 . W !,"VPR Totals --"
 . W !,?4,"Patients: ",$$PTCNT()
 . W !,?4,"Index Nodes: ",$$NODECNT("^VPRPTI")
 . W !,?4," Data Nodes: ",$$NODECNT("^VPRPT")
 . W !,?4,"Object Counts --"
 . W !,?8,"    Domain: ",$$ITEMCNT("domain")
 . W !,?8,"Collection: ",$$ITEMCNT("collection")
 . W !,?8,"     UID's: ",$$OBJCNT()
 . W !,?4,"  Code Refs: ",$$NODECNT("^VPRPTX(""allCodes"")")
 . W !,?4,"Review Refs: ",$$NODECNT("^VPRPTX(""review"")")
 Q
PTCNT() ; Return the number of patients in the VPR
 N PID,COUNT
 S PID=0,COUNT=0
 F  S PID=$O(^VPRPT(PID)) Q:'PID  S COUNT=COUNT+1
 Q COUNT
 ;
NODECNT(ROOT) ; Return the number of nodes for ROOT
 N X,COUNT
 S X=ROOT,COUNT=0
 I $E(ROOT,$L(ROOT))=")" S ROOT=$E(ROOT,1,$L(ROOT)-1)
 F  S X=$Q(@X) Q:$E(X,1,$L(ROOT))'=ROOT  S COUNT=COUNT+1
 Q COUNT
 ;
ITEMCNT(GROUP,PID) ; Return the item count for a group
 ; PID is optional, if absent, entire VPR is counted
 N COUNT,TOPIC
 S COUNT=0
 I $G(PID) D
 . S TOPIC="" F  S TOPIC=$O(^VPRPTI(PID,"tally",GROUP,TOPIC)) Q:TOPIC=""  D
 . . S COUNT=COUNT+^VPRPTI(PID,"tally",GROUP,TOPIC)
 E  D
 . S TOPIC="" F  S TOPIC=$O(^VPRPTX("count",GROUP,TOPIC)) Q:TOPIC=""  D
 . . S COUNT=COUNT+^VPRPTX("count",GROUP,TOPIC)
 Q COUNT
 ;
OBJCNT(PID) ; Return a count of objects by UID
 ; PID is optional, if absent, entire VPR is counted
 N COUNT,UID
 S COUNT=0
 I $G(PID) D
 . S UID="" F  S UID=$O(^VPRPT(PID,UID)) Q:UID=""  S COUNT=COUNT+1
 E  D
 . S PID=0 F  S PID=$O(^VPRPT(PID)) Q:'PID  D
 . . S UID="" F  S UID=$O(^VPRPT(PID,UID)) Q:UID=""  S COUNT=COUNT+1
 Q COUNT
 ;
KILLDB ; -- Delete and reset the globals for the database
 K ^VPRHTTP("log")
 K ^VPRPT
 K ^VPRPTI
 K ^VPRPTX
 K ^VPRTMP
 K ^VPRMETA
 D SETUP^VPRJM
 Q
ASKPID() ; Return PID after prompting for it
 N PID,KEY
 S PID=$$PROMPT^VPRJ1("PID","","N","Enter the PID for a patient.")
 I '$D(^VPRPT(PID)) W !,"PID "_PID_" not found." S PID=0
 Q PID
 ;

VPRJPQ^INT^1^62766,48612.627213^0
VPRJPQ ;SLC/KCM -- Query for JSON patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;TODO: if desc order, make sure limit starts at the right end
 ;
QKEY(PID,KEY,TEMPLATE) ; Return an object given the key
 ; urn:va:med:93EF:8:10076  to   med:va:93EF:8:10076
 N VPRDATA,ORDER
 S TEMPLATE=$G(TEMPLATE)
 I '$D(^VPRPT("JSON",PID,KEY)) D SETERROR^VPRJRUT(104,"Pid:"_PID_" Key:"_KEY) Q
 K ^TMP("VPRDATA",$J)
 S ^TMP("VPRDATA",$J,KEY,0)=PID,VPRDATA=1,ORDER(0)=0
 D BUILD^VPRJCU
 K ^TMP("VPRDATA",$J)
 Q
 ;
QTALLY(PID,CNTNM) ; Return a set of counts
 ; return tallies as data:{items:[{"topic":"MEDICATION,INPT","count":4}
 I '$L(CNTNM) D SETERROR^VPRJRUT(101) Q
 N BUFFER S BUFFER=""
 ;
 N TOPIC,DATA,COUNT,X
 S DATA=0,TOPIC=""
 F  S TOPIC=$O(^VPRPTI(PID,"tally",CNTNM,TOPIC)) Q:TOPIC=""  D
 . S COUNT=+^VPRPTI(PID,"tally",CNTNM,TOPIC)
 . S X=$S('DATA:"",1:",")_"{""topic"":"""_TOPIC_""",""count"":"_COUNT_"}"
 . S DATA=DATA+1,DATA(DATA)=X
 S X=$$BLDHEAD(DATA) D STAGE(X)
 S DATA=0 F  S DATA=$O(DATA(DATA)) Q:'DATA  D STAGE(DATA(DATA))
 D STAGE("]}}"),OUT
 Q
 ;
 ;defined at the QINDEX level:
 ;     PID:  VPR patient identifier
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequece of the returned valuse, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QINDEX(PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; query based on index
 I '$L($G(INDEX)) D SETERROR^VPRJRUT(101) Q
 N VPRDATA,METHOD,CLAUSES
 S RANGE=$G(RANGE),ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 M INDEX=^VPRMETA("index",INDEX,"common")
 S METHOD=$G(INDEX("method")) I '$L(METHOD) D SETERROR^VPRJRUT(102,INDEX) Q
 I $L(FILTER) D PARSE^VPRJPQF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDER^VPRJCU(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 I METHOD="time" D QTIME^VPRJPQA
 I METHOD="attr" D QATTR^VPRJPQA
 I METHOD="every" D QEVERY^VPRJPQA
 D BUILD^VPRJCU
 K ^TMP("VPRDATA",$J)
 Q
QFIND(PID,COLL,ORDER,BAIL,TEMPLATE,FILTER) ; return items from collection without index
 N VPRDATA,CLAUSES,PREFIX,DFN,KEY
 S ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 I $L(FILTER) D PARSE^VPRJPQF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDF^VPRJCU(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 S DFN="" F  S DFN=$O(^VPRPT("PID",PID,"DFN",DFN)) Q:DFN=""  D
 . S PREFIX="urn:va:"_DFN_":"_COLL_":",KEY=PREFIX
 . F  S KEY=$O(^VPRPT(PID,KEY)) Q:$E(KEY,1,$L(PREFIX))'=PREFIX  D ADDONE^VPRJPQA(KEY,0)
 D BUILD^VPRJCU
 K ^TMP("VPRDATA",$J)
 Q
QLAST(PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; return most recent item in the list
 N IDXLAST S IDXLAST=1
 D QINDEX(PID,INDEX,$G(RANGE),$G(ORDER),$G(BAIL),$G(TEMPLATE),$G(FILTER))
 Q
BLDHEAD(CNT) ; Build the object header
 N X,UPDATED
 S UPDATED=$P($$FMTHL7^XLFDT($$NOW^XLFDT),"+")
 S X="{""apiVersion"":""1.0"",""data"":{""updated"":"_UPDATED_","
 S X=X_"""totalItems"":"_CNT_",""items"":["
 Q X
 ;
STAGE(X) ; appends to BUFFER until OUT writes it
 S BUFFER=BUFFER_X
 I $L(BUFFER)'<4000 D OUT
 Q
OUT(X) ; write out a frame of data
 S BUFFER("LINES")=$G(BUFFER("LINES"),0)+1
 S ^TMP($J,BUFFER("LINES"))=BUFFER,BUFFER=""
 Q

VPRJPQA^INT^1^62766,48612.632732^0
VPRJPQA ;SLC/KCM -- Query using attribute indexes for JSON patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;TODO: if desc order, make sure limit starts at the right end
 ;
 ;defined at the QINDEX level:
 ;     PID:  VPR patient identifier
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequece of the returned valuse, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QEVERY ; return all items (filter may be applied and order used)
 N KEY
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
QTIME ; intersect START and STOP
 ; Build ^TMP("VPRDATA",$J,time,key) with keys of objects to return
 N START,STOP,DIR,SUB,KEY,INST,SAVESUB,FOUND
 D PARSERNG^VPRJPQU
 S SUB(1)=START(1) F  S SUB(1)=$O(^VPRPTI(PID,"time",INDEX,SUB(1))) Q:SUB(1)=""  Q:SUB(1)]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRPTI(PID,"time",INDEX,SUB(1),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRPTI(PID,"time",INDEX,SUB(1),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D
 . . . D ADDONE(KEY,INST,.SUB)
 . . . S FOUND(KEY,INST)=""
 S SUB(1)=START(1) F  S SUB(1)=$O(^VPRPTI(PID,"stop",INDEX,SUB(1))) Q:SUB(1)=""  Q:SUB(1)]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRPTI(PID,"stop",INDEX,SUB(1),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRPTI(PID,"stop",INDEX,SUB(1),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  I '$D(FOUND(KEY,INST)) D
 . . . S SAVESUB=SUB(1),SUB(1)=^VPRPTI(PID,"stop",INDEX,SUB(1),KEY,INST) ; make SUB(1) the start date
 . . . D ADDONE(KEY,INST,.SUB)
 . . . S SUB(1)=SAVESUB
 Q
QATTR ; return items where attribute value is in range
 ; Build ^TMP("VPRDATA",$J,sortkey,sortkey,...,key,instances) with keys of objects to return
 ; Expects:  VPRDATA,PID,METHOD,RANGE,INDEX,ORDER,CLAUSES,BAIL
 N START,STOP,DIR,SUB,KEY,INST
 D PARSERNG^VPRJPQU
 I $G(IDXLAST)=1 D  ; handle finding last or latest items
 . S DIR(INDEX("levels"))=$S(INDEX("collate",INDEX("levels"))="V":1,1:-1)
 . I INDEX("levels")=0  D L0 Q
 . I INDEX("levels")=1  D L1 Q
 . I INDEX("levels")=2  D L2 Q
 . I INDEX("levels")=3  D L3 Q
 E  D               ; normal search loops
 . I INDEX("levels")=0  D A0 Q
 . I INDEX("levels")=1  D A1 Q
 . I INDEX("levels")=2  D A2 Q
 . I INDEX("levels")=3  D A3 Q
 Q
A0 ; unsorted list
 S KEY="" F  S KEY=$O(^VPRPTI(PID,METHOD,INDEX,KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
A1 ; sorted list / attribute only
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY="" F  S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST="" F  S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)=START(3) F  S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY="" F  S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST="" F  S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
NXT1() ;
 I START(1,"collate")="L" S SUB(1)=$O(START(1,"list",SUB(1))) Q SUB(1)
 Q $O(^VPRPTI(PID,METHOD,INDEX,SUB(1)),DIR(1))
 ;
NXT2() ;
 I START(2,"collate")="L" S SUB(2)=$O(START(2,"list",SUB(2))) Q SUB(2)
 Q $O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2)),DIR(2))
 ;
NXT3() ;
 I START(3,"collate")="L" S SUB(3)=$O(START(3,"list",SUB(3))) Q SUB(3)
 Q $O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3)),DIR(3))
 ;
L0 ; unsorted list
 S KEY="" S KEY=$O(^VPRPTI(PID,METHOD,INDEX,KEY),-1) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
L1 ; sorted list / attribute only
 S SUB(1)="" S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)="" S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)="" S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
ADDONE(KEY,INST,SUB) ; add uid, calculating new sort key if necessary
 ; Expects: PID,.ORDER,.CLAUSES
 I $D(CLAUSES) Q:'$$EVALAND^VPRJPQF(.CLAUSES,KEY)  ;apply filter, quit if not true
 N I,SORT,KINST
 S I=0 F  S I=$O(ORDER(I)) Q:'I  S SORT(I)=$S(+ORDER(I):SUB(+ORDER(I)),1:$$SORTVAL(I))
 S VPRDATA=VPRDATA+1
 ; case
 I ORDER(0)=0 S ^TMP("VPRDATA",$J,KEY,INST)=PID G X1
 I ORDER(0)=1 S ^TMP("VPRDATA",$J,SORT(1),KEY,INST)=PID G X1
 I ORDER(0)=2 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY,INST)=PID G X1
 I ORDER(0)=3 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY,INST)=PID G X1
 I ORDER(0)=4 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY,INST)=PID G X1
 I ORDER(0)=5 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY,INST)=PID G X1
 I ORDER(0)=6 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY,INST)=PID G X1
 I ORDER(0)=7 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY,INST)=PID G X1
X1 ; end case
 Q
 ;
SORTVAL(I) ; return the value for the field
 ; Expects: PID,.SUB,.ORDER,.KEY
 N X,FTYPE
 S X=0
 M FTYPE=ORDER(I,"ftype")
 ; case
 I FTYPE=1 S X=$G(^VPRPT(PID,KEY,FTYPE("field")),0) G X2
 I FTYPE=2 S X=$G(^VPRPT(PID,KEY,FTYPE("field"),FTYPE("sub")),0) G X2
 S I=$G(INDEX("key",ORDER(I,"mult")))
 Q:'$G(SUB(I)) 0
 I FTYPE=3 S X=$G(^VPRPT(PID,KEY,FTYPE("mult"),SUB(I),FTYPE("field")),0) G X2
 I FTYPE=4 S X=$G(^VPRPT(PID,KEY,FTYPE("mult"),SUB(I),FTYPE("field"),FTYPE("sub")),0) G X2
X2 ; end case
 I $D(^("\s")) S X=X_" " ; naked set to last $G, append space to force string
 Q X
 ;

VPRJPQF^INT^1^62766,56619.270454^0
VPRJPQF ;SLC/KCM -- query filter
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; EVALAND is always called first since the default is to 'and'
 ; clauses together, so ERROR is newed in EVALAND.
 ;
EVALAND(CLAUSES,UID) ; evaluate object at UID against filter
 ; AND -- return true if ALL clauses are true
 N SEQ,RESULT,CLAUSE,ERROR
 S SEQ=0,RESULT=1 ;default true in case there are no clauses to evaluate
 F  S SEQ=$O(CLAUSES(SEQ)) Q:'SEQ  M CLAUSE=CLAUSES(SEQ) S RESULT=$$EVALEXPR(.CLAUSE,UID) Q:'RESULT  K CLAUSE
 Q RESULT
 ;
EVALOR(CLAUSES,UID) ; evaluate object at UID against filter
 ; OR -- return true if ANY clause is true
 N SEQ,RESULT,CLAUSE
 S SEQ=0,RESULT=1 ;default true in case there are no clauses to evaluate
 F  S SEQ=$O(CLAUSES(SEQ)) Q:'SEQ  M CLAUSE=CLAUSES(SEQ) S RESULT=$$EVALEXPR(.CLAUSE,UID) Q:RESULT  K CLAUSE
 Q RESULT
 ;
EVALNOT(CLAUSES,UID) ; evaluate object at UID against filter
 ; NOT -- return true if none of the clauses are true
 N SEQ,RESULT,CLAUSE
 S SEQ=0,RESULT=1 ;default true in case there are no clauses to evaluate
 F  S SEQ=$O(CLAUSES(SEQ)) Q:'SEQ  M CLAUSE=CLAUSES(SEQ) S RESULT=$$EVALEXPR(.CLAUSE,UID) Q:RESULT  K CLAUSE
 Q 'RESULT
 ;
EVALEXPR(CLAUSE,UID) ; evaluate expression in a clause
 ; handle conjunctions / disjunctions
 I CLAUSE="and" Q $$EVALAND(.CLAUSE,UID)
 I CLAUSE="or" Q $$EVALOR(.CLAUSE,UID)
 I CLAUSE="not" Q $$EVALNOT(.CLAUSE,UID)
 ;
 I $G(HTTPREQ("store"))="data" G EVALEXJD ; jump to different for non-patient globals
 ;
 ; get the value or values to be evaluated & go to appropriate evaluator
 N VALUE
 ; case TYPE begin
 I CLAUSE("type")=1 S VALUE=$G(^VPRPT(PID,UID,CLAUSE("field"))) Q $$EVALONE
 I CLAUSE("type")=2 S VALUE=$G(^VPRPT(PID,UID,CLAUSE("field"),CLAUSE("sub"))) Q $$EVALONE
 N INST,RSLT
 S INST="",RSLT=0
 ; return try if -any- of the values evaluate to true
 F  S INST=$O(^VPRPT(PID,UID,CLAUSE("mult"),INST)) Q:'INST  D  Q:RSLT
 . I CLAUSE("type")=3 S VALUE=$G(^VPRPT(PID,UID,CLAUSE("mult"),INST,CLAUSE("field"))) S RSLT=$$EVALONE Q
 . I CLAUSE("type")=4 S VALUE=$G(^VPRPT(PID,UID,CLAUSE("mult"),INST,CLAUSE("field"),CLAUSE("sub"))) S RSLT=$$EVALONE Q
 Q RSLT
 ;
EVALEXJD ; come here to evaluate non-patient data
 ; get the value or values to be evaluated & go to appropriate evaluator
 N VALUE
 ; case TYPE begin
 I CLAUSE("type")=1 S VALUE=$G(^VPRJD(UID,CLAUSE("field"))) Q $$EVALONE
 I CLAUSE("type")=2 S VALUE=$G(^VPRJD(UID,CLAUSE("field"),CLAUSE("sub"))) Q $$EVALONE
 N INST,RSLT
 S INST="",RSLT=0
 ; return try if -any- of the values evaluate to true
 F  S INST=$O(^VPRJD(UID,CLAUSE("mult"),INST)) Q:'INST  D  Q:RSLT
 . I CLAUSE("type")=3 S VALUE=$G(^VPRJD(UID,CLAUSE("mult"),INST,CLAUSE("field"))) S RSLT=$$EVALONE Q
 . I CLAUSE("type")=4 S VALUE=$G(^VPRJD(UID,CLAUSE("mult"),INST,CLAUSE("field"),CLAUSE("sub"))) S RSLT=$$EVALONE Q
 Q RSLT
 ;
EVALONE() ; perform operation on a single value
 I CLAUSE="eq" Q (VALUE=CLAUSE("value"))
 I CLAUSE="in" Q:'$L(VALUE) 0  Q $D(CLAUSE("list",VALUE))
 I CLAUSE="ne" Q (VALUE'=CLAUSE("value"))
 I CLAUSE="exists" Q (($L(VALUE)>0)=$G(CLAUSE("value"),1))
 I CLAUSE="nin" Q:'$L(VALUE) 0  Q '$D(CLAUSE("list",VALUE))
 ;
 I $L(VALUE),(+VALUE=VALUE),'$D(CLAUSE("asString")) G EVALNUM
EVALSTR ; use ] to evaluate string values
 I CLAUSE="gt" Q (VALUE]CLAUSE("value"))
 I CLAUSE="lt" Q (CLAUSE("value")]VALUE)
 I CLAUSE="gte" Q:VALUE=CLAUSE("value") 1  Q (VALUE]CLAUSE("value"))
 I CLAUSE="lte" Q:VALUE=CLAUSE("value") 1  Q (CLAUSE("value")]VALUE)
 I CLAUSE="between" Q:(CLAUSE("low")]VALUE) 0 Q:(VALUE]CLAUSE("high")) 0 Q 1
 I CLAUSE="like" Q VALUE?@CLAUSE("pattern")
 I CLAUSE="ilike" Q $$LOW^XLFSTR(VALUE)?@CLAUSE("pattern")
 D SETERR(106,"unsupported operator")
 Q 0
 ;
EVALNUM ; use >,< to evaluate numeric values
 I CLAUSE="gt" Q (VALUE>CLAUSE("value"))
 I CLAUSE="lt" Q (VALUE<CLAUSE("value"))
 I CLAUSE="gte" Q (VALUE'<CLAUSE("value"))
 I CLAUSE="lte" Q (VALUE'>CLAUSE("value"))
 I CLAUSE="between" Q:(VALUE<CLAUSE("low")) 0 Q:(VALUE>CLAUSE("high")) 0 Q 1
 D SETERR(106,"unsupported operator")
 Q 0
 ;
 ;
PARSE(IN,OUT) ; parse filter syntax
 ; A:argument,C:conjunction,O:operation,L:list
 N LEVEL,STACK,PTR,TOKEN,ITEM,ERROR
 S LEVEL=1,PTR=1,STACK(LEVEL)=1,STACK(LEVEL,"mode")="O",ERROR=0
 F  Q:PTR>$L(IN)  S TOKEN=$E(IN,PTR) D  Q:ERROR
 . I TOKEN="(" D PUSH("A") Q
 . I TOKEN=")" D POP Q
 . I TOKEN="{" D PUSH("C") Q
 . I TOKEN="}" D POP Q
 . I TOKEN="[" D PUSH("L") Q
 . I TOKEN="]" D POP Q
 . I TOKEN="," S STACK(LEVEL)=STACK(LEVEL)+1,PTR=PTR+1 D LTRIM Q
 . I TOKEN=" " S STACK(LEVEL)=STACK(LEVEL)+1,PTR=PTR+1 D LTRIM Q
 . S ITEM=$S(TOKEN="""":$$NXTSTR,1:$$NXTVAL) Q:ERROR  ;increment PTR to next token
 . I '$L(ITEM) D SETERR(106,"empty value") Q
 . I STACK(LEVEL,"mode")="O"!(STACK(LEVEL,"mode")="C") D SETOPER(ITEM) Q
 . I STACK(LEVEL,"mode")="A" D  Q
 . . I STACK(LEVEL)=1 D SETFLD(ITEM) Q
 . . I STACK(LEVEL)=2 D
 . . . I TOKEN="""" S @$$CURREF(LEVEL-1,"asString")=""
 . . . I @$$CURREF(LEVEL-1)="between" S @$$CURREF(LEVEL-1,"low")=ITEM Q
 . . . I @$$CURREF(LEVEL-1)="like" S @$$CURREF(LEVEL-1,"pattern")=$$MAKEPAT(ITEM,0) Q
 . . . I @$$CURREF(LEVEL-1)="ilike" S @$$CURREF(LEVEL-1,"pattern")=$$MAKEPAT(ITEM,1) Q
 . . . I @$$CURREF(LEVEL-1)="exists" S @$$CURREF(LEVEL-1,"value")=$S(ITEM="false":0,1:1) Q
 . . . E  S @$$CURREF(LEVEL-1,"value")=ITEM
 . . I STACK(LEVEL)=3 S @$$CURREF(LEVEL-1,"high")=ITEM
 . I STACK(LEVEL,"mode")="L" S @$$CURREF(LEVEL-2,"list",ITEM)="" Q
 I LEVEL'=1,'ERROR D SETERR(106,"mismatch of braces")
 I '$$CHKOUT(.OUT) Q
 Q
PUSH(MODE) ; new stack level
 S LEVEL=LEVEL+1,STACK(LEVEL)=1,STACK(LEVEL,"mode")=MODE,PTR=PTR+1
 Q
POP ; remove stack level
 K STACK(LEVEL) S LEVEL=LEVEL-1,PTR=PTR+1
 Q
CURREF(TO,PROP,ITEM) ; Set current global reference based on stack
 N LEVEL,REF
 S REF="",LEVEL=1
 F  Q:LEVEL>TO  S REF=REF_$S(LEVEL=1:"",1:",")_STACK(LEVEL),LEVEL=LEVEL+1
 I $L($G(PROP)) S REF=REF_","""_PROP_""""
 I $L($G(ITEM)) S REF=REF_","""_ITEM_""""
 Q "OUT("_REF_")"
 ;
SETOPER(ITEM) ; Set operation
 S ITEM=$$LOW^XLFSTR(ITEM)
 I ",or,and,not,eq,ne,gt,lt,gte,lte,in,between,like,ilike,exists,nin,"[(","_ITEM_",") S @$$CURREF(LEVEL)=ITEM I 1
 E  D SETERR(106,"unsupported operator")
 Q
SETFLD(FIELD) ; Classify the field into its type and parts
 N PARTS
 ; TODO: consider supporting "_" in names
 ; case begin
 I FIELD?1A.AN D  G XSETFLD
 . S PARTS("type")=1,PARTS("field")=FIELD
 I FIELD?1A.AN1"."1A.AN D  G XSETFLD
 . S PARTS("type")=2,PARTS("field")=$P(FIELD,"."),PARTS("sub")=$P(FIELD,".",2)
 I FIELD?1A.AN1"[]."1A.AN D  G XSETFLD
 . S PARTS("type")=3,PARTS("mult")=$P(FIELD,"[]."),PARTS("field")=$P(FIELD,".",2)
 I FIELD?1A.AN1"[]."1A.AN1"."1A.AN D  G XSETFLD
 . S PARTS("type")=4,PARTS("mult")=$P(FIELD,"[]."),PARTS("field")=$P(FIELD,".",2),PARTS("sub")=$P(FIELD,".",3)
 ; else
 D SETERR(107,"unsupported field type")
 ; case end
XSETFLD ;
 Q:ERROR
 M @$$CURREF(LEVEL-1)=PARTS
 Q
NXTSTR() ; return next string
 N TPTR,DONE,END,STR
 S DONE=0,PTR=PTR+1,TPTR=PTR
 F  D  Q:DONE  Q:ERROR
 . S END=$F(IN,"""",TPTR) I END=0 D SETERR(106,"unexpected end") Q
 . I $E(IN,END-2)'="\" S DONE=1 Q
 . S TPTR=END
 S STR=$E(IN,PTR,END-2)
 S PTR=END
 Q STR
 ;
NXTVAL() ; return next value
 N END,VAL
 D LTRIM
 S END=PTR
 F  Q:END>$L(IN)  Q:" ,(){}[]"[$E(IN,END)  S END=END+1
 S VAL=$$TRIM^XLFSTR($E(IN,PTR,END-1))
 S PTR=END
 Q VAL
 ;
LTRIM ; trim whitespace from left
 F  Q:PTR>$L(IN)  Q:$A(IN,PTR)>32  S PTR=PTR+1  ; trim left whitespace
 Q
MAKEPAT(MATCH,CI) ; switch LIKE pattern into M pattern match
 I '$L(MATCH) D SETERR(106,"missing LIKE argument") Q ""
 ;
 I $G(CI) S MATCH=$$LOW^XLFSTR(MATCH) ; case insensitive match
 N I,X,LAST,PATTERN
 S PATTERN="",LAST=1
 F  S I=$F(MATCH,"%",LAST) D  Q:'I  Q:I>$L(MATCH)
 . S X=$E(MATCH,LAST,$S(I:I-2,1:$L(MATCH))),LAST=I
 . I $L(X) S PATTERN=PATTERN_"1"""_X_""""
 . I $E(MATCH,I-1)="%" S PATTERN=PATTERN_".E"
 Q PATTERN
 ;
CHKOUT(CLAUSES) ; check the output of parse for errors in initial statement
 N SEQ,OK,CLAUSE
 S SEQ=0,OK=1
 F  S SEQ=$O(CLAUSES(SEQ)) Q:'SEQ  M CLAUSE=CLAUSES(SEQ) S OK=$$CHKONE(.CLAUSE) Q:'OK  K CLAUSE
 Q OK
 ;
CHKONE(CLAUSE) ; check and individual clause for errors
 I ",and,or,not,"[(","_CLAUSE_",")  Q $$CHKOUT(.CLAUSE)
 I ",or,and,not,eq,ne,gt,lt,gte,lte,in,between,like,ilike,exists,nin,"'[(","_CLAUSE_",") D SETERR(106,"unsupported operator") Q 0
 I CLAUSE="between",('$D(CLAUSE("low"))!'$D(CLAUSE("high"))) D SETERR(106,"missing low or high") Q 0
 I (CLAUSE="in"!(CLAUSE="nin")),($D(CLAUSE("list"))'>1) D SETERR(106,"missing list for in operation") Q 0
 I ",eq,ne,gt,lt,gte,lte,"[(","_CLAUSE_","),'$D(CLAUSE("value")) D SETERR(106,"missing value") Q 0
 I (CLAUSE="like"!(CLAUSE="ilike")),'$D(CLAUSE("pattern")) D SETERR(106,"missing like pattern") Q 0
 I '$D(CLAUSE("field")) D SETERR(106,"missing field") Q 0
 I CLAUSE("type")=2,'$D(CLAUSE("sub")) D SETERR(106,"missing sub-field") Q 0
 I CLAUSE("type")=3,'$D(CLAUSE("mult")) D SETERR(106,"missing multiple") Q 0
 I CLAUSE("type")=4,('$D(CLAUSE("mult"))!'$D(CLAUSE("sub"))) D SETERR(106,"incomplete field name") Q 0
 Q 1
 ;
SETERR(ERR,MSG) ; set error state
 S ERROR=ERR
 D SETERROR^VPRJRUT(ERR,$G(MSG))
 Q

VPRJPQU^INT^1^62756,62812.900185^0
VPRJPQU ;SLC/KCM -- Query utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PARSERNG ; Parse range value
 ; expects: INDEX, RANGE
 ; updates: START, STOP, DIR
 ; returned structures:
 ;   START(level)=beginning of range    ;defaults to ""
 ;   START(level,#)="value"             ;for comma delimited range
 ;   START(level,"collation")=V|S|s...  ;"L" for list
 ;   STOP(level)=end of range           ;defaults to $C(255)
 ;   DIR(level)=1                       ;direction to traverse subscript
 ;
 ; @see unit test in PARSERNG^VPRJTQX
 N I,CLTN
 F I=1:1:INDEX("levels") D
 . N TMPSTRT,TMPSTOP
 . S CLTN=INDEX("collate",I) S:'$L(CLTN) CLTN="P"
 . D RNG2VAL($P(RANGE,">",I),.TMPSTRT,.TMPSTOP,CLTN)
 . M START(I)=TMPSTRT,STOP(I)=TMPSTOP
 . S START(I,"collate")=CLTN,DIR(I)=1
 . I $D(START(I,"list")) S START(I,"collate")="L"
 Q
RNG2VAL(RANGE,START,STOP,CTYPE) ; Parse start and stop from range
 ;@see unit tests in RNG2VAL^VPRJTQU and RNG2VAL2^VPRJTQU
 S START="",STOP=$C(255,255,255)
 I RANGE="" Q
 I $A(CTYPE)>96 S RANGE=$$LOW^XLFSTR(RANGE) ; lowercase for case-insensitive
 S CTYPE=$$UP^XLFSTR(CTYPE)
 I RANGE["," D  Q
 . N I,S
 . F I=1:1:$L(RANGE,",") D
 . . S S=$$TRIM^XLFSTR($P(RANGE,",",I))
 . . I CTYPE="V" S S=S_"="
 . . I CTYPE="T" S S=S_" "
 . . I CTYPE="S"!(CTYPE="s") S S=S_" "
 . . I CTYPE="N" S S=+S
 . . S START("list",S)=""
 ;
 N ENDPOINT,NUMERIC,X
 ; figure out the endpoints (include, exclusive, startswith)
 S ENDPOINT="[]" ; default to include endpoints
 I $E(RANGE)="]" S RANGE=$E(RANGE,2,$L(RANGE)),$E(ENDPOINT)="("
 I $E(RANGE)="[" S RANGE=$E(RANGE,2,$L(RANGE))
 I $E(RANGE,$L(RANGE))="[" S RANGE=$E(RANGE,1,$L(RANGE)-1),$E(ENDPOINT,2)=")"
 I $E(RANGE,$L(RANGE))="]" S RANGE=$E(RANGE,1,$L(RANGE)-1),$E(ENDPOINT,2)="]"
 I $E(RANGE,$L(RANGE))="*" S RANGE=$E(RANGE,1,$L(RANGE)-1),$E(ENDPOINT,2)="*"
 ; get start, stop and make sure stop is after start
 S START=$P(RANGE,".."),STOP=$P(RANGE,"..",2),NUMERIC=$$NUMERIC^VPRJSONE(START)
 I STOP="" S STOP=START
 I (NUMERIC&(START>STOP))!('NUMERIC&(START]STOP)) S X=STOP,STOP=START,START=X
 ;
 ; adjust start/stop for String and Time indexes
 I (CTYPE="S")!(CTYPE="T") D  Q
 . ;I ENDPOINT["[" S START=START_" "
 . I ENDPOINT["(" S START=START_" "
 . I ENDPOINT["*" S STOP=STOP_$C(255)
 . I ENDPOINT["]" S STOP=STOP_" "
 ; adjust start/stop for Inverse Time index
 I CTYPE="V" D  Q
 . ; get complement for each time and swap the times
 . S START=$TR(START,"0123456789","9876543210"),STOP=$TR(STOP,"0123456789","9876543210")
 . S X=STOP,STOP=START,START=X
 . I ENDPOINT["[" S STOP=STOP_"="
 . I ENDPOINT["(" S STOP=STOP_":"
 . I ENDPOINT["*" S START=START_" "
 . I ENDPOINT["]" S START=START_":"
 . I ENDPOINT[")" S START=START_"="
 ; adjust start/stop for Numeric index
 I CTYPE="N" D  Q
 . I ENDPOINT["[" S START=$$ADJNUM(START,"-")
 . I ENDPOINT[")" S STOP=$$ADJNUM(STOP,"-")
 Q
ADJNUM(N,SIGN) ; adjusted a number in a positive or negative direction
 ;@see unit test in ADJNUM^VPRJTQU
 I N'=+N Q N              ; not a number, leave it as is
 N P S P=$L($P(N,".",2))  ; get precision
 N D S D=$S('P:1,1:"."_$E("000000000000000",1,P-1)_"1")
 S D=$S($G(SIGN)="-":-D,1:D)
 Q N+D
 ;
ADJSTR(S,SIGN) ; bump a string ahead or behind in collation sequence
 ;@see unit test in ADJSTR^VPRJTQU
 I S="" Q S
 I $G(SIGN)="-" S $E(S,$L(S))=$C($A($E(S,$L(S)))-1),S=S_$C(255) Q S
 Q S_$C(255)
 ;
BLDFTYP(FIELD,FTYPE) ; build components for field
 ; .FTYPE=1|2|3|4  ; identified structure of field
 ; .FTYPE("field")=field name
 ; .FTYPE("mult")=array name
 ; .FTYPE("sub")=sub-field name
 ;
 K FTYPE
 ;case
 I FIELD'["." S FTYPE=1 G X0
 I FIELD'["[]" S FTYPE=2 G X0
 ; now only array types to check
 I $L($P(FIELD,"[].",2),".")=1 S FTYPE=3 G X0
 I $L($P(FIELD,"[].",2),".")=2 S FTYPE=4 G X0
X0 ;end case
 Q:'$D(FTYPE)  ; structure not yet supported
 ;
 I FTYPE=1 S FTYPE("field")=FIELD Q
 I FTYPE=2 S FTYPE("field")=$P(FIELD,"."),FTYPE("sub")=$P(FIELD,".",2) Q
 I FTYPE=3 S FTYPE("mult")=$P(FIELD,"[]"),FTYPE("field")=$P(FIELD,".",2) Q
 I FTYPE=4 S FTYPE("mult")=$P(FIELD,"[]"),FTYPE("field")=$P(FIELD,".",2),FTYPE("sub")=$P(FIELD,".",3) Q
 Q

VPRJPR^INT^1^62766,54155.720755^0
VPRJPR ;SLC/KCM -- Handle RESTful operations for patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PUTPT(ARGS,BODY) ; PUTs patient demographics into the database
 N DEMOG,ERR,PID
 D DECODE^VPRJSON("BODY","DEMOG","ERR") I $D(ERR) D SETERROR^VPRJRUT(202) QUIT ""
 I $G(DEMOG("uid"))="" D SETERROR^VPRJRUT(211) QUIT ""
 S PID=$$GETPID(.DEMOG) I 'PID QUIT ""
 S DEMOG("pid")=PID
 K BODY
 D ENCODE^VPRJSON("DEMOG","BODY","ERR") I $D(ERR) D SETERROR^VPRJRUT(202) QUIT ""
 Q "/vpr/"_PID_"/"_$$SAVE^VPRJP(PID,.BODY)
 ;
GETPID(PD) ; returns matching PID or new PID
 N PID,ICN,DFN
 S ICN=$G(PD("icn")),DFN=$P($G(PD("uid")),":",3,4),PID=0
 I $L(ICN) S PID=$O(^VPRPT("PID","ICN",ICN,"")) QUIT:PID $$VALPID(PID,.PD)
 I $L(DFN) S PID=$O(^VPRPT("PID","DFN",DFN,"")) QUIT:PID $$VALPID(PID,.PD)
 ; no PID found, so we need to create one
 N PCNT
 L +^VPRPT("PID"):2 E  D SETERROR^VPRJRUT(502) Q 0
 S ^VPRPT("PID")=$G(^VPRPT("PID"))+1,PID=^VPRPT("PID")
 S PCNT=$G(^VPRPTX("count","patient","patient"),0)
 S ^VPRPTX("count","patient","patient")=PCNT+1
 L -^VPRPT("PID")
 TSTART
 I $L(ICN) S ^VPRPT("PID","ICN",ICN,PID)="",^VPRPT("PID",PID,"ICN",ICN)=""
 I $L(DFN) S ^VPRPT("PID","DFN",DFN,PID)="",^VPRPT("PID",PID,"DFN",DFN)=""
 TCOMMIT
 Q PID
 ;
VALPID(PID,PD) ; Returns PID if validated, 0 otherwise
 N UID S UID=PD("uid")
 I $G(PD("ssn"))'=$G(^VPRPT(PID,UID,"ssn")) D SETERROR^VPRJRUT(212) QUIT 0
 I $G(PD("dateOfBirth"))'=$G(^VPRPT(PID,UID,"dateOfBirth")) D SETERROR^VPRJRUT(212) QUIT 0
 Q PID
 ;
PID(RESULT,ARGS) ; Returns patient demographics for dfn or icn
   N ICNDFN,PID
   S ICNDFN=$G(ARGS("icndfn"),0)
   S ICNDFN=$TR(ICNDFN,";",":")
   S TYPE=$S(ICNDFN[":":"DFN",1:"ICN") ; if there is a colon in there, its a qualified DFN, otherwise an ICN
   S PID=$O(^VPRPT("PID",TYPE,ICNDFN,""))
   I 'PID S PID=ICNDFN ; try it as a PID if there was no entry for qualified DFN or ICN
   S ARGS("pid")=PID
   D GETPT^VPRJPR(.RESULT,.ARGS)
   Q
   ;
GETPT(RESULT,ARGS) ; Returns patient demographics
 I $$UNKARGS^VPRJCU(.ARGS,"pid,template,icndfn") Q
 N UID
 S UID=$O(^VPRPT("PID",$G(ARGS("pid"),0),"DFN",""))
 I '$L(UID) D SETERROR^VPRJRUT(211) Q
 S UID="urn:va:"_UID_":pat:"_$P(UID,":",2)
 D QKEY^VPRJPQ(ARGS("pid"),UID)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
PUTOBJ(ARGS,BODY) ; PUTs an object for a patient into the database
 Q "/vpr/"_ARGS("pid")_"/"_$$SAVE^VPRJP(ARGS("pid"),.BODY)
 ;
GETOBJ(RESULT,ARGS) ; gets an object given a UID
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid,template") Q
 D QKEY^VPRJPQ($G(ARGS("pid")),$G(ARGS("uid")),$G(ARGS("template")))
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
GETUID(RESULT,ARGS) ; gets an object given a UID only (no PID)
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid,template") Q
 I '$L(ARGS("uid")) D SETERROR^VPRJRUT(207) Q
 N PID S PID=$O(^VPRPT("KEY",ARGS("uid"),0))
 I 'PID D SETERROR^VPRJRUT(203) Q
 D QKEY^VPRJPQ(PID,ARGS("uid"),$G(ARGS("template")))
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
INDEX(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"pid,indexName,range,order,bail,template,filter") Q
 N PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER
 S PID=$G(ARGS("pid"))
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 ;
 ; check to see if we can return a cached result
 N HASHSTR,HASHTS,HASH
 S HASHSTR="vpr/index/"_PID_"/"_INDEX_"/"_RANGE_"/"_ORDER_"/"_TEMPLATE_"/"_FILTER
 I $$CACHED(PID,INDEX,HASHSTR,.HASH,.HASHTS) D  Q
 . S RESULT=$NA(^VPRTMP(HASH)),RESULT("pageable")=""
 ;
 ; otherwise prepare cache and do the regular query
 S ^TMP($J,"query")=HASHSTR,^TMP($J,"timestamp")=HASHTS
 S ^TMP($J,"pid")=PID,^TMP($J,"index")=INDEX,^TMP($J,"hash")=HASH
 D QINDEX^VPRJPQ(PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
CACHED(PID,INDEX,HASHSTR,HASH,HASHTS) ; return TRUE if query cached and the cache is current
 ; .HASH returns the hashed value of HASHSTR
 ; .HASHTS returns the current $H of the index used
 Q:'$L(INDEX) 0  Q:'$L(PID) 0
 N MTHD
 S MTHD=$G(^VPRMETA("index",INDEX,"common","method"))
 S HASHTS=$G(^VPRPTI(PID,MTHD,INDEX))
 S HASH=$$HASH^VPRJRUT(HASHSTR)
 I '$D(^VPRTMP(HASH,"query")) Q 0        ; no cached data
 I ^VPRTMP(HASH,"query")'=HASHSTR Q 0    ; hash matched, but not original string
 I ^VPRTMP(HASH,"timestamp")=HASHTS Q 1  ; timestamps match, quit true
 Q 0                                     ; default to no cached data
 ;
LAST(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"pid,indexName,range,order,bail,template,filter") Q
 N PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER
 S PID=$G(ARGS("pid"))
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 D QLAST^VPRJPQ(PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
FIND(RESULT,ARGS) ; GET for objects using 'where' criteria
 I $$UNKARGS^VPRJCU(.ARGS,"pid,collection,order,bail,template,filter") Q
 N PID,COLL,ORDER,BAIL,TEMPLATE,FILTER
 S PID=$G(ARGS("pid"))
 S COLL=$G(ARGS("collection"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 D QFIND^VPRJPQ(PID,COLL,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
COUNT(RESULT,ARGS) ; GET for count of domain objects
 I $$UNKARGS^VPRJCU(.ARGS,"pid,countName") Q
 D QTALLY^VPRJPQ(ARGS("pid"),ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
ALLCOUNT(RESULT,ARGS) ; GET for count of objects across patients
 I $$UNKARGS^VPRJCU(.ARGS,"countName") Q
 D QCOUNT^VPRJAQ(ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
ALLINDEX(RESULT,ARGS) ; GET for index across patients
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,template") Q
 D QINDEX^VPRJAQ(ARGS("indexName"),ARGS("template"))
 S RESULT=$NA(^TMP($J))
 Q
ALLFIND(RESULT,ARGS) ; GET using filter across all patients
 I $$UNKARGS^VPRJCU(.ARGS,"collection,order,bail,template,filter") Q
 N COLL,ORDER,BAIL,TEMPLATE,FILTER
 S COLL=$G(ARGS("collection"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 I '$L(FILTER) D SETERROR^VPRJRUT(112) Q
 D QFIND^VPRJAQ(COLL,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
DELUID(RESULT,ARGS) ; DELETE an object
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid") Q
 N PID
 S PID=$G(ARGS("pid"))
 I 'PID S PID=$O(^VPRPT("KEY",ARGS("uid"),0))
 I 'PID D SETERROR^VPRJRUT(404) QUIT ""
 D DELETE^VPRJP(PID,ARGS("uid"))
 S RESULT=$NA(^TMP($J))
 Q
DELPT(RESULT,ARGS) ; DELETE a patient
 I $$UNKARGS^VPRJCU(.ARGS,"pid") Q
 I '$G(ARGS("pid")) D SETERROR^VPRJRUT(211) Q
 D CLEARPT^VPRJP(ARGS("pid"))
 S RESULT=""
 Q
DELALL(RESULT,ARGS) ; DELETE the entire VPR store
 I $$UNKARGS^VPRJCU(.ARGS,"confirm") Q
 I $G(ARGS("confirm"))'="true" D SETERROR^VPRJRUT(405) Q
 D KILLDB^VPRJPM
 S RESULT=""
 Q

VPRJPX^INT^1^62756,67055.896143^0
VPRJPX ;SLC/KCM -- Index a JSON object
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
INDEX(PID,KEY,OLDOBJ,NEWOBJ) ; Index this object identified by its KEY
 N IDXCOLL,IDXNAME
 ; Currently assuming UID is urn:va:vistaAccount:localId:tdype...
 ; For example:  urn:va:93EF:34014:med
 N VPRCONST D CONST
 S IDXCOLL=$P(KEY,":",5)
 S IDXNAME="" F  S IDXNAME=$O(^VPRMETA("collection",IDXCOLL,"index",IDXNAME)) Q:IDXNAME=""  D
 . N IDXMETA
 . M IDXMETA=^VPRMETA("index",IDXNAME,"collection",IDXCOLL)
 . S IDXMETA("setif")=$G(^VPRMETA("index",IDXNAME,"common","setif"))
 . S IDXMETA("review")=$G(^VPRMETA("index",IDXNAME,"common","review"))
 . S IDXMETA("levels")=$G(^VPRMETA("index",IDXNAME,"common","levels"))
 . S IDXMETA("method")=^VPRMETA("index",IDXNAME,"common","method")
 . I IDXMETA("method")="tally" D TALLY Q
 . I IDXMETA("method")="time"  D TIME Q
 . I IDXMETA("method")="attr"  D ATTRIB Q
 ;D CODES (do this later -- when we add in support for matches)
 D COUNTS
 Q
 ;
 ; ----- Extract Values from Object -----
 ;
SETVALS(OBJECT,VALUES) ; extract values from OBJECT based on info in IDXMETA
 ; Expects IDXMETA
 ; .OBJECT, .VALUES both passed by reference, results in .VALUES
 N LVL,NOVAL,MULTS,USED,X
 K VALUES
 S NOVAL=0 ; set if top level value is absent
 S LVL=0 F  S LVL=$O(IDXMETA(LVL)) Q:'LVL  D  Q:NOVAL
 . I IDXMETA(LVL,"field")="" Q  ; no field defined (in all-time labs, for example)
 . I IDXMETA(LVL,"ftype")<3 S X=$$GETVAL(0) D:$L(X) ADDVAL(X,0) S:'$L(X) NOVAL=1 Q
 . I IDXMETA(LVL,"ftype")>2 D MULTVAL(LVL)
 Q:NOVAL   ; missing top level value
 M VALUES=MULTS(IDXMETA("levels"))
 Q
ADDVAL(X,INAME) ; add values to MULTS as unique instances, copying previous level
 ; expects:  LVL, MULTS
 ; build MULTS in format MULTS(level#,instanceString,field#)=value
 ; instanceString is 0 if no multiples, inst&inst&... if there are multiples
 S INAME=$G(INAME,0)
 I LVL=1 S MULTS(LVL,INAME,LVL)=X,USED(INAME)="" Q
 ; for subscripts beyond the first
 N OLD,NEW,I
 S OLD="" F  S OLD=$O(MULTS(LVL-1,OLD)) Q:OLD=""  D
 . S NEW=$S(INAME=0:OLD,$D(USED(INAME)):OLD,1:OLD_"&"_INAME),USED(NEW)=""
 . S I=0 F  S I=$O(MULTS(LVL-1,OLD,I)) Q:'I  S MULTS(LVL,NEW,I)=MULTS(LVL-1,OLD,I)
 . I INAME=0!(("&"_NEW)[("&"_INAME)) S MULTS(LVL,NEW,LVL)=X  ; make sure this is INAME instance
 Q
DELVAL(INAME) ; removes matching instances if value is empty
 N OLD S OLD=""
 F  S OLD=$O(MULTS(LVL-1,OLD)) Q:OLD=""  I ("&"_OLD)[("&"_INAME) K MULTS(LVL-1,OLD)
 Q
MULTVAL(LVL,NOVAL) ; adds to VALUES if field is multiple
 ; Expects IDXMETA, OBJECT  /  used by SETVAL
 N MULT,INST
 S MULT=IDXMETA(LVL,"ftype","mult")
 S INST="" F  S INST=$O(OBJECT(MULT,INST)) Q:'INST  D
 . S X=$$GETVAL(INST)
 . I $L(X) D ADDVAL(X,MULT_"."_INST) Q
 . D DELVAL(MULT_"."_INST) ; otherwise remove previous level with this instance
 Q
GETVAL(INST) ; return field value or "" if no value -and- no default
 ; Expects IDXMETA, LVL, OBJECT  /  used by SETVAL, MLTVAL
 N X
 S X=$$FLDVAL($G(INST))
 I '$L(X) S X=IDXMETA(LVL,"ifNull")
 S X=$$COLLATE(X,IDXMETA(LVL,"collate"),0)
 Q X
 ;
FLDVAL(INST) ; return the field values
 ; Expects IDXMETA, LVL, OBJECT  /  used by ONEVAL
 N FTYPE M FTYPE=IDXMETA(LVL,"ftype")
 I FTYPE=1 Q:'$L(FTYPE("field")) "" Q $G(OBJECT(FTYPE("field")))
 I FTYPE=2 Q:'$L(FTYPE("field")) "" Q:'$L(FTYPE("sub")) "" Q $G(OBJECT(FTYPE("field"),FTYPE("sub")))
 I FTYPE=3 Q:'$L(FTYPE("field")) "" Q $G(OBJECT(FTYPE("mult"),INST,FTYPE("field")))
 I FTYPE=4 Q:'$L(FTYPE("field")) "" Q:'$L(FTYPE("sub")) "" Q $G(OBJECT(FTYPE("mult"),INST,FTYPE("field"),FTYPE("sub")))
 Q ""
 ;
COLLATE(VALUE,CTYPE,REQUIRE) ; return value of field for collation
 ; Used by ONEVAL
 ; force times to always be a string rather than a numeric
 ; terminate inverse time with "=" so ":" can used to avoid endpoints when going backwards
 ; terminate strings with "!" so space can be used to include initial string
 ; ASCII order is " ","!",numerals,":","="
 I VALUE="" Q:'REQUIRE "" S VALUE=0
 I CTYPE="P" Q VALUE
 I CTYPE="p" Q $$LOW^XLFSTR(VALUE)
 I CTYPE="V" Q $TR(VALUE,"0123456789","9876543210")_"="
 I CTYPE="S" Q VALUE_" "
 I CTYPE="s" Q $$LOW^XLFSTR(VALUE)_" "
 I CTYPE="T" Q VALUE_" "
 I CTYPE="N" Q +VALUE
 Q VALUE_" "  ; default to string
 ;
 ; ----- Maintain counts of objects -----
 ;
COUNTS ; set counts for different collection types
 N DOMAIN
 D KCOUNT("collection",IDXCOLL,.OLDOBJ)
 D SCOUNT("collection",IDXCOLL,.NEWOBJ)
 S DOMAIN=$G(^VPRMETA("collection",IDXCOLL,"domain")) Q:DOMAIN=""
 D KCOUNT("domain",DOMAIN,.OLDOBJ)
 D SCOUNT("domain",DOMAIN,.NEWOBJ)
 Q
SCOUNT(GROUP,TOPIC,OBJECT) ; Increment a count index
 Q:$D(OBJECT)<10
 N TALLY
 S TALLY=+$G(^VPRPTI(PID,"tally",GROUP,TOPIC))
 S ^VPRPTI(PID,"tally",GROUP,TOPIC)=TALLY+1 ; incr count for patient
 ;
 L +^VPRPTX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRUT(502,GROUP_" "_TOPIC) QUIT
 S TALLY=+$G(^VPRPTX("count",GROUP,TOPIC))
 S ^VPRPTX("count",GROUP,TOPIC)=TALLY+1 ; incr count across patients
 L -^VPRPTX("count",GROUP,TOPIC)
 Q
KCOUNT(GROUP,TOPIC,OBJECT) ; Decrement a count index
 Q:$D(OBJECT)<10
 N TALLY
 S TALLY=+$G(^VPRPTI(PID,"tally",GROUP,TOPIC))
 S ^VPRPTI(PID,"tally",GROUP,TOPIC)=TALLY-1 ; decr count for patient
 ;
 L +^VPRPTX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRUT(502,GROUP_" "_TOPIC) QUIT
 S TALLY=+$G(^VPRPTX("count",GROUP,TOPIC))
 S ^VPRPTX("count",GROUP,TOPIC)=TALLY-1 ; decr count across patients
 L -^VPRPTX("count",GROUP,TOPIC)
 Q
 ;
 ; ----- Index Logic: tally by attribute value -----
 ;
TALLY ; TALLY index (PID,"tally",group,value)=tally
 ; if FIELD has no value, count is not changed
 D KTALLY(.OLDOBJ)
 D STALLY(.NEWOBJ)
 S ^VPRPTI(PID,"tally",IDXNAME)=$H
 Q
STALLY(OBJECT) ; Increment a tally index
 Q:$D(OBJECT)<10
 N VALUES,I,TALLY
 D SETVALS(.OBJECT,.VALUES) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S TALLY=+$G(^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1)))
 . S ^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1))=TALLY+1
 Q
KTALLY(OBJECT) ; Decrement a tally index
 Q:$D(OBJECT)<10
 N VALUES,I,TALLY
 D SETVALS(.OBJECT,.VALUES) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S TALLY=+$G(^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1)))
 . S ^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1))=TALLY-1
 . I ^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1))=0 K ^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1))
 Q
 ;
 ; ----- Index Logic: time ranges -----
 ;
TIME ; TIME index   (PID,"time",group,start,key)=stop
 ; -- if time range (PID,"stop",group,stop,key)=start
 ; expects start to always be something (0 if null), stop is optional
 D KTIME(.OLDOBJ)
 D STIME(.NEWOBJ)
 S ^VPRPTI(PID,"time",IDXNAME)=$H
 Q
STIME(OBJECT) ; Set a time based index
 Q:$D(OBJECT)<10
 N VALUES,I
 D SETVALS(.OBJECT,.VALUES) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S ^VPRPTI(PID,"time",IDXNAME,VALUES(I,1),KEY,I)=$G(VALUES(I,2))
 . Q:'$L($G(VALUES(I,2)))
 . S ^VPRPTI(PID,"stop",IDXNAME,VALUES(I,2),KEY,I)=VALUES(I,1)
 Q
KTIME(OBJECT) ; Kill a time based index
 Q:$D(OBJECT)<10
 N VALUES,I
 D SETVALS(.OBJECT,.VALUES) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . K ^VPRPTI(PID,"time",IDXNAME,VALUES(I,1),KEY,I)
 . Q:'$L($G(VALUES(I,2)))
 . K ^VPRPTI(PID,"stop",IDXNAME,VALUES(I,2),KEY,I)
 Q
 ;
 ; ----- Index Logic: attributes -----
 ;
ATTRIB ; ATTRIBUTE index (PID,"attr",group,value,sort,key)
 D KATTRIB(.OLDOBJ)
 D SATTRIB(.NEWOBJ)
 S ^VPRPTI(PID,"attr",IDXNAME)=$H
 Q
SATTRIB(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ; SETIF conditional statement is in format "$$TAG^ROUTINE"
 N OK,SETIF
 S OK=1
 I $L(IDXMETA("setif")) S OK=0,SETIF=IDXMETA("setif")_"(.OBJECT)" I @SETIF S OK=1
 Q:'OK
 I $L(IDXMETA("review")) D
 . N REVIEW,REVTM
 . S REVIEW="S REVTM="_REVIEW_"(.OBJECT)" X REVIEW
 . S ^VPRPTI(PID,"review",KEY,IDXNAME)=REVTM
 . S ^VPRPTX("review",REVTM,PID,KEY,IDXNAME)=""
 . S ^VPRPTX("pidReview",PID,REVTM)=""
 ;
 I IDXMETA("levels")=0  D SA0  Q
 ;
 N VALUES,I
 D SETVALS(.OBJECT,.VALUES)
 Q:'$D(VALUES)
 I IDXMETA("levels")=1  D SA1  Q
 I IDXMETA("levels")=2  D SA2  Q
 I IDXMETA("levels")=3  D SA3  Q
 Q
KATTRIB(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ;
 I $L(IDXMETA("review")) D
 . N REVTM
 . S REVTM=$G(^VPRPTI(PID,"review",KEY,IDXNAME)) Q:'$L(REVTM)
 . K ^VPRPTI(PID,"review",KEY,IDXNAME)
 . K ^VPRPTX("review",REVTM,PID,KEY,IDXNAME)
 . K ^VPRPTX("pidReview",PID,REVTM)
 ;
 I IDXMETA("levels")=0  D KA0  Q
 ;
 N VALUES,I
 D SETVALS(.OBJECT,.VALUES)
 Q:'$D(VALUES)
 I IDXMETA("levels")=1  D KA1  Q
 I IDXMETA("levels")=2  D KA2  Q
 I IDXMETA("levels")=3  D KA3  Q
 Q
SA0 ; unsorted list set logic
 S ^VPRPTI(PID,"attr",IDXNAME,KEY)=""
 Q
KA0 ; unsorted list kill logic
 K ^VPRPTI(PID,"attr",IDXNAME,KEY)
 Q
SA1 ; one attribute set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),KEY,I)=""
 Q
KA1 ; one attribute kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),KEY,I)
 Q
SA2 ; two attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)=""
 Q
KA2 ; two attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)
 Q
SA3 ; three attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)=""
 Q
KA3 ; three attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)
 Q
 ;
CODES ; code indexes
 D KCODES(.OLDOBJ)
 D SCODES(.NEWOBJ)
 Q
SCODES(OBJECT) ; set indexed codes
 Q:$D(OBJECT)<10
 N FIELD,SUB,LIST,I  ; assume max of 2 levels for now
 S FIELD="" F  S FIELD=$O(^VPRMETA("codes",IDXCOLL,FIELD)) Q:FIELD=""  D
 . I FIELD'["[]" D SETCODE(PID,KEY,$G(OBJECT(FIELD)),FIELD) Q
 . S LIST=$P(FIELD,"[]")
 . S I=0 F  S I=$O(OBJECT(LIST,I)) Q:'I  D
 . . S SUB="" F  S SUB=$O(^VPRMETA("codes",IDXCOLL,LIST,SUB)) Q:SUB=""  D SETCODE(PID,KEY,$G(OBJECT(LIST,I,SUB)),SUB)
 Q
KCODES(OBJECT) ; kill indexed codes
 Q:$D(OBJECT)<10
 N FIELD,SUB,LIST,I  ; assume max of 2 levels for now
 S FIELD="" F  S FIELD=$O(^VPRMETA("codes",IDXCOLL,FIELD)) Q:FIELD=""  D
 . I FIELD'["[]" D KILLCODE(PID,KEY,$G(OBJECT(FIELD)),FIELD) Q
 . S LIST=$P(FIELD,"[]")
 . S I=0 F  S I=$O(OBJECT(LIST,I)) Q:'I  D
 . . S SUB="" F  S SUB=$O(^VPRMETA("codes",IDXCOLL,LIST,SUB)) Q:SUB=""  D KILLCODE(PID,KEY,$G(OBJECT(LIST,I,SUB)),SUB)
 Q
SETCODE(PID,KEY,CODE,FIELD) ; Set index of all codes
 Q:'$L($G(CODE))
 S ^VPRPTX("allCodes",CODE,FIELD,PID,KEY)=""
 S ^VPRPTX("pidCodes",PID,FIELD,CODE,KEY)=""
 Q
KILLCODE(PID,KEY,CODE,FIELD) ; Kill index of all codes
 Q:'$L($G(CODE))
 K ^VPRPTX("allCodes",CODE,FIELD,PID,KEY)
 K ^VPRPTX("pidCodes",PID,FIELD,CODE,KEY)
 Q
CONST ; Set up constants for use
 S VPRCONST("SCT_MED_STATUS_ACTIVE")="urn:sct:55561003"
 S VPRCONST("SCT_MED_TYPE_OTC")="urn:sct:329505003"
 S VPRCONST("SCT_MED_TYPE_PRESCRIBED")="urn:sct:73639000"
 S VPRCONST("SCT_MED_TYPE_GENERAL")="urn:sct:105903003"
 Q

VPRJRCL^INT^1^62756,62812.918947^0
VPRJRCL ;SLC/KCM -- Control the HTTP listener
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
GO(PORT) ; start up REST listener with defaults
 I $G(PORT) D SPORT(PORT)
 S PORT=$G(^VPRHTTP(0,"port"),9080)
 D SETUP^VPRJM,SETUP^VPRJDMD ; make sure meta data is in place
 J START^VPRJREQ(PORT)       ; start the listener
 Q
STOP ; tell the listener to stop running
 I $E($G(^VPRHTTP(0,"listener")),1,4)'="stop" S ^VPRHTTP(0,"listener")="stopping"
 Q
STOPW ; tell the listener to stop running and wait until it stops
 ; this function is interactive
 N I,X
 W !,"Stopping HTTP listener on port "_$G(^VPRHTTP(0,"port"),9080)_"."
 D STOP
 F I=1:1:12 D  Q:X="stopped"
 . S X=^VPRHTTP(0,"listener")
 . I X="stopped" W X,! Q
 . W "."
 . H 1
 I X'="stopped" W "failed to stop.  Status: ",$$STATUS,!
 Q
SPORT(PORT) ; set the port that should be listened on
 Q:'$G(PORT)
 S ^VPRHTTP(0,"port")=PORT
 Q
SLOG(LEVEL) ; set log level -  0:errors,1:headers&errors,2:raw,3:body&response
 S ^VPRHTTP(0,"logging")=$G(LEVEL,0)
 Q
CLEAR ; clear the logs
 K ^VPRHTTP("log")
 Q
LOG() ; return the current logging level
 Q $G(^VPRHTTP(0,"logging"),0)
 ;
PORT() ; return the HTTP port number
 Q $G(^VPRHTTP(0,"port"),9080)
 ;
STATUS() ; Return status of the HTTP listener
 ;Simple Exchange (happy path)
 ;GET /ping HTTP/1.1
 ;Host: JDSlocalhost
 ;
 ;HTTP/1.1 200 OK
 ;Content-Length: 20
 ;Content-Type: application/json
 ;Date: Wed, 15 Aug 2012 21:10:09 GMT
 ;
 ;{"status":"running"}
 ;
 I $E($G(^VPRHTTP(0,"listener")),1,4)="stop" Q ^VPRHTTP(0,"listener")
 ;
 N HTTPLOG,HTTPREQ,PORT,X
 S HTTPLOG=0,PORT=$G(^VPRHTTP(0,"port"),9080)
 O "|TCP|2":("127.0.0.1":PORT:"CT"):2 E  Q "not responding"
 U "|TCP|2"
 W "GET /ping HTTP/1.1"_$C(10,13)_"Host: JDSlocalhost"_$C(10,13,10,13),!
 F  S X=$$RDCRLF^VPRJREQ() Q:'$L(X)  D ADDHEAD^VPRJREQ(X)
 U "|TCP|2":(::"S")
 I $G(HTTPREQ("header","content-length"))>0 D RDLEN^VPRJREQ(HTTPREQ("header","content-length"),2)
 C "|TCP|2"
 S X=$P($G(HTTPREQ("body",1)),"""",4)
 I '$L(X) Q "unknown"
 Q X

VPRJREQ^INT^1^62766,48612.655758^0
VPRJREQ ;SLC/KCM -- Listen for HTTP requests
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Listener Process ---------------------------------------
 ;
START(TCPPORT) ; set up listening for connections
 S ^VPRHTTP(0,"listener")="running"
 ;
 S TCPPORT=$G(TCPPORT,9080)
 S TCPIO="|TCP|"_TCPPORT
 O TCPIO:(:TCPPORT:"ACT"):15 E  U 0 W !,"error" Q
 U TCPIO
LOOP ; wait for connection, spawn process to handle it
 I $E(^VPRHTTP(0,"listener"),1,4)="stop" C TCPIO S ^VPRHTTP(0,"listener")="stopped" Q
 R *X:10 I '$T G LOOP
 I '$$LCLHOST^VPRJRUT() W *-2 G LOOP ; reject & close port if not localhost
 ; 
 J CHILD:(:4:TCPIO:TCPIO):10
 I $ZA\8196#2=1 W *-2 ;job failed to clear bit
 G LOOP
 ;
 ;
 ; Child Handling Process ---------------------------------
 ;
 ; The following variables exist during the course of the request
 ; HTTPREQ contains the HTTP request, with subscripts as follow --
 ; HTTPREQ("method") contains GET, POST, PUT, HEAD, or DELETE
 ; HTTPREQ("path") contains the path of the request (part from server to ?)
 ; HTTPREQ("query") contains any query params (part after ?)
 ; HTTPREQ("header",name) contains a node for each header value
 ; HTTPREQ("body",n) contains as an array the body of the request
 ; HTTPREQ("location") stashes the location value for PUT, POST
 ; HTTPREQ("store") stashes the type of store (vpr or data)
 ;
 ; HTTPRSP contains the HTTP response (or name of global with the response)
 ; HTTPLOG indicates the logging level for this process
 ; HTTPERR non-zero if there is an error state
 ;
CHILD ; handle HTTP requests on this connection
 S HTTPLOG=$G(^VPRHTTP(0,"logging"),0) ; HTTPLOG remains set throughout
 S HTTPLOG("DT")=+$H
 N $ET S $ET="G ETSOCK^VPRJREQ"
 ;
NEXT ; begin next request
 K HTTPREQ,HTTPRSP,HTTPERR
 K ^TMP($J),^TMP("HTTPERR",$J) ; TODO: change the namespace for the error global
 ;
WAIT ; wait for request on this connection
 I $E(^VPRHTTP(0,"listener"),1,4)="stop" C $P Q
 U $P:(::"CT")
 R TCPX:10 I '$T G WAIT
 I '$L(TCPX) G WAIT
 ;
 ; -- got a request and have the first line
 D INCRLOG ; set unique request id
 I HTTPLOG D LOGRAW(TCPX),LOGHDR(TCPX)
 S HTTPREQ("method")=$P(TCPX," ")
 S HTTPREQ("path")=$P($P(TCPX," ",2),"?")
 S HTTPREQ("query")=$P($P(TCPX," ",2),"?",2,999)
 ; TODO: time out connection after N minutes of wait 
 ; TODO: check format of TCPX and raise error if not correct
 I $E($P(TCPX," ",3),1,4)'="HTTP" G NEXT
 ;
 ; -- read the rest of the lines in the header
 F  S TCPX=$$RDCRLF() Q:'$L(TCPX)  D ADDHEAD(TCPX)
 ;
 ; -- decide how to read body, if any
 U $P:(::"S")
 I $$LOW^VPRJRUT($G(HTTPREQ("header","transfer-encoding")))="chunked" D
 . D RDCHNKS ; TODO: handle chunked input
 . I HTTPLOG>2 ; log array of chunks
 I $G(HTTPREQ("header","content-length"))>0 D
 . D RDLEN(HTTPREQ("header","content-length"),99)
 . I HTTPLOG>2 D LOGBODY
 ;
 ; -- build response (map path to routine & call, otherwise 404)   
 S $ETRAP="G ETCODE^VPRJREQ"
 S HTTPERR=0
 D RESPOND^VPRJRSP
 S $ETRAP="G ETSOCK^VPRJREQ"
 ; TODO: restore HTTPLOG if necessary
 ;
 ; -- write out the response (error if HTTPERR>0)
 U $P:(::"S")
 I $G(HTTPERR) D RSPERROR^VPRJRSP ; switch to error response
 D SENDATA^VPRJRSP
 ;
 ; -- exit on Connection: Close
 I $$LOW^VPRJRUT($G(HTTPREQ("header","connection")))="close" D  Q
 . K ^TMP($J),^TMP("HTTPERR",$J)
 . C $P
 ;
 ; -- otherwise get ready for the next request
 G NEXT
 ;
RDCRLF() ; read a header line
 ; fixes a problem where the read would terminate before CRLF
 ; (on a packet boundary or when 1024 characters had been read)
 N X,LINE,RETRY
 S LINE=""
 F RETRY=1:1 R X:1 D:HTTPLOG LOGRAW(X) S LINE=LINE_X Q:$A($ZB)=13  Q:RETRY>10
 Q LINE
 ;
RDCHNKS ; read body in chunks
 Q  ; still need to implement
 ;
RDLEN(REMAIN,TIMEOUT) ; read L bytes with timeout T
 N X,LINE,LENGTH
 S LINE=0
RDLOOP ;
 ; read until L bytes collected
 ; quit with what we have if read times out
 S LENGTH=REMAIN I LENGTH>4000 S LENGTH=4000
 R X#LENGTH:TIMEOUT
 I '$T D:HTTPLOG>1 LOGRAW("timeout:"_X) S LINE=LINE+1,HTTPREQ("body",LINE)=X Q
 I HTTPLOG>1 D LOGRAW(X)
 S REMAIN=REMAIN-$L(X),LINE=LINE+1,HTTPREQ("body",LINE)=X
 G:REMAIN RDLOOP
 Q
 ;
ADDHEAD(LINE) ; add header name and header value
 ; expects HTTPREQ to be defined
 D:HTTPLOG LOGHDR(LINE)
 N NAME,VALUE
 S NAME=$$LOW^VPRJRUT($$LTRIM^VPRJRUT($P(LINE,":")))
 S VALUE=$$LTRIM^VPRJRUT($P(LINE,":",2,99))
 I LINE'[":" S NAME="",VALUE=LINE
 I '$L(NAME) S NAME=$G(HTTPREQ("header")) ; grab the last name used
 I '$L(NAME) Q  ; no header name so just ignore this line
 I $D(HTTPREQ("header",NAME)) D
 . S HTTPREQ("header",NAME)=HTTPREQ("header",NAME)_","_VALUE
 E  D
 . S HTTPREQ("header",NAME)=VALUE,HTTPREQ("header")=NAME
 Q
 ;
ETSOCK ; error trap when handling socket (i.e., client closes connection)
 D LOGERR
 C $P H 2
 HALT  ; exit because connection has been closed
 ;
ETCODE ; error trap when calling out to routines
 S $ETRAP="G ETBAIL^VPRJREQ"
 I $TLEVEL TROLLBACK ; abandon any transactions
 L                   ; release any locks
 ; Set the error information and write it as the HTTP response.
 D LOGERR
 D SETERROR^VPRJRUT(501,"Log ID:"_HTTPLOG("ID")) ; sets HTTPERR
 D RSPERROR^VPRJRSP  ; switch to error response
 D SENDATA^VPRJRSP
 ; Leave $ECODE as non-null so that the error handling continues.
 ; This next line will 'unwind' the stack and got back to listening
 ; for the next HTTP request (goto NEXT).
 S $ETRAP="Q:$ESTACK&$QUIT 0 Q:$ESTACK  S $ECODE="""" G NEXT"
 Q
ETBAIL ; error trap of error traps
 U $P
 W "HTTP/1.1 500 Internal Server Error",$C(13,10),$C(13,10),!
 C $P H 1
 K ^TMP($J),^TMP("HTTPERR",$J)
 HALT  ; exit because we can't recover
 ;
INCRLOG ; get unique log id for each request
 N DT,ID
 S DT=HTTPLOG("DT")
 L +^VPRHTTP("log",DT):2 E  S HTTPLOG("ID")=99999 Q  ; get unique logging session
 S ID=$G(^VPRHTTP("log",DT),0)+1
 S ^VPRHTTP("log",DT)=ID
 L -^VPRHTTP("log",DT)
 S HTTPLOG("ID")=ID
 Q:'HTTPLOG
 S ^VPRHTTP("log",DT,$J,ID)=$$HTE^XLFDT($H)_"  $J:"_$J_"  $P:"_$P_"  $STACK:"_$STACK
 Q
LOGRAW(X) ; log raw lines read in
 N DT,ID,LN
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 S LN=$G(^VPRHTTP("log",DT,$J,ID,"raw"),0)+1
 S ^VPRHTTP("log",DT,$J,ID,"raw")=LN
 S ^VPRHTTP("log",DT,$J,ID,"raw",LN)=X
 S ^VPRHTTP("log",DT,$J,ID,"raw",LN,"ZB")=$A($ZB)
 Q
LOGHDR(X) ; log header lines read in
 N DT,ID,LN
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 S LN=$G(^VPRHTTP("log",DT,$J,ID,"req","header"),0)+1
 S ^VPRHTTP("log",DT,$J,ID,"req","header")=LN
 S ^VPRHTTP("log",DT,$J,ID,"req","header",LN)=X
 Q
LOGBODY ; log the request body
 Q:'$D(HTTPREQ("body"))
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 M ^VPRHTTP("log",DT,$J,ID,"req","body")=HTTPREQ("body")
 Q
LOGRSP ; log the response before sending
 Q:'$L($G(HTTPRSP))  Q:'$D(@HTTPRSP)
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 M ^VPRHTTP("log",DT,$J,ID,"response")=@HTTPRSP
 Q
LOGERR ; log error information
 N %D,%I
 S %D=HTTPLOG("DT"),%I=HTTPLOG("ID")
 S ^VPRHTTP("log",%D,$J,%I,"error")=$ZERROR_"  ($ECODE:"_$ECODE_")"
 N %LVL,%TOP,%N
 S %TOP=$STACK(-1),%N=0
 F %LVL=0:1:%TOP S %N=%N+1,^VPRHTTP("log",%D,$J,%I,"error","stack",%N)=$STACK(%LVL,"PLACE")_":"_$STACK(%LVL,"MCODE")
 N %X,%Y
 S %X="^VPRHTTP(""log"",%D,$J,%I,""error"",""symbols"","
 ;TODO make the following loop work also in GTM (DOLRO^%ZOSV)
 S %Y="%" F  M:$D(@%Y) @(%X_"%Y)="_%Y) S %Y=$O(@%Y) Q:%Y=""
 Q
 ;
 ;
 ; Deprecated -- use VPRJ
 ;
GO ; start up REST listener with defaults
 N PORT
 S PORT=$G(^VPRHTTP(0,"port"),9080)
 J START^VPRJREQ(PORT)
 Q
STOP ; tell the listener to stop running
 S ^VPRHTTP(0,"listener")="stopped"
 Q

VPRJRSP^INT^1^62766,56120.947482^0
VPRJRSP ;SLC/KCM -- Handle HTTP Response
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; -- prepare and send RESPONSE
 ;
RESPOND ; find entry point to handle request and call it
 ; expects HTTPREQ, HTTPRSP is used to return the response
 ;
 ; TODO: check cache of HEAD requests first and return that if there?
 K ^TMP($J)
 N ROUTINE,LOCATION,HTTPARGS,HTTPBODY
 D MATCH(.ROUTINE,.HTTPARGS) I $G(HTTPERR) QUIT
 D QSPLIT(.HTTPARGS) I $G(HTTPERR) QUIT
 S HTTPREQ("paging")=$G(HTTPARGS("start"),0)_":"_$G(HTTPARGS("limit"),999999)
 S HTTPREQ("store")=$S($$LOW^VPRJRUT($E(HTTPREQ("path"),2,4))="vpr":"vpr",1:"data")
 I "PUT,POST"[HTTPREQ("method") D
 . N BODY
 . M BODY=HTTPREQ("body") K HTTPREQ("body")
 . X "S LOCATION=$$"_ROUTINE_"(.HTTPARGS,.BODY)"
 . I $L(LOCATION) S HTTPREQ("location")=$S($D(HTTPREQ("header","host")):"http://"_HTTPREQ("header","host")_LOCATION,1:LOCATION)
 E  D @(ROUTINE_"(.HTTPRSP,.HTTPARGS)")
 Q
QSPLIT(QUERY) ; parses and decodes query fragment into array
 ; expects HTTPREQ to contain "query" node
 ; .QUERY will contain query parameters as subscripts: QUERY("name")=value
 N I,X,NAME,VALUE
 F I=1:1:$L(HTTPREQ("query"),"&") D
 . S X=$$URLDEC^VPRJRUT($P(HTTPREQ("query"),"&",I))
 . S NAME=$P(X,"="),VALUE=$P(X,"=",2,999)
 . I $L(NAME) S QUERY($$LOW^VPRJRUT(NAME))=VALUE
 Q
MATCH(ROUTINE,ARGS) ; evaluate paths in sequence until match found (else 404)
 ; TODO: this needs some work so that it will accomodate patterns shorter than the path
 ; expects HTTPREQ to contain "path" and "method" nodes
 ; ROUTINE contains the TAG^ROUTINE to execute for this path, otherwise empty
 ; .ARGS will contain an array of resolved path arguments
 ;
 N SEQ,PATH,PATTERN,DONE,FAIL,I,PATHSEG,PATTSEG,TEST,ARGUMENT,METHOD,PATHOK
 S DONE=0,PATH=HTTPREQ("path"),PATHOK=0
 S:$E(PATH)="/" PATH=$E(PATH,2,$L(PATH))
 F SEQ=1:1 S PATTERN=$P($T(URLMAP+SEQ),";;",2,99) Q:PATTERN="zzzzz"  D  Q:DONE
 . K ARGS
 . S ROUTINE=$P(PATTERN," ",3),METHOD=$P(PATTERN," "),PATTERN=$P(PATTERN," ",2),FAIL=0
 . I $L(PATTERN,"/")'=$L(PATH,"/") S ROUTINE="" Q  ; must have same number segments
 . F I=1:1:$L(PATH,"/") D  Q:FAIL
 . . S PATHSEG=$$URLDEC^VPRJRUT($P(PATH,"/",I),1)
 . . S PATTSEG=$$URLDEC^VPRJRUT($P(PATTERN,"/",I),1)
 . . I $E(PATTSEG)'="{" S FAIL=($$LOW^VPRJRUT(PATHSEG)'=$$LOW^VPRJRUT(PATTSEG)) Q
 . . S PATTSEG=$E(PATTSEG,2,$L(PATTSEG)-1) ; get rid of curly braces
 . . S ARGUMENT=$P(PATTSEG,"?"),TEST=$P(PATTSEG,"?",2)
 . . I $L(TEST) S FAIL=(PATHSEG'?@TEST) Q:FAIL
 . . S ARGS(ARGUMENT)=PATHSEG
 . I 'FAIL S PATHOK=1 I METHOD'=HTTPREQ("method") S FAIL=1
 . S:FAIL ROUTINE="" S:'FAIL DONE=1
 I PATHOK,ROUTINE="" D SETERROR^VPRJRUT(405,"Method Not Allowed") QUIT
 I ROUTINE="" D SETERROR^VPRJRUT(404,"Not Found") QUIT
 Q
SENDATA ; write out the data as an HTTP response
 ; expects HTTPERR to contain the HTTP error code, if any
 ; RSPTYPE=1  local variable
 ; RSPTYPE=2  data in ^TMP($J)
 ; RSPTYPE=3  pageable data in ^TMP($J,"data") or ^VPRTMP(hash,"data")
 N SIZE,RSPTYPE,PREAMBLE,START,LIMIT
 S RSPTYPE=$S($E($G(HTTPRSP))'="^":1,$D(HTTPRSP("pageable")):3,1:2)
 I RSPTYPE=1 S SIZE=$$VARSIZE^VPRJRUT(.HTTPRSP)
 I RSPTYPE=2 S SIZE=$$REFSIZE^VPRJRUT(.HTTPRSP)
 I RSPTYPE=3 D
 . S START=$P(HTTPREQ("paging"),":"),LIMIT=$P(HTTPREQ("paging"),":",2)
 . D PAGE^VPRJRUT(.HTTPRSP,START,LIMIT,.SIZE,.PREAMBLE)
 ;
 ; TODO: Handle HEAD requests differently
 ;       (put HTTPRSP in ^XTMP and return appropriate header)
 ; TODO: Handle 201 responses differently (change simple OK to created)
 ;
 W $$RSPLINE(),$C(13,10)
 W "Date: "_$$GMT^VPRJRUT_$C(13,10)
 I $D(HTTPREQ("location")) W "Location: "_HTTPREQ("location")_$C(13,10)
 W "Content-Type: application/json"_$C(13,10)
 W "Content-Length: ",SIZE,$C(13,10)_$C(13,10)
 I 'SIZE W $C(13,10),! Q  ; flush buffer and quit
 ;
 N I,J
 I RSPTYPE=1 D            ; write out local variable
 . I $D(HTTPRSP)#2 W HTTPRSP
 . I $D(HTTPRSP)>1 S I=0 F  S I=$O(HTTPRSP(I)) Q:'I  W HTTPRSP(I)
 I RSPTYPE=2 D            ; write out global using indirection
 . I $D(@HTTPRSP)#2 W @HTTPRSP
 . I $D(@HTTPRSP)>1 S I=0 F  S I=$O(@HTTPRSP@(I)) Q:'I  W @HTTPRSP@(I)
 I RSPTYPE=3 D            ; write out pageable records
 . W PREAMBLE
 . F I=START:1:(START+LIMIT-1) Q:'$D(@HTTPRSP@($J,I))  D
 . . I I>START W "," ; separate items with a comma
 . . S J="" F  S J=$O(@HTTPRSP@($J,I,J)) Q:'J  W @HTTPRSP@($J,I,J)
 . W "]}}"
 . K @HTTPRSP@($J)
 W $C(13,10),!  ; flush buffer
 I RSPTYPE=3,($E(HTTPRSP,1,4)="^TMP") D UPDCACHE
 Q
UPDCACHE ; update the cache for this query
 I HTTPREQ("store")="data" G UPD4DATA
UPD4VPR ;
 N PID,INDEX,HASH,HASHTS,MTHD
 S PID=$G(^TMP($J,"pid")),INDEX=$G(^TMP($J,"index"))
 S HASH=$G(^TMP($J,"hash")),HASHTS=$G(^TMP($J,"timestamp"))
 Q:'$L(PID)  Q:'$L(INDEX)  Q:'$L(HASH)
 ;
 S MTHD=$G(^VPRMETA("index",INDEX,"common","method"))
 L +^VPRTMP(HASH):1  E  Q
 I $G(^VPRPTI(PID,MTHD,INDEX))=HASHTS D
 . K ^VPRTMP(HASH)
 . M ^VPRTMP(HASH)=^TMP($J)
 . S ^VPRTMP(HASH,"created")=$H
 . S ^VPRTMP("PID",PID,HASH)=""
 L -^VPRTMP(HASH)
 Q
UPD4DATA ;
 N INDEX,HASH,HASHTS,MTHD
 S INDEX=$G(^TMP($J,"index"))
 S HASH=$G(^TMP($J,"hash")),HASHTS=$G(^TMP($J,"timestamp"))
 Q:'$L(INDEX)  Q:'$L(HASH)
 ;
 S MTHD=$G(^VPRJMETA("index",INDEX,"common","method"))
 L +^VPRTMP(HASH):1  E  Q
 I $G(^VPRJDX(MTHD,INDEX))=HASHTS D
 . K ^VPRTMP(HASH)
 . M ^VPRTMP(HASH)=^TMP($J)
 . S ^VPRTMP(HASH,"created")=$H
 L -^VPRTMP(HASH)
 Q
RSPERROR ; set response to be an error response
 D ENCODE^VPRJSON("^TMP(""HTTPERR"",$J,1)","^TMP(""HTTPERR"",$J,""JSON"")")
 S HTTPRSP="^TMP(""HTTPERR"",$J,""JSON"")"
 K HTTPRSP("pageable")
 Q
RSPLINE() ; writes out a response line based on HTTPERR
 I '$G(HTTPERR),'$D(HTTPREQ("location")) Q "HTTP/1.1 200 OK"
 I '$G(HTTPERR),$D(HTTPREQ("location")) Q "HTTP/1.1 201 Created"
 I $G(HTTPERR)=400 Q "HTTP/1.1 400 Bad Request"
 I $G(HTTPERR)=404 Q "HTTP/1.1 404 Not Found"
 I $G(HTTPERR)=405 Q "HTTP/1.1 405 Method Not Allowed"
 Q "HTTP/1.1 500 Internal Server Error"
 ;
PING(RESULT,ARGS) ; writes out a ping response
 S RESULT="{""status"":""running""}"
 Q
VPRMATCH(ROUTINE,ARGS) ; specific algorithm for matching URL's
 Q
URLMAP ; map URLs to entry points (HTTP methods handled within entry point)
 ;;POST vpr/{pid?1.N} PUTOBJ^VPRJPR
 ;;PUT vpr/{pid?1.N} PUTOBJ^VPRJPR
 ;;GET vpr/{pid?1.N}/index/{indexName} INDEX^VPRJPR
 ;;GET vpr/{pid?1.N}/index/{indexName}/{template} INDEX^VPRJPR
 ;;GET vpr/{pid?1.N}/count/{countName} COUNT^VPRJPR
 ;;GET vpr/{pid?1.N}/last/{indexName} LAST^VPRJPR
 ;;GET vpr/{pid?1.N}/last/{indexName}/{template} LAST^VPRJPR
 ;;GET vpr/{pid?1.N}/{uid?1"urn:".E} GETOBJ^VPRJPR
 ;;GET vpr/{pid?1.N}/{uid?1"urn:".E}/{template} GETOBJ^VPRJPR
 ;;GET vpr/{pid?1.N}/find/{collection} FIND^VPRJPR
 ;;GET vpr/{pid?1.N}/find/{collection}/{template} FIND^VPRJPR
 ;;GET vpr/{pid?1.N} GETPT^VPRJPR
 ;;GET vpr/uid/{uid?1"urn:".E} GETUID^VPRJPR
 ;;GET vpr/uid/{uid?1"urn:".E}/{template} GETUID^VPRJPR
 ;;POST vpr PUTPT^VPRJPR
 ;;PUT vpr PUTPT^VPRJPR
 ;;GET vpr/all/count/{countName} ALLCOUNT^VPRJPR
 ;;GET vpr/all/index/{indexName} ALLINDEX^VPRJPR
 ;;GET vpr/all/index/{indexName}/{template} ALLINDEX^VPRJPR
 ;;GET vpr/all/find/{collection} ALLFIND^VPRJPR
 ;;GET vpr/all/find/{collection}/{template} ALLFIND^VPRJPR
 ;;GET vpr/pid/{icndfn} PID^VPRJPR
 ;;DELETE vpr/{pid?1.N}/{uid?1"urn:".E} DELUID^VPRJPR
 ;;DELETE vpr/uid/{uid?1"urn:".E} DELUID^VPRJPR
 ;;DELETE vpr/{pid?1.N} DELPT^VPRJPR
 ;;DELETE vpr DELALL^VPRJPR
 ;;DELETE vpr/{pid?1.N}/collection/{collectionName} DELCOLL^VPRJPR
 ;;DELETE vpr/all/collection/{collectionName} ALLDELC^VPRJPR
 ;;POST data PUTOBJ^VPRJDR
 ;;PUT data PUTOBJ^VPRJDR
 ;;PUT data/{collectionName} NEWOBJ^VPRJDR
 ;;POST data/{collectionName} NEWOBJ^VPRJDR
 ;;GET data/{uid?1"urn:".E} GETOBJ^VPRJDR
 ;;GET data/index/{indexName} INDEX^VPRJDR
 ;;GET data/last/{indexName} LAST^VPRJDR
 ;;GET data/count/{countName} COUNT^VPRJDR
 ;;GET data/find/{collection} FIND^VPRJDR
 ;;GET data/find/{collection}/{template} FIND^VPRJDR
 ;;DELETE data/{uid?1"urn:".E} DELUID^VPRJDR
 ;;DELETE data/collection/{collectionName} DELCTN^VPRJDR
 ;;DELETE data DELALL^VPRJDR
 ;;GET ping PING^VPRJRSP
 ;;zzzzz
 Q

VPRJRUT^INT^1^62766,53305.419057^0
VPRJRUT ;SLC/KCM -- Utilities for HTTP communications
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
LOW(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
 ;
LTRIM(%X) ; Trim whitespace from left side of string
 ; derived from XLFSTR, but also removes tabs
 N %L,%R
 S %L=1,%R=$L(%X)
 F %L=1:1:$L(%X) Q:$A($E(%X,%L))>32
 Q $E(%X,%L,%R)
 ;
URLENC(X) ; Encode a string for use in a URL
 ; Q $ZCONVERT(X,"O","URL")  ; uncomment for fastest performance on Cache
 ; =, &, %, +, non-printable 
 ; {, } added JC 7-24-2012
 N I,Y,Z,LAST
     S Y=$P(X,"%") F I=2:1:$L(X,"%") S Y=Y_"%25"_$P(X,"%",I)
 S X=Y,Y=$P(X,"&") F I=2:1:$L(X,"&") S Y=Y_"%26"_$P(X,"&",I)
 S X=Y,Y=$P(X,"=") F I=2:1:$L(X,"=") S Y=Y_"%3D"_$P(X,"=",I)
 S X=Y,Y=$P(X,"+") F I=2:1:$L(X,"+") S Y=Y_"%2B"_$P(X,"+",I)
 S X=Y,Y=$P(X,"{") F I=2:1:$L(X,"{") S Y=Y_"%7B"_$P(X,"{",I)
 S X=Y,Y=$P(X,"}") F I=2:1:$L(X,"}") S Y=Y_"%7D"_$P(X,"}",I)
 S Y=$TR(Y," ","+")
 S Z="",LAST=1
 F I=1:1:$L(Y) I $A(Y,I)<32 D
 . S CODE=$$DEC2HEX($A(Y,I)),CODE=$TR($J(CODE,2)," ","0")
 . S Z=Z_$E(Y,LAST,I-1)_"%"_CODE,LAST=I+1
 S Z=Z_$E(Y,LAST,$L(Y))
 Q Z
 ;
URLDEC(X,PATH) ; Decode a URL-encoded string
 ; Q $ZCONVERT(X,"I","URL")  ; uncomment for fastest performance on Cache
 ;
 N I,OUT,FRAG,ASC
 S:'$G(PATH) X=$TR(X,"+"," ") ; don't convert '+' in path fragment
 F I=1:1:$L(X,"%") D
 . I I=1 S OUT=$P(X,"%") Q
 . S FRAG=$P(X,"%",I),ASC=$E(FRAG,1,2),FRAG=$E(FRAG,3,$L(FRAG))
 . I $L(ASC) S OUT=OUT_$C($$HEX2DEC(ASC))
 . S OUT=OUT_FRAG
 Q OUT
 ;
REFSIZE(ROOT) ; return the size of glvn passed in ROOT
 Q:'$D(ROOT) 0 Q:'$L(ROOT) 0
 N SIZE,I
 S SIZE=0
 I $D(@ROOT)#2 S SIZE=$L(@ROOT)
 I $D(@ROOT)>1 S I=0 F  S I=$O(@ROOT@(I)) Q:'I  S SIZE=SIZE+$L(@ROOT@(I))
 Q SIZE
 ;
VARSIZE(V) ; return the size of a variable
 Q:'$D(V) 0
 N SIZE,I
 S SIZE=0
 I $D(V)#2 S SIZE=$L(V)
 I $D(V)>1 S I="" F  S I=$O(V(I)) Q:'I  S SIZE=SIZE+$L(V(I))
 Q SIZE
 ;
PAGE(ROOT,START,LIMIT,SIZE,PREAMBLE) ; create the size and preamble for a page of data
 Q:'$D(ROOT) 0 Q:'$L(ROOT) 0
 N I,J,KEY,KINST,COUNT,TEMPLATE,PID
 K @ROOT@($J)
 S SIZE=0,COUNT=0,TEMPLATE=$G(@ROOT@("template"),0),PID=$G(@ROOT@("pid"))
 F I=START:1:(START+LIMIT-1) Q:'$D(@ROOT@("data",I))  S COUNT=COUNT+1 D
 . S KEY="" F  S KEY=$O(@ROOT@("data",I,KEY)) Q:KEY=""  D
 . . S KINST="" F  S KINST=$O(@ROOT@("data",I,KEY,KINST)) Q:KINST=""  D
 . . . S PID=^(KINST)  ; null if non-pt data
 . . . D TMPLT(ROOT,TEMPLATE,I,KEY,KINST,PID)
 . . . S J="" F  S J=$O(@ROOT@($J,I,J)) Q:'J  S SIZE=SIZE+$L(@ROOT@($J,I,J))
 S PREAMBLE=$$BLDHEAD(@ROOT@("total"),COUNT,START,LIMIT)
 ; add 3 for "]}}", add COUNT-1 for commas
 S SIZE=SIZE+$L(PREAMBLE)+3+COUNT-$S('COUNT:0,1:1)
 Q
TMPLT(ROOT,TEMPLATE,ITEM,KEY,KINST,PID) ; set template
 I HTTPREQ("store")="data" G TLT4DATA
TLT4VPR ;
 ; called from PAGE
 I $G(TEMPLATE)="uid" S @ROOT@($J,ITEM,1)="{""uid"":"""_KEY_"""}" Q
 ; other template
 I $L(TEMPLATE),$D(^VPRPT("TEMPLATE",PID,KEY,TEMPLATE)) M @ROOT@($J,ITEM)=^(TEMPLATE) Q
 ; else full object
 M @ROOT@($J,ITEM)=^VPRPT("JSON",PID,KEY)
 Q
TLT4DATA ;
 ; called from PAGE
 I $G(TEMPLATE)="uid" S @ROOT@($J,ITEM,1)="{""uid"":"""_KEY_"""}" Q
 ; other template
 I $L(TEMPLATE),$D(^VPRJD("TEMPLATE",KEY,TEMPLATE)) M @ROOT@($J,ITEM)=^(TEMPLATE) Q
 ; else full object
 M @ROOT@($J,ITEM)=^VPRJD("JSON",KEY)
 Q
BLDHEAD(TOTAL,COUNT,START,LIMIT) ; Build the object header
 N X,UPDATED
 S UPDATED=$P($$FMTHL7^XLFDT($$NOW^XLFDT),"+")
 S X="{""apiVersion"":""1.0"",""data"":{""updated"":"_UPDATED_","
 S X=X_"""totalItems"":"_TOTAL_","
 S X=X_"""currentItemCount"":"_COUNT_","
 I LIMIT'=999999 D  ; only set thise if paging
 . S X=X_"""itemsPerPage"":"_LIMIT_","
 . S X=X_"""startIndex"":"_START_","
 . S X=X_"""pageIndex"":"_(START\LIMIT)_","
 . S X=X_"""totalPages"":"_(TOTAL\LIMIT+$S(TOTAL#LIMIT:1,1:0))_","
 S X=X_"""items"":["
 Q X
 ;
SETERROR(ERRCODE,MESSAGE) ; set error info into ^TMP("HTTPERR",$J)
 ; causes HTTPERR system variable to be set
 ; ERRCODE:  query errors are 100-199, update errors are 200-299, M errors are 500
 ; MESSAGE:  additional explanatory material
 N NEXTERR,ERRNAME,TOPMSG
 S HTTPERR=400,TOPMSG="Bad Request"
 ; query errors (100-199)
 I ERRCODE=101 S ERRNAME="Missing name of index"
 I ERRCODE=102 S ERRNAME="Invalid index name"
 I ERRCODE=103 S ERRNAME="Parameter error"
 I ERRCODE=104 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Bad key"
 I ERRCODE=105 S ERRNAME="Template required"
 I ERRCODE=106 S ERRNAME="Bad Filter Parameter"
 I ERRCODE=107 S ERRNAME="Unsupported Field Name"
 I ERRCODE=108 S ERRNAME="Bad Order Parameter"
 I ERRCODE=109 S ERRNAME="Operation not supported with this index"
 I ERRCODE=110 S ERRNAME="Order field unknown"
 I ERRCODE=111 S ERRNAME="Unrecognized parameter"
 I ERRCODE=112 S ERRNAME="Filter required"
 ; update errors (200-299)
 I ERRCODE=201 S ERRNAME="Unknown collection" ; unused?
 I ERRCODE=202 S ERRNAME="Unable to decode JSON"
 I ERRCODE=203 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Unable to determine patient"
 I ERRCODE=204 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Unable to determine collection" ; unused?
 I ERRCODE=205 S ERRNAME="Patient mismatch with object"
 I ERRCODE=207 S ERRNAME="Missing UID"
 I ERRCODE=209 S ERRNAME="Missing range or index" ; unused?
 I ERRCODE=210 S ERRNAME="Unknown UID format"
 I ERRCODE=211 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Missing patient identifiers"
 I ERRCODE=212 S ERRNAME="Mismatch of patient identifiers"
 I ERRCODE=213 S ERRNAME="Delete demographics only not allowed"
 I ERRCODE=214 S HTTPERR=404,ERRNAME="Patient ID not found in database"
 I ERRCODE=215 S ERRNAME="Missing collection name"
 I ERRCODE=216 S ERRNAME="Incomplete deletion of collection"
 ; HTTP errors
 I ERRCODE=400 S ERRNAME="Bad Request"
 I ERRCODE=404 S ERRNAME="Not Found"
 I ERRCODE=405 S ERRNAME="Method Not Allowed"
 ; system errors (500-599)
 I ERRCODE=501 S ERRNAME="M execution error"
 I ERRCODE=502 S ERRNAME="Unable to lock record"
 I '$L($G(ERRNAME)) S ERRNAME="Unknown error"
 ;
 I ERRCODE>500 S HTTPERR=500,TOPMSG="Internal Server Error"  ; M Server Error
 I ERRCODE<500,ERRCODE>400 S HTTPERR=ERRCODE,TOPMSG=ERRNAME  ; Other HTTP Errors 
 S NEXTERR=$G(^TMP("HTTPERR",$J,0),0)+1,^TMP("HTTPERR",$J,0)=NEXTERR
 S ^TMP("HTTPERR",$J,1,"apiVersion")="1.0"
 S ^TMP("HTTPERR",$J,1,"error","code")=HTTPERR
 S ^TMP("HTTPERR",$J,1,"error","message")=TOPMSG
 S ^TMP("HTTPERR",$J,1,"error","request")=$G(HTTPREQ("method"))_" "_$G(HTTPREQ("path"))_" "_$G(HTTPREQ("query"))
 S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"reason")=ERRCODE
 S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"message")=ERRNAME
 I $L($G(MESSAGE)) S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"domain")=MESSAGE
 Q
 ;
 ; Cache specific functions
 ;
LCLHOST() ; return TRUE if the peer connection is localhost
 I $E($I,1,5)'="|TCP|" Q 0
 N VER,ADDR
 S VER=$P($P($ZV,") ",2),"(")
 I VER<2011 S ADDR=$ZU(111,0),ADDR=$A(ADDR,1)_"."_$A(ADDR,2)_"."_$A(ADDR,3)_"."_$A(ADDR,4) I 1
 E  S ADDR=$SYSTEM.TCPDevice.PeerAddr(0)
 I ADDR="127.0.0.1" Q 1
 I ADDR="0:0:0:0:0:0:0:1" Q 1
 I ADDR="::1" Q 1
 Q 0
 ;
HASH(X) ; return CRC-32 of string contained in X
 Q $ZCRC(X,7) ; return the CRC-32 value
 ;
GMT() ; return HTTP date string (this is really using UTC instead of GMT)
 N TM,DAY
 S TM=$ZTIMESTAMP,DAY=$ZDATETIME(TM,11)
 Q $P(DAY," ")_", "_$ZDATETIME(TM,2)_" GMT"
 ;
SYSID() ; return a likely unique system ID
 N X
 S X=$ZUTIL(110)_":"_$G(^VPRHTTP("port"),9080)
 Q $ZHEX($ZCRC(X,6))
 ;
DEC2HEX(NUM) ; return a decimal number as hex
 Q $ZHEX(NUM)
 ;
HEX2DEC(HEX) ; return a hex number as decimal
 Q $ZHEX(HEX_"H")
 ;
WR4HTTP ; open file to save HTTP response
 O "VPRJT.TXT":"WNS"  ; open for writing
 U "VPRJT.TXT"
 Q
RD4HTTP() ; read HTTP body from file and return as value
 N X
 O "VPRJT.TXT":"RSD" ; for reading and delete when done
 U "VPRJT.TXT"
 F  R X:1 Q:'$L(X)  ; read lines until there is an empty one
 R X:2              ; now read the JSON object
 D C4HTTP
 Q X
 ;
C4HTTP ; close file used for HTTP response
 C "VPRJT.TXT"
 U $P
 Q

VPRJSON^INT^1^62756,62812.942643^0
VPRJSON ;SLC/KCM -- Decode/Encode JSON
 ;;1.0;VIRTUAL PATIENT RECORD;**2**;Sep 01, 2011;Build 50
 ;
 ; Note:  Since the routines use closed array references, VVROOT and VVERR
 ;        are used to reduce risk of naming conflicts on the closed array.
 ;
DECODE(VVJSON,VVROOT,VVERR)  ; Set JSON object into closed array ref VVROOT
 ; Examples: D DECODE^VPRJSON("MYJSON","LOCALVAR","LOCALERR")
 ;           D DECODE^VPRJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
 ;
 ; VVJSON: string/array containing serialized JSON object
 ; VVROOT: closed array reference for M representation of object
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 ;   VVIDX: points to next character in JSON string to process
 ; VVSTACK: manages stack of subscripts
 ;  VVPROP: true if next string is property name, otherwise treat as value
 ;
 G DIRECT^VPRJSOND
 ;
ENCODE(VVROOT,VVJSON,VVERR) ; VVROOT (M structure) --> VVJSON (array of strings)
 ; Examples:  D ENCODE^VPRJSON("^GLO(99,2)","^TMP($J)")
 ;            D ENCODE^VPRJSON("LOCALVAR","MYJSON","LOCALERR")
 ;
 ; VVROOT: closed array reference for M representation of object
 ; VVJSON: destination variable for the string array formatted as JSON
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 G DIRECT^VPRJSONE
 ;
 ;
ESC(X) ; Escape string for JSON
 Q $$ESC^VPRJSONE(X)
 ;
UES(X) ; Unescape JSON string
 Q $$UES^VPRJSOND(X)
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 ; switch (ID) -- XERRX ends statement
 N ERRMSG
 ;
 ; Decode Error Messages
 ;
 I ID="STL{" S ERRMSG="Stack too large for new object." G XERRX
 I ID="SUF}" S ERRMSG="Stack Underflow - extra } found" G XERRX
 I ID="STL[" S ERRMSG="Stack too large for new array." G XERRX
 I ID="SUF]" S ERRMSG="Stack Underflow - extra ] found." G XERRX
 I ID="OBM" S ERRMSG="Array mismatch - expected ] got }." G XERRX
 I ID="ARM" S ERRMSG="Object mismatch - expected } got ]." G XERRX
 I ID="MPN" S ERRMSG="Missing property name." G XERRX
 I ID="EXT" S ERRMSG="Expected true, got "_VAL G XERRX
 I ID="EXF" S ERRMSG="Expected false, got "_VAL G XERRX
 I ID="EXN" S ERRMSG="Expected null, got "_VAL G XERRX
 I ID="TKN" S ERRMSG="Unable to identify type of token, value was "_VAL G XERRX
 I ID="SCT" S ERRMSG="Stack mismatch - exit stack level was  "_VAL G XERRX
 I ID="EIQ" S ERRMSG="Close quote not found before end of input." G XERRX
 I ID="EIU" S ERRMSG="Unexpected end of input while unescaping." G XERRX
 I ID="RSB" S ERRMSG="Reverse search for \ past beginning of input." G XERRX
 I ID="ORN" S ERRMSG="Overrun while scanning name." G XERRX
 I ID="OR#" S ERRMSG="Overrun while scanning number." G XERRX
 I ID="ORB" S ERRMSG="Overrun while scanning boolean." G XERRX
 I ID="ESC" S ERRMSG="Escaped character not recognized"_VAL G XERRX
 ;
 ; Encode Error Messages
 ;
 I ID="SOB" S ERRMSG="Unable to serialize node as object, value was "_VAL G XERRX
 I ID="SAR" S ERRMSG="Unable to serialize node as array, value was "_VAL G XERRX
 S ERRMSG="Unspecified error "_ID_" "_$G(VAL)
XERRX ; end switch
 S @VVERR@(0)=$G(@VVERR@(0))+1
 S @VVERR@(@VVERR@(0))=ERRMSG
 S VVERRORS=VVERRORS+1
 Q

VPRJSOND^INT^1^62756,62812.949468^0
VPRJSOND ;SLC/KCM -- Decode JSON
 ;;1.0;VIRTUAL PATIENT RECORD;**2**;Sep 01, 2011;Build 50
 ;
DECODE(VVJSON,VVROOT,VVERR) ; Set JSON object into closed array ref VVROOT
 ;
DIRECT ; TAG for use by DECODE^VPRJSON
 ;
 ; Examples: D DECODE^VPRJSON("MYJSON","LOCALVAR","LOCALERR")
 ;           D DECODE^VPRJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
 ;
 ; VVJSON: string/array containing serialized JSON object
 ; VVROOT: closed array reference for M representation of object
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 ;   VVIDX: points to next character in JSON string to process
 ; VVSTACK: manages stack of subscripts
 ;  VVPROP: true if next string is property name, otherwise treat as value
 ;
 N VVMAX S VVMAX=4000 ; limit document lines to 4000 characters
 S VVERR=$G(VVERR,"^TMP(""VPRJERR"",$J)")
 ; If a simple string is passed in, move it to an temp array (VVINPUT)
 ; so that the processing is consistently on an array.
 I $D(@VVJSON)=1 N VVINPUT S VVINPUT(1)=@VVJSON,VVJSON="VVINPUT"
 S VVROOT=$NA(@VVROOT@("Z")),VVROOT=$E(VVROOT,1,$L(VVROOT)-4) ; make open array ref
 N VVLINE,VVIDX,VVSTACK,VVPROP,VVTYPE,VVERRORS
 S VVLINE=$O(@VVJSON@("")),VVIDX=1,VVSTACK=0,VVPROP=0,VVERRORS=0
 F  S VVTYPE=$$NXTKN() Q:VVTYPE=""  D  I VVERRORS Q
 . I VVTYPE="{" S VVSTACK=VVSTACK+1,VVSTACK(VVSTACK)="",VVPROP=1 D:VVSTACK>64 ERRX("STL{") Q
 . I VVTYPE="}" D:VVSTACK(VVSTACK) ERRX("OBM") S VVSTACK=VVSTACK-1 D:VVSTACK<0 ERRX("SUF}") Q
 . I VVTYPE="[" S VVSTACK=VVSTACK+1,VVSTACK(VVSTACK)=1 D:VVSTACK>64 ERRX("STL[") Q
 . I VVTYPE="]" D:'VVSTACK(VVSTACK) ERRX("ARM") S VVSTACK=VVSTACK-1 D:VVSTACK<0 ERRX("SUF]") Q
 . I VVTYPE="," D  Q
 . . I VVSTACK(VVSTACK) S VVSTACK(VVSTACK)=VVSTACK(VVSTACK)+1  ; next in array
 . . E  S VVPROP=1                                   ; or next property name
 . I VVTYPE=":" S VVPROP=0 D:'$L($G(VVSTACK(VVSTACK))) ERRX("MPN") Q
 . I VVTYPE="""" D  Q
 . . I VVPROP S VVSTACK(VVSTACK)=$$NAMPARS() I 1
 . . E  D ADDSTR
 . S VVTYPE=$TR(VVTYPE,"TFN","tfn")
 . I VVTYPE="t" D  Q
 . . I $TR($E(@VVJSON@(VVLINE),VVIDX,VVIDX+2),"RUE","rue")="rue" D SETBOOL("true") I 1
 . . E  D ERRX("EXT",VVTYPE)
 . I VVTYPE="f" D  Q
 . . I $TR($E(@VVJSON@(VVLINE),VVIDX,VVIDX+3),"ALSE","alse")="alse" D SETBOOL("false") I 1
 . . E  D ERRX("EXF",VVTYPE)
 . I VVTYPE="n" D  Q
 . . I $TR($E(@VVJSON@(VVLINE),VVIDX,VVIDX+2),"ULL","ull")="ull" D SETBOOL("null") I 1
 . . E  D ERRX("EXN",VVTYPE)
 . I "0123456789+-.eE"[VVTYPE S @$$CURNODE()=$$NUMPARS(VVTYPE) Q
 . D ERRX("TKN",VVTYPE)
 I VVSTACK'=0 D ERRX("SCT",VVSTACK)
 Q
NXTKN() ; Move the pointers to the beginning of the next token
 N VVDONE,VVEOF,VVTOKEN
 S VVDONE=0,VVEOF=0 F  D  Q:VVDONE!VVEOF  ; eat spaces & new lines until next visible char
 . I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=$O(@VVJSON@(VVLINE)),VVIDX=1 I 'VVLINE S VVEOF=1 Q
 . I $A(@VVJSON@(VVLINE),VVIDX)>32 S VVDONE=1 Q
 . S VVIDX=VVIDX+1
 Q:VVEOF ""  ; we're at the end of input
 S VVTOKEN=$E(@VVJSON@(VVLINE),VVIDX),VVIDX=VVIDX+1
 Q VVTOKEN
 ;
ADDSTR ; Add string value to current node, escaping text along the way
 ; Expects VVLINE,VVIDX to reference that starting point of the index
 ; TODO: add a mechanism to specify names that should not be escaped
 ;       just store as ":")= and ":",n)=
 ;
 ; Happy path -- we find the end quote in the same line
 N VVEND,VVX
 S VVEND=$F(@VVJSON@(VVLINE),"""",VVIDX)
 I VVEND,($E(@VVJSON@(VVLINE),VVEND-2)'="\") D SETSTR  QUIT  ;normal
 I VVEND,$$ISCLOSEQ(VVLINE) D SETSTR QUIT  ;close quote preceded by escaped \
 ;
 ; Less happy path -- first quote wasn't close quote
 N VVDONE,VVTLINE
 S VVDONE=0,VVTLINE=VVLINE ; VVTLINE for temporary increment of VVLINE
 F  D  Q:VVDONE  Q:VVERRORS
 . ;if no quote on current line advance line, scan again
 . I 'VVEND S VVTLINE=VVTLINE+1,VVEND=1 I '$D(@VVJSON@(VVTLINE)) D ERRX("EIQ") Q
 . S VVEND=$F(@VVJSON@(VVTLINE),"""",VVEND)
 . I VVEND,$E(@VVJSON@(VVTLINE),VVEND-2)'="\" S VVDONE=1 Q  ; found quote position
 . S VVDONE=$$ISCLOSEQ(VVTLINE) ; see if this is an escaped quote or closing quote
 Q:VVERRORS
 ; unescape from VVIDX to VVEND, using \-extension nodes as necessary
 D UESEXT
 ; now we need to move VVLINE and VVIDX to next parsing point
 S VVLINE=VVTLINE,VVIDX=VVEND
 Q
SETSTR ; Set simple string value from within same line
 ; expects VVJSON, VVLINE, VVINX, VVEND
 N VVX
 S VVX=$E(@VVJSON@(VVLINE),VVIDX,VVEND-2),VVIDX=VVEND
 S @$$CURNODE()=$$UES(VVX)
 I +VVX=VVX S @$$CURNODE()@("\s")=""
 ;S vX=$S(+vX=vX:$C(186)_vX,1:$$UES(vX))
 ;S @$$CURNODE()=vX
 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1
 Q
UESEXT ; unescape from VVLINE,VVIDX to VVTLINE,VVEND & extend (\) if necessary
 ; expects VVLINE,VVIDX,VVTLINE,VVEND
 N VVI,VVY,VVSTART,VVSTOP,VVDONE,VVBUF,VVNODE,VVMORE,VVTO
 S VVNODE=$$CURNODE(),VVBUF="",VVMORE=0,VVSTOP=VVEND-2
 S VVI=VVIDX,VVY=VVLINE,VVDONE=0
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVSTART=VVI,VVI=$F(@VVJSON@(VVY),"\",VVI)
 . ; if we are on the last line, don't extract past VVSTOP
 . I (VVY=VVTLINE) S VVTO=$S('VVI:VVSTOP,VVI>VVSTOP:VVSTOP,1:VVI-2) I 1
 . E  S VVTO=$S('VVI:99999,1:VVI-2)
 . D ADDBUF($E(@VVJSON@(VVY),VVSTART,VVTO))
 . I (VVY'<VVTLINE),(('VVI)!(VVI>VVSTOP)) S VVDONE=1 QUIT  ; now past close quote
 . I 'VVI S VVY=VVY+1,VVI=1 QUIT  ; nothing escaped, go to next line
 . I VVI>$L(@VVJSON@(VVY)) S VVY=VVY+1,VVI=1 I '$D(@VVJSON@(VVY)) D ERRX("EIU")
 . D ADDBUF($$REALCHAR($E(@VVJSON@(VVY),VVI)))
 . S VVI=VVI+1
 . I (VVY'<VVTLINE),(VVI>VVSTOP) S VVDONE=1 ; VVI incremented past stop
 Q:VVERRORS
 D SAVEBUF
 Q
ADDBUF(VVX) ; add buffer of characters to destination
 ; expects VVBUF,VVMAX,VVNODE,VVMORE to be defined
 ; used directly by ADDSTR
 I $L(VVX)+$L(VVBUF)>VVMAX D SAVEBUF
 S VVBUF=VVBUF_VVX
 Q
SAVEBUF ; write out buffer to destination
 ; expects VVBUF,VVMAX,VVNODE,VVMORE to be defined
 ; used directly by ADDSTR,ADDBUF
 I 'VVMORE S @VVNODE=VVBUF S:+VVBUF=VVBUF @VVNODE@("\s")="" I 1 ;$S(+VVBUF=VVBUF:$C(186)_VVBUF,1:VVBUF)
 E  S @VVNODE@("\",VVMORE)=VVBUF
 S VVMORE=VVMORE+1,VVBUF=""
 Q
ISCLOSEQ(VVBLINE) ; return true if this is a closing, rather than escaped, quote
 ; expects VVJSON, VVIDX, VVEND
 ; always called directly from ADDSTR
 N VVBACK,VVBIDX
 S VVBACK=0,VVBIDX=VVEND-2
 ; starting at VVEND-2 means looking at the char right before the \
 ; if it is not \, then the \ was escaping the quote
 F  D  Q:$E(@VVJSON@(VVBLINE),VVBIDX)'="\"  Q:VVERRORS
 . S VVBACK=VVBACK+1,VVBIDX=VVBIDX-1
 . I (VVBLINE=VVLINE),(VVBIDX=VVIDX) Q  ; back at the open quote
 . Q:VVBIDX
 . ; when VVBIDX<1 go back a line
 . S VVBLINE=VVBLINE-1 I VVBLINE<VVLINE D ERRX("RSB") Q
 . S VVBIDX=$L(@VVJSON@(VVBLINE))
 Q VVBACK#2=0  ; VVBACK is even if this is a close quote
 ;
NAMPARS() ; Return parsed name, advancing index past the close quote
 ; -- This assumes no embedded quotes are in the name itself --
 N VVEND,VVDONE,VVNAME
 S VVDONE=0,VVNAME=""
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVEND=$F(@VVJSON@(VVLINE),"""",VVIDX)
 . I VVEND S VVNAME=VVNAME_$E(@VVJSON@(VVLINE),VVIDX,VVEND-2),VVIDX=VVEND,VVDONE=1
 . I 'VVEND S VVNAME=VVNAME_$E(@VVJSON@(VVLINE),VVIDX,$L(@VVJSON@(VVLINE)))
 . I 'VVEND!(VVEND>$L(@VVJSON@(VVLINE))) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("ORN")
 Q VVNAME
 ;
NUMPARS(VVDIGIT) ; Return parsed number, advancing index past the end of the number
 ; VVIDX intially references the second digit
 N VVDONE,VVNUM
 S VVDONE=0,VVNUM=VVDIGIT
 F  D  Q:VVDONE  Q:VVERRORS
 . I '("0123456789+-.eE"[$E(@VVJSON@(VVLINE),VVIDX)) S VVDONE=1 Q
 . S VVNUM=VVNUM_$E(@VVJSON@(VVLINE),VVIDX)
 . S VVIDX=VVIDX+1 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("OR#")
 Q VVNUM
 ;
SETBOOL(VVX) ; set a value and increment VVIDX
 S @$$CURNODE()=VVX
 S VVIDX=VVIDX+$L(VVX)-1
 N VVDIFF S VVDIFF=VVIDX-$L(@VVJSON@(VVLINE))  ; in case VVIDX moves to next line
 I VVDIFF>0 S VVLINE=VVLINE+1,VVIDX=VVDIFF I '$D(@VVJSON@(VVLINE)) D ERRX("ORB")
 Q
CURNODE() ; Return a global/local variable name based on VVSTACK
 ; Expects VVSTACK to be defined already
 N VVI,VVSUBS
 S VVSUBS=""
 F VVI=1:1:VVSTACK S:VVI>1 VVSUBS=VVSUBS_"," D
 . I VVSTACK(VVI) S VVSUBS=VVSUBS_VVSTACK(VVI)
 . E  S VVSUBS=VVSUBS_""""_VVSTACK(VVI)_""""
 Q VVROOT_VVSUBS_")"
 ;
UES(X) ; Unescape JSON string
 ; copy segments from START to POS-2 (right before \)
 ; translate target character (which is at $F position)
 N POS,Y,START
 S POS=0,Y=""
 F  S START=POS+1 D  Q:START>$L(X)
 . S POS=$F(X,"\",POS+1) ; find next position
 . I 'POS S Y=Y_$E(X,START,$L(X)),POS=$L(X) I 1
 . E  S Y=Y_$E(X,START,POS-2)_$$REALCHAR($E(X,POS))
 . ;S:'POS POS=$L(X)+2  ; get the rest of the string
 . ;S Y=Y_$E(X,START,POS-2)_$$REALCHAR($E(X,POS))
 Q Y
 ;
REALCHAR(C) ; Return actual character from escaped
 I C="""" Q """"
 I C="/" Q "/"
 I C="\" Q "\"
 I C="b" Q $C(8)
 I C="f" Q $C(12)
 I C="n" Q $C(10)
 I C="r" Q $C(13)
 I C="t" Q $C(9)
 I C="u" ;TODO add case for 4-hex-digits (U000A, for example)
 ;otherwise
 I $L($G(VVERR)) D ERRX("ESC",C)
 Q C
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 D ERRX^VPRJSON(ID,$G(VAL))
 Q

VPRJSONE^INT^1^62756,62812.955055^0
VPRJSONE ;SLC/KCM -- Encode JSON
 ;;1.0;VIRTUAL PATIENT RECORD;**2**;Sep 01, 2011;Build 50
 ;
ENCODE(VVROOT,VVJSON,VVERR) ; VVROOT (M structure) --> VVJSON (array of strings)
 ;
DIRECT ; TAG for use by ENCODE^VPRJSON
 ;
 ; Examples:  D ENCODE^VPRJSON("^GLO(99,2)","^TMP($J)")
 ;            D ENCODE^VPRJSON("LOCALVAR","MYJSON","LOCALERR")
 ;
 ; VVROOT: closed array reference for M representation of object
 ; VVJSON: destination variable for the string array formatted as JSON
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 S VVERR=$G(VVERR,"^TMP(""VPRJERR"",$J)")
 I '$L($G(VVROOT)) ; set error info
 I '$L($G(VVJSON)) ; set error info
 N VVLINE,VVMAX,VVERRORS
 S VVLINE=1,VVMAX=4000,VVERRORS=0  ; 96 more bytes of wiggle room
 S @VVJSON@(VVLINE)=""
 D SEROBJ(VVROOT)
 Q
 ;
SEROBJ(VVROOT) ; Serialize into a JSON object
 N VVFIRST,VVSUB,VVNXT
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"{"
 S VVFIRST=1
 S VVSUB="" F  S VVSUB=$O(@VVROOT@(VVSUB)) Q:VVSUB=""  D
 . S:'VVFIRST @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"," S VVFIRST=0
 . ; get the name part
 . D SERNAME(VVSUB)
 . ; if this is a value, serialize it
 . I $$ISVALUE(VVROOT,VVSUB) D SERVAL(VVROOT,VVSUB) Q
 . ; otherwise navigate to the next child object or array
 . I $D(@VVROOT@(VVSUB))=10 S VVNXT=$O(@VVROOT@(VVSUB,"")) D  Q
 . . I +VVNXT D SERARY($NA(@VVROOT@(VVSUB))) I 1
 . . E  D SEROBJ($NA(@VVROOT@(VVSUB)))
 . D ERRX("SOB",VVSUB)  ; should quit loop before here
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"}"
 Q
SERARY(VVROOT) ; Serialize into a JSON array
 N VVFIRST,VVI,VVNXT
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"["
 S VVFIRST=1
 S VVI=0 F  S VVI=$O(@VVROOT@(VVI)) Q:'VVI  D
 . S:'VVFIRST @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"," S VVFIRST=0
 . I $$ISVALUE(VVROOT,VVI) D SERVAL(VVROOT,VVI) Q  ; write value
 . I $D(@VVROOT@(VVI))=10 S VVNXT=$O(@VVROOT@(VVI,"")) D  Q
 . . I +VVNXT D SERARY($NA(@VVROOT@(VVI))) I 1
 . . E  D SEROBJ($NA(@VVROOT@(VVI)))
 . D ERRX("SAR",VVI)  ; should quit loop before here
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"]"
 Q
SERNAME(VVSUB) ; Serialize the object name into JSON string
 I ($L(VVSUB)+$L(@VVJSON@(VVLINE)))>VVMAX S VVLINE=VVLINE+1,@VVJSON@(VVLINE)=""
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_""""_VVSUB_""""_":"
 Q
SERVAL(VVROOT,VVSUB) ; Serialize X into appropriate JSON representation
 N VVX,VVI
 ; if the node is already in JSON format, just add it
 I $D(@VVROOT@(VVSUB,":")) D  QUIT  ; <-- jump out here if preformatted
 . S VVX=$G(@VVROOT@(VVSUB,":")) D:$L(VVX) CONCAT
 . S VVI=0 F  S VVI=$O(@VVROOT@(VVSUB,":",VVI)) Q:'VVI  S VVX=@VVROOT@(VVSUB,":",VVI) D CONCAT
 ;
 S VVX=$G(@VVROOT@(VVSUB))
 ; handle the numeric, boolean, and null types
 I '$D(@VVROOT@(VVSUB,"\s")),$$NUMERIC(VVX) D CONCAT QUIT
 I (VVX="true")!(VVX="false")!(VVX="null") D CONCAT QUIT
 ;I $E(vX)=$C(186) S vX=$E(vX,2,$L(vX)) ; remove the "string-forcing" char
 ; otherwise treat it as a string type
 S VVX=""""_$$ESC(VVX) ; open quote
 D CONCAT
 I $D(@VVROOT@(VVSUB,"\")) D  ; handle continuation nodes
 . S VVI=0 F  S VVI=$O(@VVROOT@(VVSUB,"\",VVI)) Q:'VVI   D
 . . S VVX=$$ESC(@VVROOT@(VVSUB,"\",VVI))
 . . D CONCAT
 S VVX="""" D CONCAT    ; close quote
 Q
CONCAT ; come here to concatenate to JSON string
 I ($L(VVX)+$L(@VVJSON@(VVLINE)))>VVMAX S VVLINE=VVLINE+1,@VVJSON@(VVLINE)=""
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_VVX
 Q
ISVALUE(VVROOT,VVSUB) ; Return true if this is a value node
 I $D(@VVROOT@(VVSUB))#2 Q 1
 N VVX S VVX=$O(@VVROOT@(VVSUB,""))
 Q:VVX="\" 1
 Q:VVX=":" 1
 Q 0
 ;
NUMERIC(X) ; Return true if the numeric
 I X=0 Q 1        ; numeric (value is zero)
 I +X=0 Q 0       ; string
 I X?1"."1.N Q 0  ; string (value begins with decimal)
 I +X=X Q 1       ; numeric
 S X=$TR(X,"e","E")
 I X?.1"-"1.N.1".".N1"E".1"+"1.N Q 1
 I X?.1"-"1.N.1".".N1"E-"1.N Q 1
 Q 0
 ;
ESC(X) ; Escape string for JSON
 N Y,I,PAIR,FROM,TO
 S Y=X
 F PAIR="\\","""""","//",$C(8,98),$C(12,102),$C(10,110),$C(13,114),$C(9,116) D
 . S FROM=$E(PAIR),TO=$E(PAIR,2)
 . S X=Y,Y=$P(X,FROM) F I=2:1:$L(X,FROM) S Y=Y_"\"_TO_$P(X,FROM,I)
 Q Y
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 D ERRX^VPRJSON(ID,$G(VAL))
 Q

VPRJT^INT^1^62766,49151.44728^0
VPRJT ;SLC/KCM -- Unit test driver
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;with acknowlegements to XTMUNIT, Imitation is the sincerest form of flattery
 ;
1 ; Run one specific test
 D EN("VPRJTR") ;
 ; D EN("VPRJTQF") ;"VPRJTJE,VPRJTJD,VPRJTQU,VPRJTU")
 Q
ALL ; Run all the tests
 ;D EN("VPRJTJE,VPRJTJD")
 D EN("VPRJTJE,VPRJTJD,VPRJTU,VPRJTS,VPRJTQU,VPRJTQF,VPRJTQX,VPRJTR,VPRJTRP,VPRJTD0,VPRJTD1,VPRJTD2")
 Q
EN(ZZRSET) ; Run tests for set of routines passed in
 N ZZFAILED,ZZROU,ZZPIECE
 F ZZPIECE=1:1:$L(ZZRSET,",") D TEST($P(ZZRSET,",",ZZPIECE))
 W !,$S($G(ZZFAILED):"Tests FAILED",1:"Tests PASSED")
 Q
TEST(ZZROU) ; Run tests in a specific routine
 W !!,">> "_ZZROU,?10,$P($T(@(ZZROU_"^"_ZZROU)),"--",2,99)
 N ZZI,ZZK,ZZX,ZZLABEL,ZZCODE,ZZCMT,ZZSET,ZZTEAR
 S ZZK=$T(@("STARTUP^"_ZZROU)) I $L(ZZK) D @("STARTUP^"_ZZROU)
 ;
 F ZZI=1:1 S ZZX=$T(@("+"_ZZI_"^"_ZZROU)) Q:ZZX=""  D
 . S ZZLABEL=$P(ZZX," "),ZZCODE=$$LTRIM($P(ZZX," ",2,99))
 . I $L(ZZLABEL),($E(ZZCODE,1,2)=";;"),($$UP($E(ZZCODE,1,9))["@TEST") D
 . . S ZZCMT=$E($P(ZZCODE,"@",2,99),5,$L(ZZCODE))
 . . W !,"Testing"_ZZCMT_" ["_ZZLABEL_"^"_ZZROU_"]"
 . . S ZZK=$T(@("SETUP^"_ZZROU)) I $L(ZZK) D @("SETUP^"_ZZROU)
 . . D @(ZZLABEL_"^"_ZZROU) ; run the unit test
 . . S ZZK=$T(@("TEARDOWN^"_ZZROU)) I $L(ZZK) D @("TEARDOWN^"_ZZROU)
 ;
 S ZZK=$T(@("SHUTDOWN^"_ZZROU)) I $L(ZZK) D @("SHUTDOWN^"_ZZROU)
 Q
EQ(EXPECT,ACTUAL,MSG) ;
 I EXPECT=ACTUAL W "." Q
 S ZZFAILED=1
 W:$X>1 ! W "expected: ",EXPECT,"  actual: ",ACTUAL,"  ",$G(MSG),!
 Q
NE(EXPECT,ACTUAL,MSG) ;
 I EXPECT'=ACTUAL W "." Q
 S ZZFAILED=1
 W:$X>1 ! W "not equal failed, value: ",ACTUAL,"  ",$G(MSG),!
 Q
UP(X) ; return uppercase for X
 Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 ;
LTRIM(X) ; remove spaces from left side
 N POS F POS=1:1:$L(X) Q:$E(X,POS)'=" "
 Q $E(X,POS,$L(X))

VPRJTD0^INT^1^62766,48612.681561^0
VPRJTD0 ;SLC/KCM -- Unit tests for saving objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N DATA
 D DELCTN^VPRJD("test")  ; clear the collections
 D SETUP^VPRJDMD
 Q
SHUTDOWN ; Run once after all tests
 D DELCTN^VPRJD("test")
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
ASSERT(EXPECT,ACTUAL,MSG) ; for convenience
 D EQ^VPRJT(EXPECT,ACTUAL,$G(MSG))
 Q
 ;
GETDATA(TAG,DATA) ;
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^VPRJTDD),";;",2,999) Q:X="zzzzz"  S DATA(I)=X
 Q
ADDOBJ ;; @TEST adding an object
 N DATA,LOC
 D GETDATA("TEST1",.DATA)
 S LOC=$$SAVE^VPRJD(.DATA)
 D ASSERT(10,$D(^VPRJD("urn:va:test:1")))
 D ASSERT("blue",^VPRJD("urn:va:test:1","color"))
 D ASSERT(1,$D(^VPRJD("JSON","urn:va:test:1",1)))
 ;D ASSERT(19350407,+$P(^VPRPT("TEMPLATE",VPRJTPID,"urn:va:F484:-7:pat:-7","summary",1),":",2))
 Q
CHKIDX ;; @TEST indexes that were built after adding object
 D ASSERT(1,$D(^VPRJDX("attr","test-name","alpha ","798789799542=","urn:va:test:1",0)))
 D ASSERT(1,^VPRJDX("tally","test-name-count","alpha"))
 D ASSERT(1,^VPRJDX("count","collection","test"))
 Q
GETOBJ ;; @TEST getting an object
 D QKEY^VPRJDQ("urn:va:test:1")
 D ASSERT(1,$D(^TMP($J,"data",0,"urn:va:test:1",0)))
 D ASSERT(1,$G(^TMP($J,"total")))
 Q
DELOBJ ;; @TEST deletion of object
 D DELETE^VPRJD("urn:va:test:1")
 D ASSERT(0,$D(^VPRJD("urn:va:test:1")))
 D ASSERT(0,$D(^VPRJD("JSON","urn:va:test:1")))
 D ASSERT(0,$D(^VPRJDX("attr","test-name","alpha")))
 D ASSERT(0,$G(^VPRJDX("count","collection","test")))
 Q
 ;
BUILD ;; Builds a set of test objects for interactive testing
 ; should delete the object collection when done
 F I=1:1:6 D GETDATA("TEST"_I,.DATA) S LOC=$$SAVE^VPRJD(.DATA) K DATA
 Q
DELBUILD ; Deletes the collection that was built
 D DELCTN^VPRJD("test")
 Q

VPRJTD1^INT^1^62781,63707.121381^0
VPRJTD1 ;SLC/KCM -- Unit tests for RESTful queries
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N DATA,I,LOC
 D DELCTN^VPRJD("test")  ; clear the collections
 D DELCTN^VPRJD("testb")
 D SETUP^VPRJDMD
 F I=1:1:6 D GETDATA("TEST"_I,.DATA) S LOC=$$SAVE^VPRJD(.DATA) K DATA
 Q
SHUTDOWN ; Run once after all tests
 D DELCTN^VPRJD("test")
 D DELCTN^VPRJD("testb")
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
GETDATA(TAG,DATA) ;
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^VPRJTDD),";;",2,999) Q:X="zzzzz"  S DATA(I)=X
 Q
DATA2ARY(ARY) ; call SENDATA to write out response and read back into ARY
 ; cause TCP data to be written to file
 D WR4HTTP^VPRJRUT
 D SENDATA^VPRJRSP
 D C4HTTP^VPRJRUT
 ;
 ; read TCP data from file into variable and delete file
 N X,ERR
 S X=$$RD4HTTP^VPRJRUT
 D DECODE^VPRJSON("X","ARY","ERR")
 D ASSERT(0,$D(ERR))
 Q
SETGET(URL) ; set up a request (to emulate HTTP call)
 S HTTPREQ("method")="GET"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
SETPUT(URL,SRC) ; set up a PUT request
 N DATA
 S HTTPREQ("method")="PUT"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 D GETDATA(SRC,.DATA)
 M HTTPREQ("body")=DATA
 Q
SETDEL(URL) ; set up a delete request
 S HTTPREQ("method")="DELETE"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
 ;
INDEX ;; @TEST query using an index
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/data/index/test-name?range=alpha..delta")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(4,JSON("data","totalItems"))
 D ASSERT(201110201857,JSON("data","items",4,"updated")) ; sorted reverse updated date
 Q
LAST ;; @TEST query for last instance of items in list
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/data/last/test-name?range=alpha..delta")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(3,JSON("data","totalItems"))
 D ASSERT("urn:va:test:6",JSON("data","items",1,"uid"))
 Q
ORDASC ;; @TEST query to return in different order
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/data/index/test-name?order=name asc")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT("gamma",JSON("data","items",6,"name"))
 Q
ORDDESC ;; @TEST query to return in different order
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/data/index/test-name?order=name DESC")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT("gamma",JSON("data","items",1,"name"))
 Q
FILTER ;; @TEST filter to return based on criteria
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/data/index/test-name?filter=eq(""color"",""orange"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(2,JSON("data","totalItems"))
 D ASSERT("epsilon",JSON("data","items",1,"name"))
 Q
GETUID ;; @TEST getting an object by UID only
 N JSON,ERR,HTTPERR
 D SETGET("/data/urn:va:test:5")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT("epsilon",JSON("data","items",1,"name"))
 Q
GETNONE ;; @TEST getting an object that does not exist
 N JSON,ERR,HTTPERR
 D SETGET("/data/urn:test:bogus:54321")
 D RESPOND^VPRJRSP
 D ASSERT(1,$D(HTTPERR)>0)
 D ASSERT(404,$G(^TMP("HTTPERR",$J,1,"error","code")))
 K ^TMP("HTTPERR",$J)
 Q
EVERY ;; TEST retrieving every object in a collection
 N JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/every")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(6,JSON("data","totalItems"))
 D ASSERT(0,$D(^TMP($J,$J)))
 D ASSERT(10,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"))))
 D ASSERT(0,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"),$J)))
 K JSON
 D SETGET("/vpr/"_VPRJTPID_"/index/every?start=3&limit=3")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(3,JSON("data","currentItemCount"))
 D ASSERT(10,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"))))
 D ASSERT(0,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"),$J)))
 Q
FINDALL ;; @TEST finding every object in collection
 N JSON,ERR,HTTPERR
 D SETGET("/data/find/test")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(6,JSON("data","totalItems"))
 Q
FINDPAR ;; @TEST finding with parameters
 N JSON,ERR,HTTPERR
 D SETGET("/data/find/test?filter=eq(""color"",""orange"")&order=name")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(2,JSON("data","totalItems"))
 D ASSERT("urn:va:test:5",JSON("data","items",1,"uid"))
 Q 
ADDOBJ ;; @TEST adding object to store
 N HTTPERR
 D SETPUT("/data","TEST7")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("/data/urn:va:test:7",HTTPREQ("location"))
 D ASSERT(10,$D(^VPRJD("urn:va:test:7")))
 D ASSERT(7,$G(^VPRJDX("count","collection","test")))
 D ASSERT(1,$D(^VPRJDX("attr","test-name","omega ","798789768244=","urn:va:test:7",0)))
 Q
DELOBJ ;; @TEST remove object from store
 N HTTPERR
 D SETDEL("/data/urn:va:test:7")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(0,$D(^VPRJD("urn:va:test:7")))
 D ASSERT(6,$G(^VPRJDX("count","collection","test")))
 D ASSERT(0,$D(^VPRJDX("attr","test-name","omega ","798789768244=","urn:va:test:7",0)))
 Q
 ;
NEWOBJ ;; @TEST add a new object, returning a new UID
 N HTTPERR,LASTID
 S LASTID=$G(^VPRJD("COLLECTION","testb"))
 D SETPUT("/data/testb","NOUID1")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("/data/urn:va:testb:"_$G(^VPRJMETA("system"))_":"_(LASTID+1),HTTPREQ("location"))
 D SETPUT("/data/testb","NOUID2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("/data/urn:va:testb:"_$G(^VPRJMETA("system"))_":"_(LASTID+2),HTTPREQ("location"))
 D SETPUT("/data/testb","HASUID")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("/data/urn:va:testb:42",HTTPREQ("location"))
 Q
DELCTN ;; @TEST delete collection
 N HTTPERR
 D SETPUT("/data","OTHER") ; add something from another collection
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(4,$G(^VPRJDX("count","collection","testb")))
 D ASSERT(6,$G(^VPRJDX("count","collection","test")))
 D SETDEL("/data/collection/test")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(4,$G(^VPRJDX("count","collection","testb")))
 D ASSERT(10,$D(^VPRJD("urn:va:testb:29")))
 D ASSERT(0,$D(^VPRJDX("count","collection","test")))
 Q
1 ; run just one test
 D STARTUP,SETUP,GETNONE,TEARDOWN,SHUTDOWN
 Q

VPRJTD2^INT^1^62756,62812.973667^0
VPRJTD2 ;SLC/KCM -- Unit tests for management tools
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N DATA,I,LOC
 D DELCTN^VPRJD("test")  ; clear the collections
 D DELCTN^VPRJD("testb")
 D SETUP^VPRJDMD
 F I=1:1:6 D GETDATA("TEST"_I,.DATA) S LOC=$$SAVE^VPRJD(.DATA) K DATA
 D GETDATA("OTHER",.DATA) S LOC=$$SAVE^VPRJD(.DATA) K DATA
 Q
SHUTDOWN ; Run once after all tests
 D DELCTN^VPRJD("test")
 D DELCTN^VPRJD("testb")
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
GETDATA(TAG,DATA) ;
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^VPRJTDD),";;",2,999) Q:X="zzzzz"  S DATA(I)=X
 Q
 ;
OBJCTN ;; @TEST count objects in collection
 N COUNT
 S COUNT=$$OBJCTN^VPRJDM("test")
 D ASSERT(6,COUNT)
 Q

VPRJTDD^INT^1^62756,62812.977744^0
VPRJTDD ;SLC/KCM -- Unit test data save and query
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
DATA   ; Sample data
TEST1 ;;
 ;;{"name":"alpha","updated":"201210200457","color":"blue","uid":"urn:va:test:1"}
 ;;zzzzz
TEST2 ;;
 ;;{"name":"beta","updated": "201110201857","color":"red","uid":"urn:va:test:2"}
 ;;zzzzz
TEST3 ;;
 ;;{"name":"gamma","updated":"201110210831","color":"orange","uid":"urn:va:test:3"}
 ;;zzzzz
TEST4 ;;
 ;;{"name":"delta","updated":"201210211922","color":"green","uid":"urn:va:test:4"}
 ;;zzzzz
TEST5 ;;
 ;;{"name":"epsilon","updated":"201210220722","color":"orange","uid":"urn:va:test:5"}
 ;;zzzzz
TEST6 ;;
 ;;{"name":"delta","updated":"201210221922","color":"purple","uid":"urn:va:test:6"}
 ;;zzzzz
TEST7 ;;
 ;;{"name":"omega","updated":"201210231755","color":"yellow","uid":"urn:va:test:7"}
 ;;zzzzz
OTHER ;;
 ;;{"name":"different item","updated":"201010231755","color":"white","uid":"urn:va:testb:29"}
 ;;zzzzz
NOUID1 ;;
 ;;{"name":"newItem1","updated":"201010241755","color":"white","fruit":"pomegranite"}
 ;;zzzzz
NOUID2 ;;
 ;;{"name":"newItem2","updated":"201110251622","color":"red","fruit":"apple"}
 ;;zzzzz
HASUID ;;
 ;;{"name":"newItem3","updated":"201210261342","color":"brown","fruit":"banana","uid":"urn:va:testb:42"}
 ;;zzzzz
 ;

VPRJTJD^INT^1^62756,62812.983563^0
VPRJTJD ;SLC/KCM -- Unit tests for JSON decoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
JSONUES ;; @TEST unescape JSON encoded string
 N X
 S X=$$UES^VPRJSON("String with \\ in the middle")
 D ASSERT("String with \ in the middle",X)
 S X=$$UES^VPRJSON("\\ is the first character of this string")
 D ASSERT("\ is the first character of this string",X)
 S X=$$UES^VPRJSON("The last character of this string is \\")
 D ASSERT("The last character of this string is \",X)
 S X=$$UES^VPRJSON("\\one\\two\\three\\")
 D ASSERT("\one\two\three\",X)
 S X=$$UES^VPRJSON("A vee shape: \\\/\tTABBED\tand line endings.\n\r\f")
 D ASSERT("A vee shape: \/"_$C(9)_"TABBED"_$C(9)_"and line endings."_$C(10,13,12),X)
 S X=$$UES^VPRJSON("\""This text is quoted\""")
 D ASSERT("""This text is quoted""",X)
 Q
SPLITA ;; @TEST JSON input with escaped characters on single line
 N JSON,Y,ERR,ESC
 S ESC="this string contains \and other escaped characters such as "_$c(10)
 S ESC=ESC_"  and a few tabs "_$c(9,9,9,9)_" and a piece of ""quoted text"""
 D BUILD("SPLIT",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(ESC,$G(Y("esc")))
 D ASSERT("this is a new line",$G(Y("next")))
 D ASSERT("this is a string that goes across two lines",$G(Y("wp")))
 D ASSERT("here is another string",$G(Y("nextLineQuote")))
 Q
SPLITB ;; @TEST multiple line JSON input with lines split across tokens
 N JSON,Y,ERR,ESC
 S ESC="this string contains \and other escaped characters such as "_$c(10)
 S ESC=ESC_"  and a few tabs "_$c(9,9,9,9)_" and a piece of ""quoted text"""
 D BUILDA("SPLIT",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(ESC,$G(Y("esc")))
 D ASSERT("this is a new line",$G(Y("next")))
 D ASSERT("this is a string that goes across two lines",$G(Y("wp")))
 D ASSERT("here is another string",$G(Y("nextLineQuote")))
 Q
LONG ;; @TEST long document that must be saved across extension nodes
 N JSON,Y,ERR,I,LINE
 S JSON(1)="{""title"":""long document"",""size"":""rather large"",""document"":"""
 S LINE="This is a line of text intended to test longer documents.\r\n  It will be repeated so that there are several nodes that must be longer than 4000 kilobytes."
 F I=2:1:100 S JSON(I)=LINE
 S JSON(101)=""",""author"":""WINDED,LONG""}"
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(3978,$L(Y("document")))
 D ASSERT(3213,$L(Y("document","\",3)))
 D ASSERT(0,$D(Y("document",4)))
 D ASSERT("WINDED,LONG",Y("author"))
 D ASSERT("rather large",Y("size"))
 Q
FRAC ;; @TEST multiple lines with fractional array elements
 ;; {"title":"my array of stuff", "count":3, "items": [
 ;; {"name":"red", "rating":"ok"},
 ;; {"name":"blue", "rating":"good"},
 ;; {"name":"purple", "rating":"outstanding"}
 ;; ]}
 N JSON,Y,ERR
 S JSON(0)=$P($T(FRAC+1),";;",2,99)
 S JSON(.5)=$P($T(FRAC+2),";;",2,99)
 S JSON(1)=$P($T(FRAC+3),";;",2,99)
 S JSON(1.1)=$P($T(FRAC+4),";;",2,99)
 S JSON(1.2)=$P($T(FRAC+5),";;",2,99)
 S JSON("JUNK")="Junk non-numeric node -- this should be ignored"
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("purple",Y("items",3,"name"))
 Q
VALONLY ;; @TEST passing in value only -- not array
 N JSON,Y,ERR
 S JSON=$P($T(VALONLY+1^VPRJTJDD),";;",2,999)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("urn:va:param:F484:1120:VPR USER PREF:1120",Y("uid"))
 D ASSERT("north",Y("vals","cpe.patientpicker.loc"))
 Q
NUMERIC ;; @TEST passing in numeric types and strings
 N JSON,Y,ERR
 S JSON=$P($T(NUMERIC+1^VPRJTJDD),";;",2,999)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(234567,+Y("count")) ; make sure it's numeric
 D ASSERT(20120919,Y("hl7Time"))
 D ASSERT(1,$D(Y("hl7Time","\s")))
 D ASSERT("722.10",Y("icd"))
 D ASSERT(0,+Y("icd")="722.10") ; make sure it's a string
 Q
BADQUOTE ;; @TEST poorly formed JSON (missing close quote on LABEL)
 N JSON,Y,ERR
 D BUILD("BADQUOTE",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
BADSLASH ;; @TEST poorly formed JSON (non-escaped backslash)
 N JSON,Y,ERR
 D BUILD("BADSLASH",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
SAM1 ;; @TEST decode sample 1 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM1",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("file",$G(Y("menu","id")))
 D ASSERT("OpenDoc()",$G(Y("menu","popup","menuitem",2,"onclick")))
 Q
SAM2 ;; @TEST decode sample 2 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM2",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("XML",$G(Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",2)))
 D ASSERT("SGML",$G(Y("glossary","GlossDiv","GlossList","GlossEntry","SortAs")))
 Q
SAM3 ;; @TEST decode sample 3 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM3",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(500,$G(Y("widget","window","width")))
 D ASSERT("sun1.opacity = (sun1.opacity / 100) * 90;",$G(Y("widget","text","onMouseUp")))
 D ASSERT("Sample Konfabulator Widget",$G(Y("widget","window","title")))
 Q
SAM4 ;; @TEST decode sample 4 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM4",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(Y("web-app","servlet",6)))  ; should only be 5 servlets
 D ASSERT(1,$G(Y("web-app","servlet",5,"init-param","log")))
 D ASSERT("/usr/local/tomcat/logs/CofaxTools.log",$G(Y("web-app","servlet",5,"init-param","logLocation")))
 D ASSERT("/",$G(Y("web-app","servlet-mapping","cofaxCDS")))
 D ASSERT("/WEB-INF/tlds/cofax.tld",$G(Y("web-app","taglib","taglib-location")))
 Q
SAM5 ;; @TEST decode sample 5 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM5",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(Y("menu","items",23)))  ; should only be 22 items
 D ASSERT("About Adobe CVG Viewer...",$G(Y("menu","items",22,"label")))
 D ASSERT("null",$G(Y("menu","items",3)))
 Q
 ;
BUILD(TAG,JSON) ; Build array of strings in JSON for TAG
 N X,I,LINE
 S LINE=1,JSON(LINE)=""
 F I=1:1 S X=$E($T(@TAG+I^VPRJTJDD),4,999) Q:X="#####"  D
 . I $L(JSON(LINE))+$L(X)>4000 S LINE=LINE+1,JSON(LINE)=""
 . S JSON(LINE)=JSON(LINE)_X
 Q
BUILDA(TAG,JSON) ; Build array of string in JSON with splits preserved
 N X,I
 F I=1:1 S X=$E($T(@TAG+I^VPRJTJDD),4,999) Q:X="#####"  S JSON(I)=X
 Q

VPRJTJDD^INT^1^62756,62812.991088^0
VPRJTJDD ;SLC/KCM -- Unit test data for JSON decoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;
 ; --- Data for multi-line tests
 ;
SPLIT ;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc": "this string contains \\
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
VALONLY ;
 ;;{"uid":"urn:va:param:F484:1120:VPR USER PREF:1120","entity":"USR","entityId":"1120","param":"VPR USER PREF","instance":"1120","vals":{"ext.libver":"/lib/ext-4.0.7/ext-all-dev.js","cpe.patientpicker.loc":"north"}}
 ;
NUMERIC ;
 ;;{"name":"Duck,Donald","hl7Time":"20120919","count":234567,"icd":"722.10"}
BADQUOTE ;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc: "this string contains \\
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
BADSLASH ;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc": "this string contains \
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
 ; --- SAMPLE JSON strings
 ;
SAM1 ;
 ;;{"menu":{"id":"file","popup":{"menuitem":[{"value": "New","onclick":"CreateNewDoc()"},
 ;;{"value": "Open","onclick": "OpenDoc()"},{"value": "Close","onclick": "CloseDoc()"}]} ,
 ;;"value":"File"}}
 ;;#####
 ;
SAM2 ;
 ;;    {
 ;;        "glossary": {
 ;;            "title": "example glossary",
 ;;            "GlossDiv": {
 ;;                "title": "S",
 ;;                "GlossList": {
 ;;                    "GlossEntry": {
 ;;                        "ID": "SGML",
 ;;                        "SortAs": "SGML",
 ;;                        "GlossTerm": "Standard Generalized Markup Language",
 ;;                        "Acronym": "SGML",
 ;;                        "Abbrev": "ISO 8879:1986",
 ;;                        "GlossDef": {
 ;;                            "para": "A meta-markup language, used to create markup languages such as DocBook.",
 ;;                            "GlossSeeAlso": ["GML", "XML"]
 ;;                        },
 ;;                        "GlossSee": "markup"
 ;;                    }
 ;;                }
 ;;            }
 ;;        }
 ;;    }
 ;;#####
 ;    
SAM3 ;
 ;;    {"widget": {
 ;;        "debug": "on",
 ;;        "window": {
 ;;            "title": "Sample Konfabulator Widget",
 ;;            "name": "main_window",
 ;;            "width": 500,
 ;;            "height": 500
 ;;        },
 ;;        "image": { 
 ;;            "src": "Images/Sun.png",
 ;;            "name": "sun1",
 ;;            "hOffset": 250,
 ;;            "vOffset": 250,
 ;;            "alignment": "center"
 ;;        },
 ;;        "text": {
 ;;            "data": "Click Here",
 ;;            "size": 36,
 ;;            "style": "bold",
 ;;            "name": "text1",
 ;;            "hOffset": 250,
 ;;            "vOffset": 100,
 ;;            "alignment": "center",
 ;;            "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"
 ;;        }
 ;;    }}    
 ;;#####
 ;
SAM4 ;    
 ;;    {"web-app": {
 ;;      "servlet": [   
 ;;        {
 ;;          "servlet-name": "cofaxCDS",
 ;;          "servlet-class": "org.cofax.cds.CDSServlet",
 ;;          "init-param": {
 ;;            "configGlossary:installationAt": "Philadelphia, PA",
 ;;            "configGlossary:adminEmail": "ksm@pobox.com",
 ;;            "configGlossary:poweredBy": "Cofax",
 ;;            "configGlossary:poweredByIcon": "/images/cofax.gif",
 ;;            "configGlossary:staticPath": "/content/static",
 ;;            "templateProcessorClass": "org.cofax.WysiwygTemplate",
 ;;            "templateLoaderClass": "org.cofax.FilesTemplateLoader",
 ;;            "templatePath": "templates",
 ;;            "templateOverridePath": "",
 ;;            "defaultListTemplate": "listTemplate.htm",
 ;;            "defaultFileTemplate": "articleTemplate.htm",
 ;;            "useJSP": false,
 ;;            "jspListTemplate": "listTemplate.jsp",
 ;;            "jspFileTemplate": "articleTemplate.jsp",
 ;;            "cachePackageTagsTrack": 200,
 ;;            "cachePackageTagsStore": 200,
 ;;            "cachePackageTagsRefresh": 60,
 ;;            "cacheTemplatesTrack": 100,
 ;;            "cacheTemplatesStore": 50,
 ;;            "cacheTemplatesRefresh": 15,
 ;;            "cachePagesTrack": 200,
 ;;            "cachePagesStore": 100,
 ;;            "cachePagesRefresh": 10,
 ;;            "cachePagesDirtyRead": 10,
 ;;            "searchEngineListTemplate": "forSearchEnginesList.htm",
 ;;            "searchEngineFileTemplate": "forSearchEngines.htm",
 ;;            "searchEngineRobotsDb": "WEB-INF/robots.db",
 ;;            "useDataStore": true,
 ;;            "dataStoreClass": "org.cofax.SqlDataStore",
 ;;            "redirectionClass": "org.cofax.SqlRedirection",
 ;;            "dataStoreName": "cofax",
 ;;            "dataStoreDriver": "com.microsoft.jdbc.sqlserver.SQLServerDriver",
 ;;            "dataStoreUrl": "jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon",
 ;;            "dataStoreUser": "sa",
 ;;            "dataStorePassword": "dataStoreTestQuery",
 ;;            "dataStoreTestQuery": "SET NOCOUNT ON;select test='test';",
 ;;            "dataStoreLogFile": "/usr/local/tomcat/logs/datastore.log",
 ;;            "dataStoreInitConns": 10,
 ;;            "dataStoreMaxConns": 100,
 ;;            "dataStoreConnUsageLimit": 100,
 ;;            "dataStoreLogLevel": "debug",
 ;;            "maxUrlLength": 500}},
 ;;        {
 ;;          "servlet-name": "cofaxEmail",
 ;;          "servlet-class": "org.cofax.cds.EmailServlet",
 ;;          "init-param": {
 ;;          "mailHost": "mail1",
 ;;          "mailHostOverride": "mail2"}},
 ;;        {
 ;;          "servlet-name": "cofaxAdmin",
 ;;          "servlet-class": "org.cofax.cds.AdminServlet"},
 ;;     
 ;;        {
 ;;          "servlet-name": "fileServlet",
 ;;          "servlet-class": "org.cofax.cds.FileServlet"},
 ;;        {
 ;;          "servlet-name": "cofaxTools",
 ;;          "servlet-class": "org.cofax.cms.CofaxToolsServlet",
 ;;          "init-param": {
 ;;            "templatePath": "toolstemplates/",
 ;;            "log": 1,
 ;;            "logLocation": "/usr/local/tomcat/logs/CofaxTools.log",
 ;;            "logMaxSize": "",
 ;;            "dataLog": 1,
 ;;            "dataLogLocation": "/usr/local/tomcat/logs/dataLog.log",
 ;;            "dataLogMaxSize": "",
 ;;            "removePageCache": "/content/admin/remove?cache=pages&id=",
 ;;            "removeTemplateCache": "/content/admin/remove?cache=templates&id=",
 ;;            "fileTransferFolder": "/usr/local/tomcat/webapps/content/fileTransferFolder",
 ;;            "lookInContext": 1,
 ;;            "adminGroupID": 4,
 ;;            "betaServer": true}}],
 ;;      "servlet-mapping": {
 ;;        "cofaxCDS": "/",
 ;;        "cofaxEmail": "/cofaxutil/aemail/*",
 ;;        "cofaxAdmin": "/admin/*",
 ;;        "fileServlet": "/static/*",
 ;;        "cofaxTools": "/tools/*"},
 ;;     
 ;;      "taglib": {
 ;;        "taglib-uri": "cofax.tld",
 ;;        "taglib-location": "/WEB-INF/tlds/cofax.tld"}}}
 ;;#####
 ;
SAM5 ;    
 ;;    {"menu": {
 ;;        "header": "SVG Viewer",
 ;;        "items": [
 ;;            {"id": "Open"},
 ;;            {"id": "OpenNew", "label": "Open New"},
 ;;            null,
 ;;            {"id": "ZoomIn", "label": "Zoom In"},
 ;;            {"id": "ZoomOut", "label": "Zoom Out"},
 ;;            {"id": "OriginalView", "label": "Original View"},
 ;;            null,
 ;;            {"id": "Quality"},
 ;;            {"id": "Pause"},
 ;;            {"id": "Mute"},
 ;;            null,
 ;;            {"id": "Find", "label": "Find..."},
 ;;            {"id": "FindAgain", "label": "Find Again"},
 ;;            {"id": "Copy"},
 ;;            {"id": "CopyAgain", "label": "Copy Again"},
 ;;            {"id": "CopySVG", "label": "Copy SVG"},
 ;;            {"id": "ViewSVG", "label": "View SVG"},
 ;;            {"id": "ViewSource", "label": "View Source"},
 ;;            {"id": "SaveAs", "label": "Save As"},
 ;;            null,
 ;;            {"id": "Help"},
 ;;            {"id": "About", "label": "About Adobe CVG Viewer..."}
 ;;        ]
 ;;    }}
 ;;#####

VPRJTJE^INT^1^62756,62812.99738^0
VPRJTJE ;SLC/KCM -- Unit tests for JSON encoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
JSONESC ;; @TEST create JSON escaped string
 N X
 S X=$$ESC^VPRJSON("String with \ in the middle")
 D ASSERT("String with \\ in the middle",X)
 S X=$$ESC^VPRJSON("\ is the first character of this string")
 D ASSERT("\\ is the first character of this string",X)
 S X=$$ESC^VPRJSON("The last character of this string is \")
 D ASSERT("The last character of this string is \\",X)
 S X=$$ESC^VPRJSON("\one\two\three\")
 D ASSERT("\\one\\two\\three\\",X)
 S X=$$ESC^VPRJSON("A vee shape: \/"_$C(9)_"TABBED"_$C(9)_"and line endings."_$C(10,13,12))
 D ASSERT("A vee shape: \\\/\tTABBED\tand line endings.\n\r\f",X)
 S X=$$ESC^VPRJSON("""This text is quoted""")
 D ASSERT("\""This text is quoted\""",X)
 Q
BASIC ;; @TEST encode basic object as JSON
 N X,JSON
 S X("myObj","booleanT")="true"
 S X("myObj","booleanF")="false"
 S X("myObj","numeric")=3.1416
 S X("myObj","nullValue")="null"
 S X("myObj","array",1)="one"
 S X("myObj","array",2)="two"
 S X("myObj","array",3)="three"
 S X("myObj","subObject","fieldA")="hello"
 S X("myObj","subObject","fieldB")="world"
 D ENCODE^VPRJSON("X","JSON")
 D ASSERT($$TARGET("BASIC"),JSON(1))
 Q
VALS ;; @TEST encode simple values only object as JSON
 N X,JSON
 S X("prop1")="property1"
 S X("bool1")="true"
 S X("num1")="2.1e3"
 S X("arr",1)="apple"
 S X("arr",2)="orange"
 S X("arr",3)="pear"
 S X("arr",4,"obj")="4th array item is object"
 D ENCODE^VPRJSON("X","JSON")
 D ASSERT($$TARGET("VALS"),JSON(1))
 Q
LONG ;; @TEST encode object with continuation nodes for value
 N X,I,JSON,FILLER,TARGET
 S FILLER=", this will extend the line out to at least 78 characters."_$C(10)
 S X("title")="My note test title"
 S X("note")="This is the first line of the note.  Here are ""quotes"" and a \ and a /."_$C(10)
 F I=1:1:60 S X("note","\",I)="Additional Line #"_I_FILLER
 D ENCODE^VPRJSON("X","JSON")
 S TARGET=$$TARGET("LONG")
 D ASSERT(TARGET,$E(JSON(1),1,$L(TARGET)))
 D ASSERT(1,$D(JSON(2)))
 D ASSERT(0,$D(JSON(3)))
 S TARGET="s.\n"",""title"":""My note test title""}"
 D ASSERT(TARGET,$E(JSON(2),$L(JSON(2))-$L(TARGET)+1,$L(JSON(2))))
 Q
PRE ;; @TEST encode object where parts are already JSON encoded
 N X,JSON,TARGET
 S X("count")=3
 S X("menu",1,":",1)=$$TARGET("NODES",1)
 S X("menu",2,":",1)=$$TARGET("NODES",2)
 S X("menu",3,":",1)=$$TARGET("NODES",3)
 S X("template",":")=$$TARGET("NODES",4)
 D ENCODE^VPRJSON("X","JSON")
 S TARGET=$$TARGET("PRE",1)_$$TARGET("PRE",2)
 D ASSERT(TARGET,JSON(1))
 Q
WP ;; @TEST word processing nodes inside object
 N Y,JSON,TARGET
 D BUILDY("WP")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("WPOUT")_$$TARGET("WPOUT",2)_$$TARGET("WPOUT",3)
 D ASSERT(TARGET,JSON(1))
 Q
LTZERO ;; @TEST leading / trailing zeros get preserved
 N Y,JSON,TARGET
 S Y("count")=737
 S Y("ssn")="000427930"
 S Y("icd")="626.00"
 S Y("price")=".65"
 S Y("errors")=0
 D ENCODE^VPRJSON("Y","JSON")
 D ASSERT($$TARGET("LTZERO"),JSON(1))
 ;W !,"Y ---",! ZW Y W !,"JSON ---",! W JSON(1)
 Q
STRINGS ;; @TEST force encoding as string
 N Y,JSON,TARGET,ERR
 S Y("count")=234567
 S Y("hl7Time")="20120919"
 S Y("hl7Time","\s")=""
 S Y("icd")="722.10"
 S Y("name")="Duck,Donald"
 D ENCODE^VPRJSON("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT($$TARGET("STRINGS"),JSON(1))
 Q
EXAMPLE ;; @TEST encode samples that are on JSON.ORG
 N Y,JSON,TARGET
 D BUILDY("EX1IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX1OUT")
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX2IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX2OUT")_$$TARGET("EX2OUT",2)
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX3IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX3OUT")_$$TARGET("EX3OUT",2)
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX4IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX4OUT")
 D ASSERT(TARGET,$E(JSON(1),1,215))
 D ASSERT(2758,$L(JSON(1)))
 Q
BUILDY(LABEL) ; build Y array based on LABEL
 ; expects Y from EXAMPLE
 N I,X
 K Y
 F I=1:1 S X=$P($T(@LABEL+I^VPRJTJED),";;",2,999) Q:X="zzzzz"  X "S "_X
 Q
TARGET(ID,OFFSET) ; values to test against
 S OFFSET=$G(OFFSET,1)
 Q $P($T(@ID+OFFSET^VPRJTJED),";;",2,999)

VPRJTJED^INT^1^62756,62813.00418^0
VPRJTJED ;SLC/KCM -- Data for JSON encoding unit tests
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;
 ; expected return data values
 ;
BASIC ;; Basic object 
 ;;{"myObj":{"array":["one","two","three"],"booleanF":false,"booleanT":true,"nullValue":null,"numeric":3.1416,"subObject":{"fieldA":"hello","fieldB":"world"}}}
VALS ;; Simple values only object
 ;;{"arr":["apple","orange","pear",{"obj":"4th array item is object"}],"bool1":true,"num1":2.1e3,"prop1":"property1"}
LONG ;; Object with continuation nodes
 ;;{"note":"This is the first line of the note.  Here are \"quotes\" and a \\ and a \/.\nAdditional Line #1, this will extend the line out to at least 78 characters.\nAdditional Line #2,
NODES ;; Nodes preformatted as JSON
 ;;{"value": "New", "onclick": "CreateNewDoc()"}
 ;;{"value": "Open", "onclick": "OpenDoc()"}
 ;;{"value": "Close", "onclick": "CloseDoc()"}
 ;;{"data":"Click Here","size":36,"style":"bold","name":"text1","hOffset":250,"vOffset":100,"alignment":"center","onMouseUp":"sun1.opacity = (sun1.opacity / 100) * 90;"}
PRE ;; Adding already encoded values to object
 ;;{"count":3,"menu":[{"value": "New", "onclick": "CreateNewDoc()"},{"value": "Open", "onclick": "OpenDoc()"},{"value": "Close", "onclick": "CloseDoc()"}],"template":
 ;;{"data":"Click Here","size":36,"style":"bold","name":"text1","hOffset":250,"vOffset":100,"alignment":"center","onMouseUp":"sun1.opacity = (sun1.opacity / 100) * 90;"}}
WPOUT ;; WP field encoded as JSON
 ;;{"dob":"APR 7,1935","gender":"MALE","lastVitals":{"height":{"lastDone":"Aug 24, 2009","value":190},"weight":{"lastDone":"Jul 01, 2011","value":210}},"name":"AVIVAPATIENT,THIRTY","patDemDetails":{"text":"               COORDINATING
 ;; MASTER OF RECORD: ABILENE (CAA)\r\n Address: Any Street                    Temporary: NO TEMPORARY ADDRESS\r\n         Any Town,WV 99998-0071\r\n         \r\n  County: UNSPECIFIED                     From\/To: NOT APPLICABLE\r\n"},
 ;;"uid":"urn:va:patient:F484:8"}
LTZERO ;; Leading and trailing zeros
 ;;{"count":737,"errors":0,"icd":"626.00","price":".65","ssn":"000427930"}
STRINGS ;; strings that look like numbers
 ;;{"count":234567,"hl7Time":"20120919","icd":"722.10","name":"Duck,Donald"}
EX1OUT ;; JSON.org example #1 target
 ;;{"menu":{"id":"file","popup":{"menuitem":[{"onclick":"CreateNewDoc()","value":"New"},{"onclick":"OpenDoc()","value":"Open"},{"onclick":"CloseDoc()","value":"Close"}]},"value":"File"}}
EX2OUT ;; JSON.org example #2 target
 ;;{"glossary":{"GlossDiv":{"GlossList":{"GlossEntry":{"Abbrev":"ISO 8879:1986","Acronym":"SGML","GlossDef":{"GlossSeeAlso":["GML","XML"],"para":"A meta-markup language, used to create markup languages such as DocBook."}
 ;;,"GlossSee":"markup","GlossTerm":"Standard Generalized Markup Language","ID":"SGML","SortAs":"SGML"}},"title":"S"},"title":"example glossary"}}
EX3OUT ;; JSON.org example #3 target
 ;;{"widget":{"debug":"on","image":{"alignment":"center","hOffset":250,"name":"sun1","src":"Images\/Sun.png","vOffset":250},"text":{"alignment":"center","data":"Click Here","hOffset":250,"name":"text1","onMouseUp":
 ;;"sun1.opacity = (sun1.opacity \/ 100) * 90;","size":36,"style":"bold","vOffset":100},"window":{"height":500,"name":"main_window","title":"Sample Konfabulator Widget","width":500}}}
EX4OUT ;; JSON.org example #4 target
 ;;{"web-app":{"servlet":[{"init-param":{"cachePackageTagsRefresh":60,"cachePackageTagsStore":200,"cachePackageTagsTrack":200,"cachePagesDirtyRead":10,"cachePagesRefresh":10,"cachePagesStore":100,"cachePagesTrack":200,
 ;
 ; data values to test long text field input
 ;
WP ;; object with word processing field
 ;;Y("dob")="APR 7,1935"
 ;;Y("gender")="MALE"
 ;;Y("lastVitals","height","lastDone")="Aug 24, 2009"
 ;;Y("lastVitals","height","value")=190
 ;;Y("lastVitals","weight","lastDone")="Jul 01, 2011"
 ;;Y("lastVitals","weight","value")=210
 ;;Y("name")="AVIVAPATIENT,THIRTY"
 ;;Y("patDemDetails","text","\",6)="               COORDINATING MASTER OF RECORD: ABILENE (CAA)"_$C(13,10)
 ;;Y("patDemDetails","text","\",7)=" Address: Any Street                    Temporary: NO TEMPORARY ADDRESS"_$C(13,10)
 ;;Y("patDemDetails","text","\",8)="         Any Town,WV 99998-0071"_$C(13,10)
 ;;Y("patDemDetails","text","\",9)="         "_$C(13,10)
 ;;Y("patDemDetails","text","\",10)="  County: UNSPECIFIED                     From/To: NOT APPLICABLE"_$C(13,10)
 ;;Y("uid")="urn:va:patient:F484:8"
 ;;zzzzz
 ;
 ; data values for JSON.ORG examples rendered as M arrays
 ;
EX1IN ;; JSON.org example #1
 ;;Y("menu","id")="file"
 ;;Y("menu","popup","menuitem",1,"onclick")="CreateNewDoc()"
 ;;Y("menu","popup","menuitem",1,"value")="New"
 ;;Y("menu","popup","menuitem",2,"onclick")="OpenDoc()"
 ;;Y("menu","popup","menuitem",2,"value")="Open"
 ;;Y("menu","popup","menuitem",3,"onclick")="CloseDoc()"
 ;;Y("menu","popup","menuitem",3,"value")="Close"
 ;;Y("menu","value")="File"
 ;;zzzzz
EX2IN ;; JSON.org example #2
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","Abbrev")="ISO 8879:1986"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","Acronym")="SGML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",1)="GML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",2)="XML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","para")="A meta-markup language, used to create markup languages such as DocBook."
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossSee")="markup"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossTerm")="Standard Generalized Markup Language"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","ID")="SGML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","SortAs")="SGML"
 ;;Y("glossary","GlossDiv","title")="S"
 ;;Y("glossary","title")="example glossary"
 ;;zzzzz
EX3IN ;; JSON.org example #3
 ;;Y("widget","debug")="on"
 ;;Y("widget","image","alignment")="center"
 ;;Y("widget","image","hOffset")=250
 ;;Y("widget","image","name")="sun1"
 ;;Y("widget","image","src")="Images/Sun.png"
 ;;Y("widget","image","vOffset")=250
 ;;Y("widget","text","alignment")="center"
 ;;Y("widget","text","data")="Click Here"
 ;;Y("widget","text","hOffset")=250
 ;;Y("widget","text","name")="text1"
 ;;Y("widget","text","onMouseUp")="sun1.opacity = (sun1.opacity / 100) * 90;"
 ;;Y("widget","text","size")=36
 ;;Y("widget","text","style")="bold"
 ;;Y("widget","text","vOffset")=100
 ;;Y("widget","window","height")=500
 ;;Y("widget","window","name")="main_window"
 ;;Y("widget","window","title")="Sample Konfabulator Widget"
 ;;Y("widget","window","width")=500
 ;;zzzzz
EX4IN ;; JSON.org example #4
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsRefresh")=60
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsStore")=200
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsTrack")=200
 ;;Y("web-app","servlet",1,"init-param","cachePagesDirtyRead")=10
 ;;Y("web-app","servlet",1,"init-param","cachePagesRefresh")=10
 ;;Y("web-app","servlet",1,"init-param","cachePagesStore")=100
 ;;Y("web-app","servlet",1,"init-param","cachePagesTrack")=200
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesRefresh")=15
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesStore")=50
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesTrack")=100
 ;;Y("web-app","servlet",1,"init-param","configGlossary:adminEmail")="ksm@pobox.com"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:installationAt")="Philadelphia, PA"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:poweredBy")="Cofax"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:poweredByIcon")="/images/cofax.gif"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:staticPath")="/content/static"
 ;;Y("web-app","servlet",1,"init-param","dataStoreClass")="org.cofax.SqlDataStore"
 ;;Y("web-app","servlet",1,"init-param","dataStoreConnUsageLimit")=100
 ;;Y("web-app","servlet",1,"init-param","dataStoreDriver")="com.microsoft.jdbc.sqlserver.SQLServerDriver"
 ;;Y("web-app","servlet",1,"init-param","dataStoreInitConns")=10
 ;;Y("web-app","servlet",1,"init-param","dataStoreLogFile")="/usr/local/tomcat/logs/datastore.log"
 ;;Y("web-app","servlet",1,"init-param","dataStoreLogLevel")="debug"
 ;;Y("web-app","servlet",1,"init-param","dataStoreMaxConns")=100
 ;;Y("web-app","servlet",1,"init-param","dataStoreName")="cofax"
 ;;Y("web-app","servlet",1,"init-param","dataStorePassword")="dataStoreTestQuery"
 ;;Y("web-app","servlet",1,"init-param","dataStoreTestQuery")="SET NOCOUNT ON;select test='test';"
 ;;Y("web-app","servlet",1,"init-param","dataStoreUrl")="jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon"
 ;;Y("web-app","servlet",1,"init-param","dataStoreUser")="sa"
 ;;Y("web-app","servlet",1,"init-param","defaultFileTemplate")="articleTemplate.htm"
 ;;Y("web-app","servlet",1,"init-param","defaultListTemplate")="listTemplate.htm"
 ;;Y("web-app","servlet",1,"init-param","jspFileTemplate")="articleTemplate.jsp"
 ;;Y("web-app","servlet",1,"init-param","jspListTemplate")="listTemplate.jsp"
 ;;Y("web-app","servlet",1,"init-param","maxUrlLength")=500
 ;;Y("web-app","servlet",1,"init-param","redirectionClass")="org.cofax.SqlRedirection"
 ;;Y("web-app","servlet",1,"init-param","searchEngineFileTemplate")="forSearchEngines.htm"
 ;;Y("web-app","servlet",1,"init-param","searchEngineListTemplate")="forSearchEnginesList.htm"
 ;;Y("web-app","servlet",1,"init-param","searchEngineRobotsDb")="WEB-INF/robots.db"
 ;;Y("web-app","servlet",1,"init-param","templateLoaderClass")="org.cofax.FilesTemplateLoader"
 ;;Y("web-app","servlet",1,"init-param","templateOverridePath")=""
 ;;Y("web-app","servlet",1,"init-param","templatePath")="templates"
 ;;Y("web-app","servlet",1,"init-param","templateProcessorClass")="org.cofax.WysiwygTemplate"
 ;;Y("web-app","servlet",1,"init-param","useDataStore")="true"
 ;;Y("web-app","servlet",1,"init-param","useJSP")="false"
 ;;Y("web-app","servlet",1,"servlet-class")="org.cofax.cds.CDSServlet"
 ;;Y("web-app","servlet",1,"servlet-name")="cofaxCDS"
 ;;Y("web-app","servlet",2,"init-param","mailHost")="mail1"
 ;;Y("web-app","servlet",2,"init-param","mailHostOverride")="mail2"
 ;;Y("web-app","servlet",2,"servlet-class")="org.cofax.cds.EmailServlet"
 ;;Y("web-app","servlet",2,"servlet-name")="cofaxEmail"
 ;;Y("web-app","servlet",3,"servlet-class")="org.cofax.cds.AdminServlet"
 ;;Y("web-app","servlet",3,"servlet-name")="cofaxAdmin"
 ;;Y("web-app","servlet",4,"servlet-class")="org.cofax.cds.FileServlet"
 ;;Y("web-app","servlet",4,"servlet-name")="fileServlet"
 ;;Y("web-app","servlet",5,"init-param","adminGroupID")=4
 ;;Y("web-app","servlet",5,"init-param","betaServer")="true"
 ;;Y("web-app","servlet",5,"init-param","dataLog")=1
 ;;Y("web-app","servlet",5,"init-param","dataLogLocation")="/usr/local/tomcat/logs/dataLog.log"
 ;;Y("web-app","servlet",5,"init-param","dataLogMaxSize")=""
 ;;Y("web-app","servlet",5,"init-param","fileTransferFolder")="/usr/local/tomcat/webapps/content/fileTransferFolder"
 ;;Y("web-app","servlet",5,"init-param","log")=1
 ;;Y("web-app","servlet",5,"init-param","logLocation")="/usr/local/tomcat/logs/CofaxTools.log"
 ;;Y("web-app","servlet",5,"init-param","logMaxSize")=""
 ;;Y("web-app","servlet",5,"init-param","lookInContext")=1
 ;;Y("web-app","servlet",5,"init-param","removePageCache")="/content/admin/remove?cache=pages&id="
 ;;Y("web-app","servlet",5,"init-param","removeTemplateCache")="/content/admin/remove?cache=templates&id="
 ;;Y("web-app","servlet",5,"init-param","templatePath")="toolstemplates/"
 ;;Y("web-app","servlet",5,"servlet-class")="org.cofax.cms.CofaxToolsServlet"
 ;;Y("web-app","servlet",5,"servlet-name")="cofaxTools"
 ;;Y("web-app","servlet-mapping","cofaxAdmin")="/admin/*"
 ;;Y("web-app","servlet-mapping","cofaxCDS")="/"
 ;;Y("web-app","servlet-mapping","cofaxEmail")="/cofaxutil/aemail/*"
 ;;Y("web-app","servlet-mapping","cofaxTools")="/tools/*"
 ;;Y("web-app","servlet-mapping","fileServlet")="/static/*"
 ;;Y("web-app","taglib","taglib-location")="/WEB-INF/tlds/cofax.tld"
 ;;Y("web-app","taglib","taglib-uri")="cofax.tld"
 ;;zzzzz

VPRJTPD^INT^1^62766,48612.69441^0
VPRJTPD ;SLC/KCM -- Unit test data for patient save and query
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PTDATA   ; Sample data for patient
DEMOG7 ;;
 ;;{"addresses":[{"city":"Any Town","postalCode":"99998-0071","stateProvince":"WEST VIRGINIAN"}],"aliases":[{"fullName":"P7"}],"briefId":"A0007","dateOfBirth":19350407,"facilities":[{"code":500,"latestDate":20110613,"name":
 ;;"CAMP MASTER","systemId":"93EF"}],"familyName":"AVIVAPATIENT","gender":"M","givenNames":"TWENTYSEVEN","icn":-10107,"ssn":666000007,"uid":"urn:va:93EF:-7:pat:-7"}
 ;;zzz
DEMOG8 ;;
 ;;{"addresses":[{"city":"Any Town","postalCode":"99998-0071","stateProvince":"WEST VIRGINIAN"}],"aliases":[{"fullName":"P8"}],"briefId":"A0008","dateOfBirth":19350408,"facilities":[{"code":500,"latestDate":20110613,"name":
 ;;"CAMP MASTER","systemId":"93EF"}],"familyName":"AVIVAPATIENT","gender":"M","givenNames":"TWENTYEIGHT","icn":-10108,"ssn":666000008,"uid":"urn:va:93EF:-8:pat:-8"}
 ;;zzz
MED1 ;;
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:93EF:-7:med:16982","localId":"402786;O","productFormName":"TAB,SA","sig":"TAKE ONE TABLET BY BY MOUTH TWICE A DAY","medStatus":"urn:sct:55561003","medType":"urn:sct
 ;;:73639000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"METFORMIN","kind":"Medication, Outpatient","overallStart":"20050317","overallStop":"20060318","stopped":"20050317","products":[{"ingredientCode":"urn:vu
 ;;id:4023979","ingredientName":"METFORMIN","drugClassCode":"urn:vadc:HS502","drugClassName":"ORAL HYPOGLYCEMIC AGENTS,ORAL","suppliedCode":"urn:vuid:4014984","suppliedName":"METFORMIN HCL 250MG TAB,SA","ingredientRole":"urn
 ;;:sct:410942007"}],"dosages":[{"dose":"250 MG","units":"MG","routeName":"PO","scheduleName":"BID","relativeStart":0,"relativeStop":0,"start":"20050317","stop":"20050317"}],"orders":[{"orderId":"","prescriptionId":"500290",
 ;;"quantityOrdered":"180","daysSupply":90,"fillsAllowed":3,"fillsRemaining":3,"fillCost":"90","location":"","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20050317152443.000","expiration":"2006
 ;;0318","provider":{"uid":"11745","name":"LABTECH,SPECIAL"},"pharmacist":{"uid":"10000000019","name":"TDPHARMACIST,ONE"}}]}
 ;;zzz
MED2 ;;
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:93EF:-7:med:17203","localId":"402926;O","productFormName":"TAB","sig":"TAKE ONE TABLET BY BY MOUTH EVERY DAY AT 1 PM","medStatus":"urn:sct:73425007","medType":"urn:sc
 ;;t:73639000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"WARFARIN","kind":"Medication, Outpatient","overallStart":"20060530","overallStop":"20070602","stopped":"20060604","products":[{"ingredientCode":"urn:vuid
 ;;:4019972","ingredientName":"WARFARIN","drugClassCode":"urn:vadc:BL110","drugClassName":"ANTICOAGULANTS","suppliedCode":"urn:vuid:4013990","suppliedName":"WARFARIN (C0UMADIN) NA 5MG TAB","ingredientRole":"urn:sct:410942007
 ;;"}],"dosages":[{"dose":"5 MG","units":"MG","routeName":"PO","scheduleName":"QD-WARF","relativeStart":0,"relativeStop":5760,"start":"20060531","stop":"20060604"}],"orders":[{"orderId":"","prescriptionId":"500412","quantity
 ;;Ordered":"30","daysSupply":30,"fillsAllowed":5,"fillsRemaining":5,"fillCost":"1.65","location":"VIST CLINIC","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20060531160045.000","expiration":"2
 ;;0070601","provider":{"uid":"10000000031","name":"VEHU,ONEHUNDRED"},"pharmacist":{"uid":"20144","name":"PHARMACIST,THIRTY"}}]}
 ;;zzz
MED3 ;;
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:93EF:-7:med:17266","localId":"402924;O","productFormName":"TAB,SA","sig":"TAKE ONE TABLET BY BY MOUTH TWICE A DAY","medStatus":"urn:sct:73425007","medType":"urn:sct:7
 ;;3639000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"METFORMIN","kind":"Medication, Outpatient","overallStart":"20060531","overallStop":"20070601","stopped":"20060604","products":[{"ingredientCode":"urn:vuid:4
 ;;023979","ingredientName":"METFORMIN","drugClassCode":"urn:vadc:HS502","drugClassName":"ORAL HYPOGLYCEMIC AGENTS,ORAL","suppliedCode":"urn:vuid:4014984","suppliedName":"METFORMIN HCL 500MG TAB,SA","ingredientRole":"urn:sct
 ;;:410942007"}],"dosages":[{"dose":"500 MG","units":"MG","routeName":"PO","scheduleName":"BID","relativeStart":0,"relativeStop":5760,"start":"20060531","stop":"20060604"}],"orders":[{"orderId":"","prescriptionId":"500290A",
 ;;"quantityOrdered":"180","daysSupply":90,"fillsAllowed":3,"fillsRemaining":3,"fillCost":"90","location":"VIST CLINIC","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20060531161818.000","expira
 ;;tion":"20070601","provider":{"uid":"10000000031","name":"VEHU,ONEHUNDRED"},"pharmacist":{"uid":"20144","name":"PHARMACIST,THIRTY"}}]}
 ;;zzz
MED4 ;;
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:93EF:-7:med:18068","localId":"1N;O","productFormName":"TAB,EC","sig":"TAKE ONE TABLET BY MOUTH EVERY MORNING","medStatus":"urn:sct:55561003","medType":"urn:sct:329505
 ;;003","vaType":"N","vaStatus":"ACTIVE","qualifiedName":"ASPIRIN","kind":"Medication, Non-VA","products":[{"ingredientCode":"urn:vuid:4017536","ingredientName":"ASPIRIN TAB","drugClassCode":"urn:vadc:CN103","drugClassName":"NON
 ;;-OPIOID ANALGESICS","suppliedCode":"urn:vuid:4005766","suppliedName":"ASPIRIN 81MG EC TAB","ingredientRole":"urn:sct:410942007"}],"dosages":[{"dose":"81 MG","units":"MG","routeName":"PO","scheduleName":"QAM","relativeStar
 ;;t":0}],"orders":[{"orderId":"","prescriptionId":"","quantityOrdered":"","fillCost":"","location":"GENERAL MEDICINE","vaRouting":"","vaDispensed":false,"vaOrderStatus":"ACTIVE","ordered":"20070411162700.000","provider":{"u
 ;;id":"10000000031","name":"VEHU,ONEHUNDRED"}}]}
 ;;zzz
MED5 ;;
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:93EF:-7:med:18069","localId":"403229;O","productFormName":"TAB,SA","sig":"TAKE ONE TABLET BY BY MOUTH TWICE A DAY","medStatus":"urn:sct:73425007","medType":"urn:sct:7
 ;;3639000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"METFORMIN","kind":"Medication, Outpatient","overallStart":"20070411","overallStop":"20080411","stopped":"20080128","products":[{"ingredientCode":"urn:vuid:4
 ;;023979","ingredientName":"METFORMIN","drugClassCode":"urn:vadc:HS502","drugClassName":"ORAL HYPOGLYCEMIC AGENTS,ORAL","suppliedCode":"urn:vuid:4014984","suppliedName":"METFORMIN HCL 500MG TAB,SA","ingredientRole":"urn:sct
 ;;:410942007"}],"dosages":[{"dose":"500 MG","units":"MG","routeName":"PO","scheduleName":"BID","relativeStart":0,"relativeStop":420540,"start":"20070411","stop":"20080128"}],"orders":[{"orderId":"","prescriptionId":"500290B
 ;;","quantityOrdered":"180","daysSupply":90,"fillsAllowed":3,"fillsRemaining":3,"fillCost":"90","location":"GENERAL MEDICINE","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20070411162837.000",
 ;;"expiration":"20080411","provider":{"uid":"10000000031","name":"VEHU,ONEHUNDRED"},"pharmacist":{"uid":"10000000056","name":"PHARMACIST,ONE"}}]}
 ;;zzz
 ;
MED6 ; Sample Med to Add
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:93EF:-7:med:15231","localId":"402300;O","productFormName":"TAB","sig":"TAKE ONE TABLET BY BY MOUTH TWICE A DAY","medStatus":"urn:sct:73425007","medType":"urn:sct:7363
 ;;9000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"METOPROLOL","kind":"Medication, Outpatient","overallStart":"20040330","overallStop":"20050331","stopped":"20040330","products":[{"ingredientCode":"urn:vuid:4
 ;;019836","ingredientName":"METOPROLOL","drugClassCode":"urn:vadc:CV100","drugClassName":"BETA BLOCKERS/RELATED","suppliedCode":"urn:vuid:4004608","suppliedName":"METOPROLOL TARTRATE 50MG TAB","ingredientRole":"urn:sct:41
 ;;0942007"}],"dosages":[{"dose":"50 MG","units":"MG","routeName":"PO","scheduleName":"BID","relativeStart":0,"relativeStop":0,"start":"20040330","stop":"20040330"}],"orders":[{"orderId":"","prescriptionId":"500046","quant
 ;;ityOrdered":"180","daysSupply":90,"fillsAllowed":3,"fillsRemaining":3,"fillCost":"11.88","location":"","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20040330145422.000","expiration":"20050
 ;;331","provider":{"uid":"11745","name":"LABTECH,SPECIAL"},"pharmacist":{"uid":"11745","name":"LABTECH,SPECIAL"}}]}
 ;;zzz
TIU1 ; Sample TIU document
 ;;{"uid":"urn:va:93EF:8:tiu:1090","summary":"BLEEDING DISORDER","pid":"3","kind":"","facilityCode":"500D","facilityName":"SLC-FO HMP DEV","localId":"1090","encounterUid":"urn:va:93EF:8:visit:1218","encounterName":"GEN MED
 ;; Jul 18, 1995","referenceDateTime":"19990513131520","documentTypeCode":"CR","documentTypeName":"","documentClass":"PROGRESS NOTES","localTitle":"BLEEDING DISORDER","status":"completed","content":" LOCAL TITLE: BLEEDING 
 ;;DISORDER                                  \r\n   DICT DATE: MAY 13, 1999@10:11     ENTRY DATE: MAY 13, 1999@13:15:20      \r\n DICTATED BY: PROVIDER,TWOHUNDRED  EXP COSIGNER:                           \r\n     URGENCY:
 ;;                            STATUS: COMPLETED                     \r\n\r\n nblkve\r\nv kldh\r\nPatient is a 46-year-old male here for evaluation of his bilateral knee \r\nblood tests done, because he was unaware that he
 ;; needed to be fasting.  \r\nStates that he recently started a new job as a Physiology Professor at \r\na local college and was concerned about missing too much work (needed \r\nto take time from work two days in a row o
 ;;f these exams).  \r\n \r\n@###\r\n \r\n/es/ \r\n\r\nSigned: 05/13/1999 13:15","clinicians":[{"uid":"urn:va:user:93EF:11712","summary":"EXT.DOMAIN.cpe.vpr.DocumentClinician@388c3949","role":"A","name":"PROVIDER,TWOHUNDREDNIN
 ;;ETYSEVEN"},{"uid":"urn:va:user:93EF:11712","summary":"EXT.DOMAIN.cpe.vpr.DocumentClinician@7e05049f","role":"S","signedDateTime":"19990513131536","signature":"TWOHUNDREDNINETYSEVEN PROVIDER COMPUTER SPECIALIST","name":"PROV
 ;;IDER,TWOHUNDREDNINETYSEVEN"}],"text":" LOCAL TITLE: BLEEDING DISORDER                                  \r\n   DICT DATE: MAY 13, 1999@10:11     ENTRY DATE: MAY 13, 1999@13:15:20      \r\n DICTATED BY: PROVIDER,TWOHUNDRE
 ;;D  EXP COSIGNER:                           \r\n     URGENCY:                            STATUS: COMPLETED                     \r\n\r\n nblkve\r\nv kldh\r\nPatient is a 46-year-old male here for evaluation of his bilater
 ;;al knee \r\nblood tests done, because he was unaware that he needed to be fasting.  \r\nStates that he recently started a new job as a Physiology Professor at \r\na local college and was concerned about missing too much
 ;; work (needed \r\nto take time from work two days in a row of these exams).  \r\n \r\n@###\r\n \r\n/es/ \r\n\r\nSigned: 05/13/1999 13:15","idx":[]}
 ;;zzz

VPRJTQF^INT^1^62766,48612.701946^0
VPRJTQF ;SLC/KCM -- Unit tests for query filters
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N DATA,I,LOC
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 I VPRJTPID D CLEARPT^VPRJP(VPRJTPID)
 D SETUP^VPRJM
 D GETDATA("DEMOG7",.DATA)
 S VPRJTPID=$P($$PUTPT^VPRJPR("",.DATA),"/",3)
 D MOCK1
 Q
SHUTDOWN ; Run once after all tests
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 D CLEARPT^VPRJP(VPRJTPID)
 K VPRJTPID
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
GETDATA(TAG,DATA) ;
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^VPRJTPD),";;",2,999) Q:X="zzz"  S DATA(I)=X
 Q
MOCK1 ; Create mock data to test filter against
 N PID,UID
 S PID=VPRJTPID,UID="urn:va:93EF:-7:test:1"
 S ^VPRPT(PID,UID,"topValue")=1
 S ^VPRPT(PID,UID,"strValue")="quick brown fox"
 S ^VPRPT(PID,UID,"valueA")="red"
 S ^VPRPT(PID,UID,"result")=7.6
 S ^VPRPT(PID,UID,"observed")=20110919
 S ^VPRPT(PID,UID,"facility","name")="VAMC"
 S ^VPRPT(PID,UID,"products",1,"ingredient")="aspirin"
 S ^VPRPT(PID,UID,"products",2,"ingredient")="codeine"
 S ^VPRPT(PID,UID,"orders",1,"clinician","name")="Welby"
 Q
ASSERT(EXPECT,ACTUAL,MSG) ; for convenience
 D EQ^VPRJT(EXPECT,ACTUAL,$G(MSG))
 Q
EVAL(LINE) ; return evaluation of statement
 N PID,UID,STMT,CLAUSES,HTTPERR
 S STMT=$P($T(@LINE),";;",2,99)
 D PARSE^VPRJPQF(STMT,.CLAUSES)
 D ASSERT(0,$D(HTTPERR),"HTTP error:"_$G(HTTPERR))
 S PID=VPRJTPID,UID="urn:va:93EF:-7:test:1"
 K HTTPERR
 Q $$EVALAND^VPRJPQF(.CLAUSES,UID)
 D ASSERT(0,$D(HTTPERR),"HTTP error:"_$G(HTTPERR))
 ;
SIMPLE ;; @TEST simple match
 ;; eq(topValue,1)
 ;; eq(topValue,42)
 ;; eq(missingValue,27)
 ;; eq("products[].ingredient","codeine")
 ;; eq("products[].ingredient","acetaminphen")
 ;; eq("facility.name","VAMC")
 ;; eq("facility.name","other") 
 D ASSERT(1,$$EVAL("SIMPLE+1"))
 D ASSERT(0,$$EVAL("SIMPLE+2"))
 D ASSERT(0,$$EVAL("SIMPLE+3"))
 D ASSERT(1,$$EVAL("SIMPLE+4"))
 D ASSERT(0,$$EVAL("SIMPLE+5"))
 D ASSERT(1,$$EVAL("SIMPLE+6"))
 D ASSERT(0,$$EVAL("SIMPLE+7"))
 Q
FLTAND ;; @TEST filter with ands
 ;; eq(topValue,1) eq(strValue,"quick brown fox")
 ;; eq(topValue,1) eq(strValue,"wrong")
 ;; ne(topValue,2) eq("products[].ingredient","aspirin")
 ;; eq(topValue,1) ne("products[].ingredient","acetaminophen")
 ;; eq(topValue,1) eq("products[].ingredient","acetaminophen")
 D ASSERT(1,$$EVAL("FLTAND+1"))
 D ASSERT(0,$$EVAL("FLTAND+2"))
 D ASSERT(1,$$EVAL("FLTAND+3"))
 D ASSERT(1,$$EVAL("FLTAND+4"))
 D ASSERT(0,$$EVAL("FLTAND+5"))
 Q
FLTOR ;; @TEST filter with or's
 ;; eq(topValue,1) or{eq(valueA,"red") eq(valueA,"green")}
 ;; eq(topValue,1) or{eq(valueA,"blue") eq(valueA,"yellow")}
 D ASSERT(1,$$EVAL("FLTOR+1"))
 D ASSERT(0,$$EVAL("FLTOR+2"))
 Q
FLTNOT ;; @TEST filter with not's
 ;; eq(topValue,1) not{eq(valueA,"yellow") eq(valueA,"green") eq(valueA,"blue")}
 ;; eq(topValue,1) not{eq(valueA,"red") eq(valueA,"green") eq(valueA,"blue")}
 D ASSERT(1,$$EVAL("FLTNOT+1"))
 D ASSERT(0,$$EVAL("FLTNOT+2"))
 Q
FLTIN ;; @TEST filter in property
 ;; in(valueA,["red","green","blue"])
 ;; in(valueA,["orange","banana","peach"])
 D ASSERT(1,$$EVAL("FLTIN+1"))
 D ASSERT(0,$$EVAL("FLTIN+2"))
 Q
FLTNIN ;; @TEST filter not in array
 ;; nin(valueA,["red","green","blue"])
 ;; nin(valueA,["orange","banana","peach"])
 ;; nin("products[].ingredient",["acetiminophen","ibuprofin"])
 ;; nin("products[].ingredient",["aspirin","codeine"])
 D ASSERT(0,$$EVAL("FLTNIN+1"))
 D ASSERT(1,$$EVAL("FLTNIN+2"))
 D ASSERT(1,$$EVAL("FLTNIN+3"))
 D ASSERT(0,$$EVAL("FLTNIN+4"))
 Q
FLTGTLT ;; @TEST filter gt and lt (value of result is 7.6)
 ;; gt(result,7.0)
 ;; gt(result,8)
 ;; gte(result,7.5)
 ;; gte(result,7.6)
 ;; gte(result,7.7)
 ;; lt(result,8)
 ;; lte(result,6)
 ;; lte(result,7.6)
 ;; lte(result,7.5)
 ;; lt(result,5)
 D ASSERT(1,$$EVAL("FLTGTLT+1"))
 D ASSERT(0,$$EVAL("FLTGTLT+2"))
 D ASSERT(1,$$EVAL("FLTGTLT+3"))
 D ASSERT(1,$$EVAL("FLTGTLT+4"))
 D ASSERT(0,$$EVAL("FLTGTLT+5"))
 D ASSERT(1,$$EVAL("FLTGTLT+6"))
 D ASSERT(0,$$EVAL("FLTGTLT+7"))
 D ASSERT(1,$$EVAL("FLTGTLT+8"))
 D ASSERT(0,$$EVAL("FLTGTLT+9"))
 D ASSERT(0,$$EVAL("FLTGTLT+10"))
 Q
FLTGTLTS ;; @TEST filter gt and lt with strings
 ;; gt(valueA,"blue")
 ;; gt(valueA,"TAN")
 ;; gte(valueA,"record")
 ;; gte(valueA,"red")
 ;; gte(valueA,"reddish")
 ;; lt(valueA,"TAN")
 ;; lte(valueA,"reddish")
 ;; lte(valueA,"red")
 ;; lte(valueA,"blue")
 ;; lt(valueA,"brown")
 D ASSERT(1,$$EVAL("FLTGTLTS+1"))
 D ASSERT(1,$$EVAL("FLTGTLTS+2")) ; lowercase sorts after upper
 D ASSERT(1,$$EVAL("FLTGTLTS+3"))
 D ASSERT(1,$$EVAL("FLTGTLTS+4"))
 D ASSERT(0,$$EVAL("FLTGTLTS+5"))
 D ASSERT(0,$$EVAL("FLTGTLTS+6")) ; uppercase is less than lowercase
 D ASSERT(1,$$EVAL("FLTGTLTS+7"))
 D ASSERT(1,$$EVAL("FLTGTLTS+8"))
 D ASSERT(0,$$EVAL("FLTGTLTS+9"))
 D ASSERT(0,$$EVAL("FLTGTLTS+10"))
 Q
FLTWEEN ;; @TEST between for numerics
 ;; between(result,7,8)
 ;; between(result,6,7)
 ;; between(result,8,9)
 D ASSERT(1,$$EVAL("FLTWEEN+1"))
 D ASSERT(0,$$EVAL("FLTWEEN+2"))
 D ASSERT(0,$$EVAL("FLTWEEN+3"))
 Q
FLTWEENS ;; @TEST between for strings
 ;; between(valueA,"rat","rot")
 ;; between(valueA,"RAT","ROT")
 ;; between(valueA,"reddish","tan")
 D ASSERT(1,$$EVAL("FLTWEENS+1"))
 D ASSERT(0,$$EVAL("FLTWEENS+2"))
 D ASSERT(0,$$EVAL("FLTWEENS+3"))
 Q
FLTLIKE ;; @TEST like for strings
 ;; like(strValue,"%brown%")
 ;; like(strValue,"%red%")
 ;; like(strValue,"%fox")
 ;; like("products[].ingredient","asp%")
 ;; like("products[].ingredient","ace%")
 ;; like("products[].ingredient","%C%")
 D ASSERT(1,$$EVAL("FLTLIKE+1"))
 D ASSERT(0,$$EVAL("FLTLIKE+2"))
 D ASSERT(1,$$EVAL("FLTLIKE+3"))
 D ASSERT(1,$$EVAL("FLTLIKE+4"))
 D ASSERT(0,$$EVAL("FLTLIKE+5"))
 D ASSERT(0,$$EVAL("FLTLIKE+5"))
 Q
FLTILIKE ;; @TEST ilike (case insensitive) for string
 ;; ilike("products[].ingredient","ACE%")
 ;; ilike("products[].ingredient","%C%")
 D ASSERT(0,$$EVAL("FLTILIKE+1"))
 D ASSERT(1,$$EVAL("FLTILIKE+2"))
 Q
FLTEXIST ;; @TEST exist for values
 ;; exists(result)
 ;; exists(absent)
 ;; exists("orders[].clinician.name")
 ;; exists(absent,false)
 D ASSERT(1,$$EVAL("FLTEXIST+1"))
 D ASSERT(0,$$EVAL("FLTEXIST+2"))
 D ASSERT(1,$$EVAL("FLTEXIST+3"))
 D ASSERT(1,$$EVAL("FLTEXIST+4"))
 Q
FLTDATES ;; @TEST dates represented as strings
 ;; between(observed,"2008","2012")
 ;; lt(observed,"201110")
 ;; gte(observed,"20110919")
 ;; lt(observed,"20080919103426")
 D ASSERT(1,$$EVAL("FLTDATES+1"))
 D ASSERT(1,$$EVAL("FLTDATES+2"))
 D ASSERT(1,$$EVAL("FLTDATES+3"))
 D ASSERT(0,$$EVAL("FLTDATES+4"))
 Q 
FLDTYP ;; @TEST filter with various field types
 ;;eq("summary", 1) eq(facility.name, 2) eq("products[].ingredient", 3) eq("products[].ingredient.name", 4) eq(noquote, 0)
 ;;NOTE: fields with [] must be quoted
 N FILTER,CLAUSES
 S FILTER=$P($T(FLDTYP+1),";;",2,99)
 D PARSE^VPRJPQF(FILTER,.CLAUSES)
 D ASSERT(1,CLAUSES(1,"type"))
 D ASSERT(2,CLAUSES(2,"type"))
 D ASSERT(3,CLAUSES(3,"type"))
 D ASSERT(4,CLAUSES(4,"type"))
 D ASSERT("summary",CLAUSES(1,"field"))
 D ASSERT("ingredient",CLAUSES(3,"field"))
 D ASSERT("products",CLAUSES(4,"mult"))
 D ASSERT("name",CLAUSES(4,"sub"))
 Q
CONJ ;; @TEST nested conjunctions
 ;;or{ eq(tobe, 1) eq(notobe, 2) and{eq(unrelated, 3), eq(another, 4)}}
 ;;eq(status,7) gt(observed,"2011") in("products[].code",[20,30,40]) or{eq(a,7) eq(b,8) lt(c,500)} and{eq(w,200) gt(x,7) eq(z,50)} eq(milk,"fresh") and{eq(h,1) eq(j,2)}
 N FILTER,CLAUSES
 S FILTER=$P($T(CONJ+1),";;",2,99)
 D PARSE^VPRJPQF(FILTER,.CLAUSES)
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("tobe",CLAUSES(1,2,"field"))
 D ASSERT("and",CLAUSES(1,4))
 D ASSERT("another",CLAUSES(1,4,2,"field"))
 K CLAUSES
 S FILTER=$P($T(CONJ+2),";;",2,99)
 D PARSE^VPRJPQF(FILTER,.CLAUSES)
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(1,$D(CLAUSES(2,"asString")))
 Q
VALUES ;; @TEST types of values
 ;; eq(astr, "this is a string") gt(anum, 123) in(alist, ["alpha","beta","gamma"]) eq(funnyStr, "123")
 N FILTER,CLAUSES
 S FILTER=$P($T(VALUES+1),";;",2,99)
 D PARSE^VPRJPQF(FILTER,.CLAUSES)
 D ASSERT("this is a string",CLAUSES(2,"value"))
 D ASSERT(123,+CLAUSES(3,"value"))
 D ASSERT(1,$D(CLAUSES(4,"list","gamma")))
 D ASSERT(1,$D(CLAUSES(5,"asString")))
 Q
MAKEPAT ; @TEST converting SQL Like statements into M patterns
 N X,TV ; TV = test value -- to get around XINDEX problem
 S X=$$MAKEPAT^VPRJPQF("%ing")
 D ASSERT(".E1""ing""",X)
 S TV="reindexing" D ASSERT(1,TV?@X)
 S TV="indexing" D ASSERT(1,TV?@X)
 S X=$$MAKEPAT^VPRJPQF("re%ing")
 D ASSERT("1""re"".E1""ing""",X)
 S TV="reindexing" D ASSERT(1,TV?@X)
 S TV="indexing" D ASSERT(0,TV?@X)
 S X=$$MAKEPAT^VPRJPQF("re%")
 D ASSERT("1""re"".E",X)
 S X=$$MAKEPAT^VPRJPQF("%ING")
 D ASSERT(".E1""ING""",X)
 S TV="reindexing" D ASSERT(0,TV?@X)
 S X=$$MAKEPAT^VPRJPQF("RE%")
 D ASSERT("1""RE"".E",X)
 S X=$$MAKEPAT^VPRJPQF("%ING",1)
 D ASSERT(".E1""ing""",X)
 S X=$$MAKEPAT^VPRJPQF("RE%",1)
 D ASSERT("1""re"".E",X)
 S TV="reindexing" D ASSERT(1,TV?@X)
 S TV="indexing" D ASSERT(0,TV?@X)
 S X=$$MAKEPAT^VPRJPQF("%")
 D ASSERT(".E",X)
 S X=$$MAKEPAT^VPRJPQF("REINDEXING",1)
 D ASSERT("1""reindexing""",X)
 S TV="reindexing" D ASSERT(1,TV?@X)
 S TV="indexing" D ASSERT(0,TV?@X)
 Q

VPRJTQU^INT^1^62756,62813.024902^0
VPRJTQU ;SLC/KCM -- Unit tests for query utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
ADJNUM   ;; @TEST incrementing and decrementing numbers
 ; use CHKTF, CHKEQ, FAIL, CHKLEAKS to test calls
 N X
 S X=$$ADJNUM^VPRJPQU(100)       D ASSERT(101,X)
 S X=$$ADJNUM^VPRJPQU(1.009)     D ASSERT(1.01,X)
 S X=$$ADJNUM^VPRJPQU(1.001,"-") D ASSERT(1,X)
 S X=$$ADJNUM^VPRJPQU(100,"-")   D ASSERT(99,X)
 Q
ADJSTR   ;; @TEST bumping strings up and down in collation
 N X
 S X=$$ADJSTR^VPRJPQU("SMILE","-") D ASSERT("SMILD"_$C(255),X)
 S X=$$ADJSTR^VPRJPQU("SMI")       D ASSERT("SMI"_$C(255),X)
 Q
RNG2VAL  ;; @TEST converting ranges to START, STOP
 N START,STOP,MAXC
 S MAXC=$C(255)
 ;
 ; default is include endpoints and assume each is "starts with"
 D RNG2VAL^VPRJPQU("201209191045..201210200620",.START,.STOP,"T")
 D ASSERT("201209191045",START),ASSERT("201210200620 ",STOP)
 ; (start:stop) gets the values between start and stop (exclude endpoints)
 D RNG2VAL^VPRJPQU("]201209191045..201210200620[",.START,.STOP,"T")
 D ASSERT("201209191045 ",START),ASSERT("201210200620",STOP)
 ; [start:stop] changes start/stop so that $O will include endpoints
 D RNG2VAL^VPRJPQU("[201209191045..201210200620]",.START,.STOP,"T")
 D ASSERT("201209191045",START),ASSERT("201210200620 ",STOP)
 D RNG2VAL^VPRJPQU("20121101",.START,.STOP,"T")
 D ASSERT("20121101",START),ASSERT("20121101 ",STOP)
 D RNG2VAL^VPRJPQU("201211011045",.START,.STOP,"T")
 D ASSERT("201211011045",START),ASSERT("201211011045 ",STOP)
 ;
 D RNG2VAL^VPRJPQU("ACETAMINOPHEN..ASPIRIN",.START,.STOP,"S")
 D ASSERT("ACETAMINOPHEN",START),ASSERT("ASPIRIN ",STOP)
 D RNG2VAL^VPRJPQU("]ACETAMINOPHEN..ASPIRIN[",.START,.STOP,"S")
 D ASSERT("ACETAMINOPHEN ",START),ASSERT("ASPIRIN",STOP)
 D RNG2VAL^VPRJPQU("[ACETAMINOPHEN..ASPIRIN]",.START,.STOP,"S")
 D ASSERT("ACETAMINOPHEN",START),ASSERT("ASPIRIN ",STOP)
 ;
 D RNG2VAL^VPRJPQU("ASPIRIN*",.START,.STOP,"S")
 D ASSERT("ASPIRIN",START),ASSERT("ASPIRIN"_MAXC,STOP)
 D RNG2VAL^VPRJPQU("ASP*",.START,.STOP,"S")
 D ASSERT("ASP",START),ASSERT("ASP"_MAXC,STOP)
 ;
 D RNG2VAL^VPRJPQU("10..20",.START,.STOP,"N")
 D ASSERT(9,START),ASSERT(20,STOP)
 D RNG2VAL^VPRJPQU("[10..20]",.START,.STOP,"N")
 D ASSERT(9,START),ASSERT(20,STOP)
 D RNG2VAL^VPRJPQU("]1.001..3.1416[",.START,.STOP,"N")
 D ASSERT(1.001,START),ASSERT(3.1415,STOP)
 D RNG2VAL^VPRJPQU("[1.001..3.1416]",.START,.STOP,"N")
 D ASSERT(1,START),ASSERT(3.1416,STOP)
 Q
RNG2VAL2 ;; @TEST convert range to start, stop (2nd edition)
 ;; -- string collation, space appended to each entry in index
 ;;SMILE       "SMILE"   Q:X]"SMILE "   []  equals SMILE
 ;;[SMILE]     "SMILE"   Q:X]"SMILE "   []  equals SMILE
 ;;SMI..SOR    "SMI"     Q:X]"SOR "     []  startswith SMI thru startswith SOR
 ;;[SMI..SOR]  "SMI"     Q:X]"SOR "     []  SMI thru SOR (not startswith) 
 ;;]SMI..SOR[  "SMI "    Q:X]"SOR"      ()  SMI thru SOR excluding SMI and SOR
 ;;SMI*        "SMI"     Q:X]"SMI"     [*  startswith SMI
 ;;]SMI*       "SMI "    Q:X]"SMI"     (*  startswith SMI, excluding SMI itself
 ;; 
 ;; -- time collation, space appended to each entry in index
 ;;20121101..20121117    "20121101"       Q:X]"20121117 "      []
 ;;20121101              "20121101"       Q:X]"20121101 "      []
 ;;[20121101..20121117]  "20121101"       Q:X]"20121117 "      []
 ;;]20121101..20121117[  "20121101 "      Q:X]"20121117"       ()
 ;;201211011045          "201211011045"   Q:X]"201211011045 "  []
 ;;201211*               "201211"         Q:X]"201211"        [*
 ;;]201211*              "201211 "        Q:X]"201211"        (*
 ;;
 ;; -- inverse time collation, number inverted and space appended
 ;;20121101..20121117    "79878882:"      Q:X]"79878898="      []
 ;;20121101              "79878898:"      Q:X]"79878898="      []
 ;;[20121101..20121117]  "79878882:"      Q:X]"79878898="      []
 ;;]20121101..20121117[  "79878882="      Q:X]"79878898:"      ()
 ;;201211011045          "798788988954:"  Q:X]"798788988954="  []
 ;;201211*               "798788 "        Q:X]"798788="        [*
 ;;]201211*              "798788 "        Q:X]"798788:"        (*
 ;;
 ;; -- numeric collation, each entry in index is "plused"
 ;;123456.654321..65432.789    123456.654320   Q:X>65432.789   []
 ;;[123456.654321..65432.789]  123456.654320   Q:X>65432.789   []
 ;;]123456.654321..65432.789[  123456.654321   Q:X>65432.788   ()
 ;
 N START,STOP,MAXC
 S MAXC=$C(255)
 D RNG2VAL^VPRJPQU("SMILE",.START,.STOP,"S")      D ASSERT("SMILE",START) D ASSERT("SMILE ",STOP)
 D RNG2VAL^VPRJPQU("[SMILE]",.START,.STOP,"S")    D ASSERT("SMILE",START) D ASSERT("SMILE ",STOP)
 D RNG2VAL^VPRJPQU("SMI..SOR",.START,.STOP,"S")   D ASSERT("SMI",START)   D ASSERT("SOR ",STOP)
 D RNG2VAL^VPRJPQU("[SMI..SOR]",.START,.STOP,"S") D ASSERT("SMI",START)   D ASSERT("SOR ",STOP)
 D RNG2VAL^VPRJPQU("]SMI..SOR[",.START,.STOP,"S") D ASSERT("SMI ",START)  D ASSERT("SOR",STOP)
 D RNG2VAL^VPRJPQU("SMI*",.START,.STOP,"S")       D ASSERT("SMI",START)   D ASSERT("SMI"_MAXC,STOP)
 D RNG2VAL^VPRJPQU("]SMI*",.START,STOP,"S")       D ASSERT("SMI ",START)  D ASSERT("SMI"_MAXC,STOP)
 ;
 D RNG2VAL^VPRJPQU("20121101..20121117",.START,.STOP,"T")   D ASSERT("20121101",START)     D ASSERT("20121117 ",STOP)
 D RNG2VAL^VPRJPQU("20121101",.START,.STOP,"T")             D ASSERT("20121101",START)     D ASSERT("20121101 ",STOP)
 D RNG2VAL^VPRJPQU("[20121101..20121117]",.START,.STOP,"T") D ASSERT("20121101",START)     D ASSERT("20121117 ",STOP)
 D RNG2VAL^VPRJPQU("]20121101..20121117[",.START,.STOP,"T") D ASSERT("20121101 ",START)    D ASSERT("20121117",STOP)
 D RNG2VAL^VPRJPQU("201211011045",.START,.STOP,"T")         D ASSERT("201211011045",START) D ASSERT("201211011045 ",STOP)
 D RNG2VAL^VPRJPQU("201211*",.START,.STOP,"T")              D ASSERT("201211",START)       D ASSERT("201211"_MAXC,STOP)
 D RNG2VAL^VPRJPQU("]201211*",.START,.STOP,"T")             D ASSERT("201211 ",START)      D ASSERT("201211"_MAXC,STOP)
 ;
 D RNG2VAL^VPRJPQU("20121101..20121117",.START,.STOP,"V")   D ASSERT("79878882:",START)     D ASSERT("79878898=",STOP)
 D RNG2VAL^VPRJPQU("20121101",.START,.STOP,"V")             D ASSERT("79878898:",START)     D ASSERT("79878898=",STOP)
 D RNG2VAL^VPRJPQU("[20121101..20121117]",.START,.STOP,"V") D ASSERT("79878882:",START)     D ASSERT("79878898=",STOP)
 D RNG2VAL^VPRJPQU("]20121101..20121117[",.START,.STOP,"V") D ASSERT("79878882=",START)     D ASSERT("79878898:",STOP)
 D RNG2VAL^VPRJPQU("201211011045",.START,.STOP,"V")         D ASSERT("798788988954:",START) D ASSERT("798788988954=",STOP)
 D RNG2VAL^VPRJPQU("201211*",.START,.STOP,"V")              D ASSERT("798788 ",START)       D ASSERT("798788=",STOP)
 D RNG2VAL^VPRJPQU("]201211*",.START,.STOP,"V")             D ASSERT("798788 ",START)       D ASSERT("798788:",STOP)
 ;
 D RNG2VAL^VPRJPQU("12345.654321..65432.789",.START,.STOP,"N")   D ASSERT(12345.65432,START)  D ASSERT(65432.789,STOP)
 D RNG2VAL^VPRJPQU("[12345.654321..65432.789]",.START,.STOP,"N") D ASSERT(12345.65432,START)  D ASSERT(65432.789,STOP)
 D RNG2VAL^VPRJPQU("]12345.654321..65432.789[",.START,.STOP,"N") D ASSERT(12345.654321,START) D ASSERT(65432.788,STOP)
 ;
 D RNG2VAL^VPRJPQU("2014..1999",.START,.STOP,"T") D ASSERT("1999",START) D ASSERT("2014 ",STOP)
 Q

VPRJTQX^INT^1^62766,48612.709361^0
VPRJTQX ;SLC/KCM -- Unit tests for query indexes
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;TODO:  add test for tally
 ;TODO:  add test for query UID
 ;
STARTUP  ; Run once before all tests
 N DATA,I,LOC
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 I VPRJTPID D CLEARPT^VPRJP(VPRJTPID)
 D SETUP^VPRJM
 D GETDATA("DEMOG7",.DATA)
 S VPRJTPID=$P($$PUTPT^VPRJPR("",.DATA),"/",3)
 F I=1:1:5 D GETDATA("MED"_I,.DATA) S LOC=$$SAVE^VPRJP(VPRJTPID,.DATA) K DATA
 Q
SHUTDOWN ; Run once after all tests
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 D CLEARPT^VPRJP(VPRJTPID)
 K VPRJTPID
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
ASSERT(EXPECT,ACTUAL,MSG) ; for convenience
 D EQ^VPRJT(EXPECT,ACTUAL,$G(MSG))
 Q
 ;
GETDATA(TAG,DATA) ;
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^VPRJTPD),";;",2,999) Q:X="zzz"  S DATA(I)=X
 Q
TMP2ARY(ARY) ; convert JSON object in ^TMP($J) to array
 ; ARY must be passed by reference
 N SIZE,PREAMBLE
 S HTTPREQ("store")="vpr" ; normally this gets set in RESPOND^VPRJRSP
 D PAGE^VPRJRUT("^TMP($J)",0,999,.SIZE,.PREAMBLE)
 N SRC,N,I,J
 S N=0,SRC(N)="{""apiVersion"":""1.0"",""data"":{""totalItems"":"_^TMP($J,"total")_",""items"":["
 S I="" F  S I=$O(^TMP($J,$J,I)) Q:I=""  D
 . I I S SRC(N)=SRC(N)_","
 . S J=0 F  S J=$O(^TMP($J,$J,I,J)) Q:'J  D
 . . S N=N+1,SRC(N)=^TMP($J,$J,I,J)
 S N=N+1,SRC(N)="]}}"
 D DECODE^VPRJSON("SRC","ARY","ERR")
 D ASSERT(0,$G(ERR(0),0),"JSON conversion error")
 Q
PARSERNG ;; @TEST parse range (using meta-information)
 N RANGE,INDEX,START,STOP,DIR
 S INDEX="lab-type"
 M INDEX=^VPRMETA("index",INDEX,"common")
 S RANGE="GLU..GLZ>2012..2013["
 D PARSERNG^VPRJPQU
 D ASSERT("glz ",STOP(1))
 D ASSERT("7986=",START(2))
 D ASSERT(1,DIR(2))
 K START,STOP,DIR
 S RANGE="GLUCOSE, SODIUM, POTASSIUM>2012..2013["
 D PARSERNG^VPRJPQU
 D ASSERT(1,$D(START(1,"list","sodium ")))
 D ASSERT(0,$D(START(2,"list")))
 D ASSERT($C(255,255,255),STOP(1))
 Q
JSON ;;@test json formatting
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-ingredient-name","METFOR*",,,"uid")
 D ASSERT(0,$D(HTTPERR))
 N ARY D TMP2ARY(.ARY)
 ; reverse chronological order, so 16982 is 3rd item in list
 D ASSERT("urn:va:93EF:-7:med:16982",ARY("data","items",3,"uid"))
 D ASSERT(3,ARY("data","totalItems"))
 Q
TIME ;;@test time based query
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-time","20060101..20061231")
 D ASSERT(0,$D(HTTPERR))
 N ARY D TMP2ARY(.ARY)
 D ASSERT(3,ARY("data","totalItems"))
 D ASSERT(20060531,ARY("data","items",1,"overallStart"))
 D ASSERT(20060318,ARY("data","items",3,"overallStop"))
 D ASSERT("250 MG",ARY("data","items",3,"dosages",1,"dose"))
 Q
TIMEASC ;;@test ascending order
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-time","20060101..20061231","asc",4)
 N ARY D TMP2ARY(.ARY)
 D ASSERT(3,ARY("data","totalItems"))
 D ASSERT(20060318,ARY("data","items",1,"overallStop"))
 D ASSERT(20060531,ARY("data","items",3,"overallStart"))
 ; spot check a few values
 D ASSERT("urn:vuid:4023979",ARY("data","items",1,"products",1,"ingredientCode"))
 D ASSERT("VEHU,ONEHUNDRED",ARY("data","items",2,"orders",1,"provider","name"))
 D ASSERT("500 MG",ARY("data","items",3,"dosages",1,"dose"))
 Q
ATTR ;; @TEST attribute query
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-ingredient-name","METFOR*")
 N ARY D TMP2ARY(.ARY)
 D ASSERT(3,ARY("data","totalItems"))
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-ingredient-name","[ASPIRIN..METFORMIN]")
 K ARY D TMP2ARY(.ARY)
 D ASSERT(4,ARY("data","totalItems"))
 Q
ATTRLIM ;; @test attribute query with bail limits on return
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-ingredient-name","METFOR*",,1)
 N ARY D TMP2ARY(.ARY)
 D ASSERT(1,ARY("data","totalItems"))
 Q
LIST ;; @TEST list based query
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-active-outpt")
 N ARY D TMP2ARY(.ARY)
 D ASSERT(2,ARY("data","totalItems"))
 Q
LAST ;; @TEST most recent query
 N HTTPERR
 K ^TMP($J)
 D QLAST^VPRJPQ(VPRJTPID,"med-qualified-name")
 N ARY D TMP2ARY(.ARY)
 D ASSERT("urn:va:93EF:-7:med:18069",ARY("data","items",1,"uid"))
 D ASSERT("urn:va:93EF:-7:med:17203",ARY("data","items",2,"uid"))
 D ASSERT("urn:va:93EF:-7:med:18068",ARY("data","items",3,"uid"))
 K ^TMP($J)
 D QLAST^VPRJPQ(VPRJTPID,"med-class-code","urn:vadc:HS502, urn:vadc:CN103, urn:vadc:XX000")
 K ARY D TMP2ARY(.ARY)
 D ASSERT(2,ARY("data","totalItems"))
 D ASSERT("urn:va:93EF:-7:med:18069",ARY("data","items",1,"uid"))
 D ASSERT("urn:va:93EF:-7:med:18068",ARY("data","items",2,"uid"))
 Q
MATCH ;; match query (DISABLED for NOW)
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"condition.bleedingrisk")
 N ARY D TMP2ARY(.ARY)
 D ASSERT(1,ARY("data","totalItems"))
 D ASSERT("urn:vadc:BL110",ARY("data","items",1,"products",1,"drugClassCode"))
 Q
TALLY ;; @test tally items
 N HTTPERR
 K ^TMP($J)
 D QTALLY^VPRJPQ(VPRJTPID,"kind")
 N ARY
 D DECODE^VPRJSON("^TMP($J)","ARY","ERR")
 D ASSERT(0,$G(ERR(0),0),"JSON conversion error")
 D ASSERT(2,ARY("data","totalItems"))
 D ASSERT(4,ARY("data","items",2,"count"))
 Q
UID ;; @test get uid
 N HTTPERR
 K ^TMP($J)
 D QKEY^VPRJPQ(VPRJTPID,"urn:va:93EF:-7:med:17266")
 N ARY D TMP2ARY(.ARY)
 D ASSERT("402924;O",ARY("data","items",1,"localId"))
 D ASSERT("urn:vuid:4023979",ARY("data","items",1,"products",1,"ingredientCode"))
 Q
ORDER ;; @test sorting on different field
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"medication","","qualifiedName")
 N ARY D TMP2ARY(.ARY)
 D ASSERT("ASPIRIN",ARY("data","items",1,"qualifiedName"))
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"medication","","qualifiedName desc")
 K ARY D TMP2ARY(.ARY)
 D ASSERT("WARFARIN",ARY("data","items",1,"qualifiedName"))
 Q
BLDTLT ;; @test building a template
 N JSON,OBJECT,TLTARY,ERR,ARY
 D GETDATA("TIU1",.JSON)
 D DECODE^VPRJSON("JSON","OBJECT")
 D BLDTLT^VPRJP("tiu",.OBJECT,.TLTARY)
 D DECODE^VPRJSON("TLTARY(""notext"",1)","ARY","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(ARY("content")))
 D ASSERT(0,$D(ARY("text")))
 D ASSERT(1,$D(ARY("encounterUid")))
 D ASSERT(1,$D(ARY("uid")))
 D ASSERT(10,$D(ARY("clinicians")))
 K ARY
 D DECODE^VPRJSON("TLTARY(""summary"",1)","ARY","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(ARY("content")))
 D ASSERT(0,$D(ARY("text")))
 D ASSERT(0,$D(ARY("encounterUid")))
 D ASSERT(1,$D(ARY("uid")))
 D ASSERT(1,$D(ARY("localTitle")))
 Q

VPRJTR^INT^1^62766,48612.717279^0
VPRJTR ;SLC/KCM -- Unit tests for RESTful queries
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N DATA,I,LOC
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 I VPRJTPID D CLEARPT^VPRJP(VPRJTPID)
 D SETUP^VPRJM
 D GETDATA("DEMOG7",.DATA)
 S VPRJTPID=$P($$PUTPT^VPRJPR("",.DATA),"/",3)
 F I=1:1:5 D GETDATA("MED"_I,.DATA) S LOC=$$SAVE^VPRJP(VPRJTPID,.DATA) K DATA
 Q
SHUTDOWN ; Run once after all tests
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 D CLEARPT^VPRJP(VPRJTPID)
 K VPRJTPID
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
GETDATA(TAG,DATA) ;
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^VPRJTPD),";;",2,999) Q:X="zzz"  S DATA(I)=X
 Q
DATA2ARY(ARY) ; call SENDATA to write out response and read back into ARY
 ; cause TCP data to be written to file
 D WR4HTTP^VPRJRUT
 D SENDATA^VPRJRSP
 D C4HTTP^VPRJRUT
 ;
 ; read TCP data from file into variable and delete file
 N X,ERR
 S X=$$RD4HTTP^VPRJRUT
 D DECODE^VPRJSON("X","ARY","ERR")
 D ASSERT(0,$D(ERR))
 Q
SETGET(URL) ; set up a request (to emulate HTTP call)
 S HTTPREQ("method")="GET"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
SETPUT(URL,SRC) ; set up a PUT request
 N DATA
 S HTTPREQ("method")="PUT"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 D GETDATA(SRC,.DATA)
 M HTTPREQ("body")=DATA
 Q
SETDEL(URL) ; set up a delete request
 S HTTPREQ("method")="DELETE"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
SHOWRSP(ROOT) ; write out response
 N I
 I $D(@ROOT)#2 W !,@ROOT
 S I=0 F  S I=$O(@ROOT@(I)) Q:'I  W !,@ROOT@(I)
 Q
 ;
QSPLIT ;; @TEST splitting query parameters
 N QRY,HTTPERR
 S HTTPREQ("query")="range=20060101..20061231"
 D QSPLIT^VPRJRSP(.QRY)
 D ASSERT($D(QRY("range")),1)
 D ASSERT("20060101..20061231",QRY("range"))
 K QRY
 S HTTPREQ("query")="range=20060101..20061231&order=desc&limit=5"
 D QSPLIT^VPRJRSP(.QRY)
 D ASSERT("desc",QRY("order"))
 D ASSERT(5,QRY("limit"))
 Q
TIMERNG ;; @TEST query for range of time
 ;;{"apiVersion":"1.0","data":{"updated":20120517174918,"totalItems":3,"items":[{
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/med-time/?range=20060101..20061231")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(3,JSON("data","totalItems"))
 D ASSERT("METFORMIN",JSON("data","items",3,"products",1,"ingredientName"))
 ;D SHOWRSP(ROOT)
 Q
LAST ;; @TEST query for last instance of items in list
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/last/med-ingredient-name?range=Metformin, Aspirin Tab")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(2,JSON("data","totalItems"))
 D ASSERT("urn:va:93EF:-7:med:18069",JSON("data","items",1,"uid"))
 D ASSERT("urn:va:93EF:-7:med:18068",JSON("data","items",2,"uid"))
 Q
ORDASC ;; @TEST query to return in different order
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/medication?order=qualifiedName asc")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT("WARFARIN",JSON("data","items",5,"qualifiedName"))
 Q
ORDDESC ;; @TEST query to return in different order
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/medication?order=qualifiedName DESC")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT("WARFARIN",JSON("data","items",1,"qualifiedName"))
 Q
FILTER ;; @TEST filter to return based on criteria
 ;;{"apiVersion":"1.0","data":{"updated":20120517174918,"totalItems":3,"items":[{
 N ROOT,JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/medication/?filter=gt(""orders[].fillsRemaining"",4)")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(1,JSON("data","totalItems"))
 D ASSERT("urn:va:93EF:-7:med:17203",JSON("data","items",1,"uid"))
 ;D SHOWRSP(ROOT)
 Q
GETUID ;; @TEST getting an object by UID only
 N JSON,ERR,HTTPERR
 D SETGET("/vpr/uid/"_"urn:va:93EF:-7:med:18068")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT("ASPIRIN",JSON("data","items",1,"qualifiedName"))
 Q
EVERY ;; @TEST retrieving every object for a patient
 N JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/every")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(6,JSON("data","totalItems"))
 D ASSERT(0,$D(^TMP($J,$J)))
 D ASSERT(10,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"))))
 D ASSERT(0,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"),$J)))
 K JSON
 D SETGET("/vpr/"_VPRJTPID_"/index/every?start=3&limit=3")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(3,JSON("data","currentItemCount"))
 D ASSERT(10,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"))))
 D ASSERT(0,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"),$J)))
 Q
FINDALL ;; @TEST finding every object in collection
 N JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/find/med")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(5,JSON("data","totalItems"))
 Q
FINDPAR ;; @TEST finding with parameters
 N JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/find/med?filter=eq(""products[].ingredientName"",""METFORMIN"") eq(""dosages[].dose"",""250 MG"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(1,JSON("data","totalItems"))
 D ASSERT("urn:va:93EF:-7:med:16982",JSON("data","items",1,"uid"))
 Q
FINDLIKE ;; @TEST finding using like()
 N JSON,ERR,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/find/med?filter=like(""products[].ingredientName"",""ASPIRIN%25"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(1,JSON("data","totalItems"))
 D ASSERT("urn:va:93EF:-7:med:18068",JSON("data","items",1,"uid"))
 Q
ADDOBJ ;; @TEST adding object to store
 N HTTPERR
 D SETPUT("/vpr/"_VPRJTPID,"MED6")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("/vpr/"_VPRJTPID_"/urn:va:93EF:-7:med:15231",HTTPREQ("location"))
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:93EF:-7:med:15231")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","medication","79949668=","urn:va:93EF:-7:med:15231",0)))
 Q
DELOBJ ;; @TEST remove object from store
 N HTTPERR
 ;D SETDEL("/vpr/"_VPRJTPID_"/urn:va:93EF:-7:med:15231")
 D SETDEL("/vpr/uid/urn:va:93EF:-7:med:15231")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(0,$D(^VPRPT(VPRJTPID,"urn:va:93EF:-7:med:15231")))
 D ASSERT(0,$D(^VPRPTI(VPRJTPID,"list","medication",20050331,"urn:va:93EF:-7:med:15231")))
 Q
ADDPT ;; @TEST add new patient
 N MYPID,JSON,HTTPERR
 D SETPUT("/vpr","DEMOG8")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 S MYPID=$O(^VPRPT("PID","DFN","93EF:-8",""))
 D ASSERT("/vpr/"_MYPID_"/urn:va:93EF:-8:pat:-8",HTTPREQ("location"))
 ; do it again, make sure we get the same PID
 D SETPUT("/vpr","DEMOG8")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("/vpr/"_MYPID_"/urn:va:93EF:-8:pat:-8",HTTPREQ("location"))
 ; now get the patient demographics
 D SETGET("/vpr/"_MYPID)
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(666000008,JSON("data","items",1,"ssn"))
 D SETDEL("/vpr/"_MYPID)
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(0,$D(^VPRPT(MYPID)))
 D ASSERT(0,$D(^VPRPT("JSON",MYPID)))
 D ASSERT(0,$D(^VPRPTI(MYPID)))
 Q
 ;
ALLFIND ;; test find across patients
 ; this shouldn't be run like the other tests
 ; it can't produce the same results each time since it works across patients
 N MYPID,JSON,HTTPERR
 D SETGET("/vpr/all/find/med/uid?filter=like(""products[].ingredientName"",""ASPIRIN%25"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(1,($G(^TMP($J,"total"))>0))
 Q
1 ; run just one test
 D STARTUP,SETUP,ALLFIND,TEARDOWN,SHUTDOWN
 Q

VPRJTRP^INT^1^62766,48612.723039^0
VPRJTRP ;SLC/KCM -- Unit tests for RESTful paging
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N DATA,I,LOC
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 I VPRJTPID D CLEARPT^VPRJP(VPRJTPID)
 D SETUP^VPRJM
 D GETDATA("DEMOG7",.DATA)
 S VPRJTPID=$P($$PUTPT^VPRJPR("",.DATA),"/",3)
 F I=1:1:5 D GETDATA("MED"_I,.DATA) S LOC=$$SAVE^VPRJP(VPRJTPID,.DATA) K DATA
 Q
SHUTDOWN ; Run once after all tests
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 D CLEARPT^VPRJP(VPRJTPID)
 K VPRJTPID
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
GETDATA(TAG,DATA) ;
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^VPRJTPD),";;",2,999) Q:X="zzz"  S DATA(I)=X
 Q
DATA2ARY(ARY) ; call SENDATA to write out response and read back into ARY
 ; cause TCP data to be written to file
 D WR4HTTP^VPRJRUT
 D SENDATA^VPRJRSP
 D C4HTTP^VPRJRUT
 ;
 ; read TCP data from file into variable and delete file
 N X,ERR
 S X=$$RD4HTTP^VPRJRUT
 D DECODE^VPRJSON("X","ARY","ERR")
 D ASSERT(0,$D(ERR))
 Q
SETGET(URL) ; set up a request (to emulate HTTP call)
 S HTTPREQ("method")="GET"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
SETPUT(URL,SRC) ; set up a PUT request
 N DATA
 S HTTPREQ("method")="PUT"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 D GETDATA(SRC,.DATA)
 M HTTPREQ("body")=DATA
 Q
SETDEL(URL) ; set up a delete request
 S HTTPREQ("method")="DELETE"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
PAGE1 ;; @TEST query for first page
 N JSON,HTTPERR,HASH
 S HASH=$$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/medication////")
 D ASSERT(0,$D(^VPRTMP(HASH)))
 D SETGET("/vpr/"_VPRJTPID_"/index/medication?start=0&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(2,JSON("data","currentItemCount"))
 D ASSERT(5,JSON("data","totalItems"))
 D ASSERT("urn:va:93EF:-7:med:17203",JSON("data","items",2,"uid"))
 D ASSERT(10,$D(^VPRTMP(HASH)))
 Q
PAGE3 ;; @TEST query for last page
 N JSON,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/medication?start=4&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(1,JSON("data","currentItemCount"))
 D ASSERT(5,JSON("data","totalItems"))
 D ASSERT(4,JSON("data","startIndex"))
 D ASSERT("urn:va:93EF:-7:med:18068",JSON("data","items",1,"uid"))
 Q
PAGECHG ;; @TEST query when page changed
 W "(pause 1 sec)" H 1 ; wait long enough for the second to change
 N JSON,HTTPERR,HASH
 S HASH=$$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/medication////")
 D ASSERT(5,^VPRTMP(HASH,"total"))
 D SETPUT("/vpr/"_VPRJTPID,"MED6")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("/vpr/"_VPRJTPID_"/urn:va:93EF:-7:med:15231",HTTPREQ("location"))
 D SETGET("/vpr/"_VPRJTPID_"/index/medication?start=0&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(6,^VPRTMP(HASH,"total"))
 Q
LIMIT1 ;; @TEST query when order changed and want only 1 item
 N JSON,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/medication?order=overallStart asc&limit=1")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT(1,JSON("data","currentItemCount"))
 D ASSERT(0,JSON("data","startIndex"))
 D ASSERT("urn:va:93EF:-7:med:18068",JSON("data","items",1,"uid"))
 Q
TEMPLATE ;; @TEST query using template
 N JSON,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/medication/uid?start=2&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT("uid",$O(JSON("data","items",1,"")))
 D ASSERT("uid",$O(JSON("data","items",2,"")))
 D ASSERT(2,JSON("data","currentItemCount"))
 D ASSERT(1,JSON("data","pageIndex"))
 Q
NOLIMIT ;; @TEST query when no paging is requested
 N JSON,HTTPERR
 D SETGET("/vpr/"_VPRJTPID_"/index/medication/uid")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D DATA2ARY(.JSON)
 D ASSERT("uid",$O(JSON("data","items",1,"")))
 D ASSERT("uid",$O(JSON("data","items",2,"")))
 D ASSERT(6,JSON("data","currentItemCount"))
 D ASSERT(0,$D(JSON("data","pageIndex")))
 Q

VPRJTS^INT^1^62766,48612.728102^0
VPRJTS ;SLC/KCM -- Unit tests for saving objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N DATA
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 I VPRJTPID D CLEARPT^VPRJP(VPRJTPID)
 D SETUP^VPRJM
 Q
SHUTDOWN ; Run once after all tests
 S VPRJTPID=$O(^VPRPT("PID","DFN","93EF:-7",""))
 D CLEARPT^VPRJP(VPRJTPID)
 K VPRJTPID
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
ASSERT(EXPECT,ACTUAL,MSG) ; for convenience
 D EQ^VPRJT(EXPECT,ACTUAL,$G(MSG))
 Q
 ;
GETDATA(TAG,DATA) ;
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^VPRJTPD),";;",2,999) Q:X="zzz"  S DATA(I)=X
 Q
COLLATE ;; @TEST collation function
 N X
 S X=$$COLLATE^VPRJPX("","S",1)        D ASSERT("0 ",X)
 S X=$$COLLATE^VPRJPX(20120919,"V",0)  D ASSERT("79879080=",X)
 S X=$$COLLATE^VPRJPX("ASPIRIN","S",0) D ASSERT("ASPIRIN ",X)
 S X=$$COLLATE^VPRJPX("","S",0)        D ASSERT("",X)
 S X=$$COLLATE^VPRJPX(3.1416,"N",0)    D ASSERT(3.1416,X)
 S X=$$COLLATE^VPRJPX("DIGOXIN","P",0) D ASSERT("DIGOXIN",X)
 Q
ADDPT ;; @TEST adding a patient
 N DATA
 D GETDATA("DEMOG7",.DATA)
 S VPRJTPID=$P($$PUTPT^VPRJPR("",.DATA),"/",3)
 D ASSERT(1,VPRJTPID>0)
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:93EF:-7:pat:-7")))
 D ASSERT(666000007,^VPRPT(VPRJTPID,"urn:va:93EF:-7:pat:-7","ssn"))
 D ASSERT(1,$D(^VPRPT("PID",VPRJTPID,"ICN",-10107)))
 D ASSERT(1,$D(^VPRPT("PID","DFN","93EF:-7",VPRJTPID)))
 D ASSERT(1,$D(^VPRPT("JSON",VPRJTPID,"urn:va:93EF:-7:pat:-7",1)))
 Q
ADDOBJ ;; @TEST adding an object
 N DATA,LOC
 D GETDATA("MED1",.DATA)
 S LOC=$$SAVE^VPRJP(VPRJTPID,.DATA)
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:93EF:-7:med:16982")))
 D ASSERT("urn:vuid:4023979",^VPRPT(VPRJTPID,"urn:va:93EF:-7:med:16982","products",1,"ingredientCode"))
 D ASSERT(1,$D(^VPRPT("JSON",VPRJTPID,"urn:va:93EF:-7:med:16982",1)))
 D ASSERT(19350407,+$P(^VPRPT("TEMPLATE",VPRJTPID,"urn:va:93EF:-7:pat:-7","summary",1),":",2))
 D ASSERT(1,^VPRPTI(VPRJTPID,"tally","collection","med"))
 Q
CHKIDX ;; @TEST indexes that were built after adding object
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","med-class-code","urn:vadc:hs502 ","79939681=","urn:va:93EF:-7:med:16982","products.1")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","med-provider","labtech,special ","79939681=","urn:va:93EF:-7:med:16982","orders.1")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","med-qualified-name","metformin ","79939681=","urn:va:93EF:-7:med:16982",0)))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","medication","79939681=","urn:va:93EF:-7:med:16982",0)))
 D ASSERT("79939681=",^VPRPTI(VPRJTPID,"time","med-time","79949682=","urn:va:93EF:-7:med:16982",0))
 D ASSERT("79949682=",^VPRPTI(VPRJTPID,"stop","med-time","79939681=","urn:va:93EF:-7:med:16982",0))
 D ASSERT(1,^VPRPTI(VPRJTPID,"tally","kind","medication, outpatient"))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","med-active-outpt","79939681=","urn:va:93EF:-7:med:16982",0)))
 Q

VPRJTU^INT^1^62756,62813.054607^0
VPRJTU ;SLC/KCM -- Unit tests for utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
SETREQ(METHOD,URL) ; set up a request (to emulate HTTP call)
 S HTTPREQ("method")=METHOD
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
URLENC ;; @TEST test encoding string for use in a URL
 N X
 S X=$$URLENC^VPRJRUT("VALUES=20%&60% + or -")
 D ASSERT("VALUES%3D20%25%2660%25+%2B+or+-",X)
 Q
URLDEC ;; @TEST test decoding URL back into string
 N X
 S X=$$URLDEC^VPRJRUT("VALUES%3D20%25%2660%25+%2B+or+-")
 D ASSERT("VALUES=20%&60% + or -",X)
 S X=$$URLDEC^VPRJRUT("piece+of+path",1) ; '+' may be part of path
 D ASSERT("piece+of+path",X)
 Q
MATCH ;; @TEST matching for URLs
 N ROU,ARGS
 D SETREQ("GET","/vpr/48/urn:va:9E3C:229:med:33246") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("GETOBJ^VPRJPR",ROU)
 D ASSERT("urn:va:9E3C:229:med:33246",ARGS("uid"))
 D SETREQ("PUT","/vpr") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("PUTPT^VPRJPR",ROU)
 D ASSERT(0,$D(ARGS))
 D SETREQ("PUT","/vpr/42") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("PUTOBJ^VPRJPR",ROU)
 D ASSERT(42,ARGS("pid"))
 D SETREQ("GET","/vpr/42/index/med-outpt") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("INDEX^VPRJPR",ROU)
 D ASSERT(42,ARGS("pid"))
 D ASSERT("med-outpt",ARGS("indexName"))
 D SETREQ("GET","/vpr/42/index/med-outpt/simple") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("INDEX^VPRJPR",ROU)
 D ASSERT(42,ARGS("pid"))
 D ASSERT("med-outpt",ARGS("indexName"))
 D ASSERT("simple",ARGS("template"))
 D SETREQ("GET","/vpr/all/count/med-outpt") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("ALLCOUNT^VPRJPR",ROU)
 D ASSERT("med-outpt",ARGS("countName"))
 D SETREQ("DELETE","/vpr/42") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("DELPT^VPRJPR",ROU)
 K HTTPREQ,HTTPERR
 Q
NOMATCH ;; @TEST error codes when no match found
 ;;GET vpr/{patient?1.N}/find/{collection} FIND^VPRJPR
 N ROU,ARGS
 D SETREQ("DELETE","/vpr/42/find/med") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT(405,HTTPERR)
 D ASSERT(0,$D(ARGS))
 D ASSERT("",ROU)
 D SETREQ("GET","vpr/42/bogus") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT(404,HTTPERR)
 D ASSERT(0,$D(ARGS))
 D ASSERT("",ROU)
 K HTTPREQ,HTTPERR
 Q
SETVALS ;; @TEST set values procedure
 N OBJECT,VALUES,IDXMETA
 S OBJECT("top")="top value"
 S OBJECT("when")="201208121030"
 S OBJECT("how")="miracle"
 S OBJECT("mult",1,"sub")="sub1 value"
 S OBJECT("mult",2,"sub")="sub2 value"
 S OBJECT("mult",2,"provider","name")="Welby"
 S OBJECT("products",1,"drugClassCode")="urn:vadc:HS502"
 ;
 S IDXMETA(1,"field")="top"
 S IDXMETA(1,"collate")="S",IDXMETA(1,"ifNull")="",IDXMETA("levels")=1
 S IDXMETA(1,"ftype")=1,IDXMETA(1,"ftype","field")="top"
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 D ASSERT("top value ",VALUES(0,1))
 S IDXMETA(2,"field")="when"
 S IDXMETA("collateField")="S",IDXMETA("collateSort")="V"
 S IDXMETA(1,"collate")="S",IDXMETA(1,"ftype")=1,IDXMETA(1,"ftype","field")="top",IDXMETA(1,"ifNull")=""
 S IDXMETA(2,"collate")="V",IDXMETA(2,"ftype")=1,IDXMETA(2,"ftype","field")="when",IDXMETA(2,"ifNull")=0
 S IDXMETA("levels")=2
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 D ASSERT("798791878969=",VALUES(0,2))
 S IDXMETA(1,"field")="mult[].sub"
 S IDXMETA(1,"collate")="S",IDXMETA(1,"ftype")=3,IDXMETA(1,"ifNull")=""
 S IDXMETA(1,"ftype","field")="sub",IDXMETA(1,"ftype","mult")="mult"
 S IDXMETA("levels")=2
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 D ASSERT("sub1 value ",VALUES("mult.1",1))
 D ASSERT("sub2 value ",VALUES("mult.2",1))
 D ASSERT("798791878969=",VALUES("mult.1",2))
 D ASSERT("798791878969=",VALUES("mult.2",2))
 ; fields: mult[].sub, when, mult[].provider.name
 S IDXMETA(3,"field")="mult[].provider.name"
 S IDXMETA(3,"collate")="s",IDXMETA(3,"ifNull")=""
 S IDXMETA(3,"ftype")=4,IDXMETA(3,"ftype","mult")="mult"
 S IDXMETA(3,"ftype","field")="provider",IDXMETA(3,"ftype","sub")="name"
 S IDXMETA("levels")=3
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 D ASSERT(0,$D(VALUES("mult.1")))
 D ASSERT("welby ",VALUES("mult.2",3))
 S IDXMETA(3,"ifNull")="?"
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 D ASSERT("? ",VALUES("mult.1",3))
 S IDXMETA(2,"ftype","field")="gone",IDXMETA(2,"field")="gone"
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 D ASSERT("9=",VALUES("mult.1",2)) ; reverse time, so 0= becomes 9=
 D ASSERT("9=",VALUES("mult.2",2))
 S IDXMETA(3,"field")="products[].drugClassCode"
 S IDXMETA(3,"collate")="S",IDXMETA(3,"ifNull")=""
 S IDXMETA(3,"ftype")=3,IDXMETA(3,"ftype","mult")="products"
 S IDXMETA(3,"ftype","field")="drugClassCode"
 S IDXMETA("levels")=3
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 D ASSERT("urn:vadc:HS502 ",VALUES("mult.1&products.1",3))
 D ASSERT("urn:vadc:HS502 ",VALUES("mult.2&products.1",3))
 K IDXMETA
 S IDXMETA(1,"collate")="s",IDXMETA(1,"ftype")=1,IDXMETA(1,"ftype","field")="top",IDXMETA(1,"field")="top"
 S IDXMETA(2,"collate")="s",IDXMETA(2,"ftype")=1,IDXMETA(2,"ftype","field")="how",IDXMETA(2,"field")="how"
 S IDXMETA(3,"collate")="V",IDXMETA(3,"ftype")=1,IDXMETA(3,"ftype","field")="when",IDXMETA(3,"field")="when"
 S IDXMETA("levels")=3
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 D ASSERT("top value ",VALUES(0,1))
 D ASSERT("miracle ",VALUES(0,2))
 D ASSERT("798791878969=",VALUES(0,3))
 K IDXMETA
 S IDXMETA(1,"field")="mult[].sub"
 S IDXMETA(1,"collate")="s",IDXMETA("levels")=1
 S IDXMETA(1,"ftype")=3,IDXMETA(1,"ftype","mult")="mult",IDXMETA(1,"ftype","field")="sub"
 D SETVALS^VPRJPX(.OBJECT,.VALUES)
 Q
BLDREF ;; @TEST building a node reference from object notation
 N X
 S X=$$BLDREF^VPRJP("results[].clinician.name")
 D ASSERT("(""results"",NUM,""clinician"",""name"")",X)
 S X=$$BLDREF^VPRJP("summary")
 D ASSERT("(""summary"")",X)
 S X=$$BLDREF^VPRJP("results[].units")
 D ASSERT("(""results"",NUM,""units"")",X)
 S X=$$BLDREF^VPRJP("clinician.name")
 D ASSERT("(""clinician"",""name"")",X)
 Q
ADDFLD ;; @TEST adding fields to template object
 N OBJECT,TOBJECT
 D BLDOBJ(.OBJECT)
 D ADDFLD^VPRJP("summary",.OBJECT,.TOBJECT)
 D ASSERT(1,$$NODECNT(.TOBJECT))
 D ASSERT("short description",TOBJECT("summary"))
 D ADDFLD^VPRJP("nonexist",.OBJECT,.TOBJECT)
 D ASSERT(1,$$NODECNT(.TOBJECT))
 D ADDFLD^VPRJP("facility.name",.OBJECT,.TOBJECT)
 D ASSERT(2,$$NODECNT(.TOBJECT))
 D ADDFLD^VPRJP("mult[].clinician.name",.OBJECT,.TOBJECT)
 D ASSERT(5,$$NODECNT(.TOBJECT))
 D ADDFLD^VPRJP("mult[].sub",.OBJECT,.TOBJECT)
 D ASSERT(8,$$NODECNT(.TOBJECT))
 D ADDFLD^VPRJP("mult[].*",.OBJECT,.TOBJECT)
 D ASSERT(12,$$NODECNT(.TOBJECT))
 D ASSERT("o4",TOBJECT("mult",4,"other"))
 Q
DELFLD ;; @TEST removing fields from template object
 N OBJECT,TOBJECT
 D BLDOBJ(.OBJECT) M TOBJECT=OBJECT
 D ASSERT(14,$$NODECNT(.TOBJECT))
 D DELFLD^VPRJP("mult[].*",.TOBJECT)
 D ASSERT(4,$$NODECNT(.TOBJECT))
 D DELFLD^VPRJP("summary",.TOBJECT)
 D ASSERT(3,$$NODECNT(.TOBJECT))
 D DELFLD^VPRJP("facility.name",.TOBJECT)
 D ASSERT(2,$$NODECNT(.TOBJECT))
 M TOBJECT=OBJECT
 D DELFLD^VPRJP("mult[].sub",.TOBJECT)
 D ASSERT(11,$$NODECNT(.TOBJECT))
 D DELFLD^VPRJP("mult[].clinician.name",.TOBJECT)
 D ASSERT(8,$$NODECNT(.TOBJECT))
 Q
BLDOBJ(OBJECT) ; build a sample object for adding removing fields
 S OBJECT("one")=1
 S OBJECT("two")=2
 S OBJECT("mult",1,"sub")="s1"
 S OBJECT("mult",1,"other")="o1"
 S OBJECT("mult",1,"clinician","name")="Marcus"
 S OBJECT("mult",2,"sub")="s2"
 S OBJECT("mult",2,"other")="o2"
 S OBJECT("mult",2,"clinician","name")="Welby"
 S OBJECT("mult",3,"sub")="s3"
 S OBJECT("mult",3,"other")="o3"
 S OBJECT("mult",3,"clinician","name")="Kildare"
 S OBJECT("mult",4,"other")="o4"
 S OBJECT("facility","name")="somewhere"
 S OBJECT("summary")="short description"
 Q
NODECNT(OBJECT) ; Return a count of nodes in the object
 N X,CNT
 S CNT=0,X="OBJECT"
 F  S X=$Q(@X) Q:X=""  S CNT=CNT+1
 Q CNT
 ;

XLFCRC^INT^1^62756,62813.059401^0
XLFCRC ;ISF/RWF - Library Functions to do CRC ;08/04/2000  09:42
 ;;8.0;KERNEL;**166**;Jul 10, 1995
 ; The code below was approved in document X11/1998-32
 ;From the book "M[UMPS] by example" by Ed de Mole.
 ;
CRC32(string,seed) ;
 ; Polynomial X**32 + X**26 + X**23 + X**22 +
 ;          + X**16 + X**12 + X**11 + X**10 +
 ;          + X**8  + X**7  + X**5  + X**4 +
 ;          + X**2  + X     + 1
 N I,J,R
 I '$D(seed) S R=4294967295
 E  I seed'<0,seed'>4294967295 S R=4294967295-seed
 E  S $ECODE=",M28,"
 F I=1:1:$L(string) D
 . S R=$$XOR($A(string,I),R,8)
 . F J=0:1:7 D
 . . I R#2 S R=$$XOR(R\2,3988292384,32)
 . . E  S R=R\2
 . . Q
 . Q
 Q 4294967295-R
 ;
XOR(a,b,w) N I,M,R
 S R=b,M=1
 F I=1:1:w D
 . S:a\M#2 R=R+$S(R\M#2:-M,1:M)
 . S M=M+M
 . Q
 Q R
 ; ===
 ;
 ; The code below was approved in document X11/1998-32
 ;
CRC16(string,seed) ;
 ; Polynomial x**16 + x**15 + x**2 + x**0
 N I,J,R
 I '$D(seed) S R=0
 E  I seed'<0,seed'>65535 S R=seed\1
 E  S $ECODE=",M28,"
 F I=1:1:$L(string) D
 . S R=$$XOR($A(string,I),R,8)
 . F J=0:1:7 D
 . . I R#2 S R=$$XOR(R\2,40961,16)
 . . E  S R=R\2
 . . Q
 . Q
 Q R
 ;
ZXOR(a,b,w) NEW I,M,R
 SET R=b,M=1
 FOR I=1:1:w DO
 . SET:a\M#2 R=R+$SELECT(R\M#2:-M,1:M)
 . SET M=M+M
 . QUIT
 QUIT R
 ;

XLFDT^INT^1^62756,62813.066033^0
XLFDT ;ISC-SF/STAFF - Date/Time Functions ;03/27/2003  14:09
 ;;8.0;KERNEL;**71,120,166,168,179,280**;Jul 10, 1995
 ;VA FileMan uses 2400 as midnight, many other system use 0000.
 ;This is true for $H and HL7, so a conversion has to adjust
 ;the day when converting Midnight.
 ;i.e. 3001225.24 is the same as HL7 '200012260000' and $H '58434,0'
 ;The range of accepted $H dates: "2,0" to "99999,85399".
 ;The range of accepted FM dates: 1410102 to 4141015 (any valid time).
 ;The range of accepted HL7 dates: 18410102 to 21141015 (any valid time).
 ;It is expected that input values are valid dates.
 ;
HTFM(%H,%F) ;$H to FM, %F=1 for date only
 N X,%,%T,%Y,%M,%D S:'$D(%F) %F=0
 I $$HR(%H) Q -1 ;Check Range
 I '%F,%H[",0" S %H=(%H-1)_",86400"
 D YMD S:%T&('%F) X=X_%T
 Q X
 ;
H2F(%H) ;Internal to this routine use
 N X,%,%T,%Y,%M,%D
 D YMD S:%T X=X_%T
 Q X
 ;
YMD ;21608 = 28 feb 1900, 94657 = 28 feb 2100, 141 $H base year
 S %=(%H>21608)+(%H>94657)+%H-.1,%Y=%\365.25+141,%=%#365.25\1
 S %D=%+306#(%Y#4=0+365)#153#61#31+1,%M=%-%D\29+1
 S X=%Y_"00"+%M_"00"+%D,%=$P(%H,",",2)
 S %T=%#60/100+(%#3600\60)/100+(%\3600)/100 S:'%T %T=".0"
 Q
 ;
FMTH(X,%F) ;FM to $H, %F=1 for date only
 N %Y,%H,%A S:'$D(%F) %F=0
 I $$FR(X) Q -1 ;$H range of 1 - 99999
 I '%F,X[".24" S %A=1
 D H S:%F %H=+%H I $D(%A) S %H=(%H+1)_",0"
 Q %H
 ;
F2H(X) ;Internal to this routine use
 N %Y,%H,%A
 D H
 Q %H
 ;
H ;Build %H from FM
 N %,%L,%M,%D,%T I X<1410101 S %H=0,%Y=-1 Q
 S %Y=$E(X,1,3),%M=$E(X,4,5),%D=$E(X,6,7)
 S %T=$E(X_0,9,10)*60+$E(X_"000",11,12)*60+$E(X_"00000",13,14)
 ;%L = (# leap years) - (# leap years before base)
 S %L=%Y+1700 S:%M<3 %L=%L-1 S %L=(%L\4)-(%L\100)+(%L\400)-446
 S %H=$P("^31^59^90^120^151^181^212^243^273^304^334","^",%M)+%D
 S %=('%M)!('%D),%Y=%Y-141,%H=(%H+(%Y*365)+%L+%)_","_%T,%Y=$S(%:-1,1:%H+4#7)
 Q
 ;
HTE(%H,%F) ;$H to external
 Q:$$HR(%H) %H ;Range Check
 N Y,%T,%R
 S %F=$G(%F,1) S Y=$$HTFM(%H,0) G T2
 ;
FMTE(Y,%F) ;FM to external
 Q:(Y<1000000)!(Y>9991231) Y ;Range Check
 N %T,%R S %F=$G(%F,1)
 ;Both HTE and FMTE come here.
T2 S %T="."_$E($P(Y,".",2)_"000000",1,7)
 D FMT^XLFDT1 Q %R
 ;
FR(%V) ;Check FM in valid range
 Q (%V<1410102)!(%V>4141015.235959)
HR(%V) ;Check $H in valid range
 Q (%V<2)!(%V>99999)
 ;
FMTHL7(%P1) ;Convert FM date/time to HL7 format
 N %T Q:'$L(%P1) "" S %P1=+%P1 ;Make sure a cononic number
 I $$FR(%P1) Q -1 ;Check range
 S %T=$P(%P1,".",2),%P1=$P(%P1,".")
 I %T=24 S %P1=$$FMADD($P(%P1,"."),1),%T="0000"
 S:%P1>1 %P1=%P1+17000000
 I $L(%T) S %T=$S($L(%T)>4:$E(%T_"00",1,6),1:$E(%T_"0000",1,4))
 I $L(%T) S %P1=%P1_%T_$$TZ()
 Q %P1
 ;
HL7TFM(%P1,%P2,%P3) ;Convert HL7 D/T to FM.
 ;%P1 is the value to convert
 ;%P2 is if output should be local or UCT time (L,U)
 ;%P3 is 1 if the input just a time value?
 N %TZ,%LTZ,%SN,%U,%H,%M,%T Q:'$L(%P1) ""
 S %T=$E(%P1_"0000",1,8)
 S %P2=$G(%P2),%P3=+$G(%P3),%TZ="",%LTZ=$$TZ()
 I '%P3 Q:(%T<18410102)!(%T>21141015) -1 ;Date Range Check
 F %SN="+","-" I %P1[%SN D  Q  ;Find the timezone
 . S %TZ=$P(%P1,%SN,2),%P1=$P(%P1,%SN) I %TZ'?4N S %TZ="" Q
 . S %TZ=%SN_%TZ
 . Q
 ;FM only supports time to seconds
 S %P1=$P(%P1,".")
 ;See it just a Time value
 I %P3 S %P1="20000104"_%P1 ;Add a date
 Q:($L(%P1)#2)!(%P1'?4.14N) -1 ;Length check
 I $L(%P1)<8 S %P1=$E(%P1_"00000000",1,8) ;Fill out to 8 digits
 I %TZ="" D
 . S:%P2["L" %P2="" ;If no TZ, assume local, don't need L.
 . S:%P2["U" %TZ=%LTZ ;give the local tz
 ;
 S %P1=$S($L(%P1)>8:$E(%P1,1,8)-17000000_"."_$E(%P1,9,14),1:%P1-17000000)
 ;%P1 is now in FM format
 I %P1[".",+$P(%P1,".",2)=0 S %P1=$$FMADD(+%P1,-1)_".24"
 ;If HL7 tz and local tz are the same
 I %P2["L",%TZ=%LTZ S %P2=""
 I (%P2["U")!(%P2["L"),%P1["." D  ;Build UCT from data
 . S %=$TR(%TZ,"+-","-+") ;Reverse the sign
 . S %H=$E(%,1,3),%M=$E(%,1)_$E(%,4,5)
 . S %P1=$$FMADD(%P1,,%H,%M) Q
 ;
 I %P2["L",%P1["." D  ;Build local from UCT
 . S %=$$TZ(),%H=$E(%,1,3),%M=$E(%,1)_$E(%,4,5)
 . S %P1=$$FMADD(%P1,,%H,%M) Q
 Q +$S(%P3:"."_$P(%P1,".",2),1:%P1)
 ;
DOW(X,Y) ;Day of Week
 N %Y,%M,%D,%H,%T D H I $G(Y) Q %Y
 Q $P("Sun^Mon^Tues^Wednes^Thurs^Fri^Satur","^",%Y+1)_"day"
 ;
FMDIFF(X1,X2,X3) ;FM diff in two dates. if X3=1 in days, if X3=2 in seconds.
 N %H,%Y,X
 S X1=$G(X1),X2=$G(X2),X3=$G(X3,1)
 S:$$FR(X1) X1=0 S:$$FR(X2) X2=0 ;Check range, Use 0 for bad values
 S X=X1 D H S X1=+%H,X1(1)=$P(%H,",",2),X=X2 D H
 ;Both FMDIFF and HDIFF come here.
D2 S X=(X1-%H) S:X3>1 X=X*86400+(X1(1)-$P(%H,",",2))
 I X3=3 S %=X,X="" S:%'<86400 X=(%\86400) S:%#86400 X=X_" "_(%#86400\3600)_":"_$E(%#3600\60+100,2,3)_":"_$E(%#60+100,2,3)
 Q X
 ;
HDIFF(X1,X2,X3) ;$H diff in two dates, X3 same as FMDIFF.
 N X,%H,%T
 S:$$HR(X1) X1="1,1" S:$$HR(X2) X2="1,1" ;Check range, use "1,1" for bad values
 S X3=$G(X3,1)
 S X1(1)=$P(X1,",",2),X1=+X1,%H=X2
 G D2
 ;
HADD(X,D,H,M,S) ;Add to $H date
 N %H,%T
 Q:$$HR(X) -1 ;Check Range
 S %H=+X,%T=$P(X,",",2) D A2 Q %H_","_%T
 ;
A2 S %H=%H+$G(D),%T=%T+($G(H)*3600)+($G(M)*60)+$G(S) ;add days and seconds
 ;S:%T'<86400 %H=%H+(%T\86400),%T=%T#86400 S:%T<0 %H=%H+(%T\86400)-1,%T=%T#86400
 S %H=%H+(%T\86400) I %T<0,(%T#86400'=0) S %H=%H-1 ;Adj for sec>day
 S %T=%T#86400
 Q
 ;
FMADD(X,D,H,M,S) ;Add to FM date
 N %H,%T,%P
 Q:$$FR(X) -1 ;Check Range
 S %P=X[".",%H=$$F2H(X),%T=$P(%H,",",2) D A2
 I %P,%T=0 S %H=%H-1,%T=86400
 Q $$H2F(%H_","_%T)
 ;
NOW() ;Current Date/time in FM.
 Q $$HTFM($H)
 ;
DT() ;Current Date in FM.
 Q $$HTFM($H,1)\1
 ;
SCH(SCH,LTM,FF) ;Find the next D/T given a schedule, start time.
 Q $$DECODE^XLFDT2
 ;
WITHIN(XLSCH,XLD) ;See if D/T is within schedule
 G WITHIN^XLFDT4
 ;
SEC(%) ;Convert $H to seconds.
 I %?7.N.".".N S %=$$FMTH(%) ;Check for FM date
 Q 86400*%+$P(%,",",2)
 ;
%H(%) ;Covert from seconds to $H
 Q (%\86400)_","_(%#86400)
 ;
TZ() ;Return current Time Zone from Mailman parameter file
 N %T,%S
 S %T=$P($G(^XMB(4.4,+$P($G(^XMB(1,1,0)),"^",2),0)),"^",3),%S=$S(%T["-":"-",1:"+"),%T=$TR(%T,"-+")
 Q %S_$E(100+%T,2,3)_$S(%T[".5":"30",1:"00")

XLFDT1^INT^1^62756,62813.071129^0
XLFDT1 ;ISC-SF/RWF - Date/Time Functions cont. from VA FileMan %DTC ;02/20/2003  10:05
 ;;8.0;KERNEL;**71,280**;Jul 10, 1995
 ;If y contains a "D" then Date only.
 ;if y contains a "F" then output with leading blanks
 ;If y contains a "P" then output ' HH:MM:SS am/pm'.
 ;If y contains a "S" then force seconds in the output.
 ;if y contains a "M" then stop at minutes i.e. no seconds.
 ;
FMT ;
 N %G S %G=+%F
 G F1:%G=1,F2:%G=2,F3:%G=3,F4:%G=4,F5:%G=5,F6:%G=6,F7:%G=7,F8:%G=8,F9:%G=9,F1
 Q
 ;
F1 ;Apr 10, 2002
 S %R=$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_$S($E(Y,6,7):$E(Y,6,7)_", ",1:"")_($E(Y,1,3)+1700)
 ;
TM ;All formats come here to format Time.
 N %,%S Q:%T'>0!(%F["D")
 I %F'["P" S %R=%R_"@"_$E(%T,2,3)_":"_$E(%T,4,5)_$S(%F["M":"",$E(%T,6,7)!(%F["S"):":"_$E(%T,6,7),1:"")
 I %F["P" D
 . S %R=%R_" "_$S($E(%T,2,3)>12:$E(%T,2,3)-12,+$E(%T,2,3)=0:"12",1:+$E(%T,2,3))_":"_$E(%T,4,5)_$S(%F["M":"",$E(%T,6,7)!(%F["S"):":"_$E(%T,6,7),1:"")
 . S %R=%R_$S($E(%T,2,7)<120000:" am",$E(%T,2,3)=24:" am",1:" pm")
 . Q
 Q
 ;Return Month names
M() Q "  Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec"
 ;
F2 ;4/10/02
 S %R=$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)_"/"_$E(Y,2,3)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F3 ;10/4/02
 S %R=$J(+$E(Y,6,7),2)_"/"_$J(+$E(Y,4,5),2)_"/"_$E(Y,2,3)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F4 ;02/4/10
 S %R=$E(Y,2,3)_"/"_$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F5 ;4/10/2002
 S %R=$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)_"/"_($E(Y,1,3)+1700)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F6 ;10/4/2002
 S %R=$J(+$E(Y,6,7),2)_"/"_$J(+$E(Y,4,5),2)_"/"_($E(Y,1,3)+1700)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F7 ;2002/4/10
 S %R=($E(Y,1,3)+1700)_"/"_$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F8 ;10 Apr 02
 S %R=$S($E(Y,6,7):$E(Y,6,7)_" ",1:"")_$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_$E(Y,2,3)
 G TM
F9 ;10 Apr 2002
 S %R=$S($E(Y,6,7):$E(Y,6,7)_" ",1:"")_$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_($E(Y,1,3)+1700)
 G TM

XLFSTR^INT^1^62756,62813.076251^0
XLFSTR ;ISC-SF/STAFF - String Functions ;12/19/06  09:45
 ;;8.0;KERNEL;**112,120,400,437**;Jul 10, 1995;Build 2
 ;
UP(X) Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 ;
LOW(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
 ;
STRIP(X,Y) Q $TR(X,$G(Y),"")
 ;
REPEAT(X,Y) ;
 N % Q:'$D(X) "" I $L(X)*$G(Y)>245 Q ""
 S %="",$P(%,X,$G(Y)+1)=""
 Q %
 ;
SPLIT(%SRC,%DLM,%VLIST) ;split a string by delimiter vars in list
 ;returns number of vars in list
 ;usage - s %=$$split(src,dlm,"d1,d2,d3,..")
 N I,V,DV
 S DV=$$DVARS(%VLIST),%DLM=$G(%DLM,",")
 F I=1:1:$L(%VLIST,DV) S V=$P(%VLIST,DV,I) S:V'="" @V=$P(%SRC,%DLM,I)
 Q I
 ;
DVARS(LIST) ;return a delimiter for a list of variables
 Q $S(%VLIST[$C(9):$C(9),%VLIST[";":";",1:",")
 ;
INVERT(X) ;
 N %,%1 S %="" F %1=$L(X):-1:1 S %=%_$E(X,%1)
 Q %
 ;
REPLACE(IN,SPEC) ;See $$REPLACE in MDC minutes.
 Q:'$D(IN) "" Q:$D(SPEC)'>9 IN N %1,%2,%3,%4,%5,%6,%7,%8
 S %1=$L(IN),%7=$J("",%1),%3="",%6=9999 F  S %3=$O(SPEC(%3)) Q:%3=""  S %6(%6)=%3,%6=%6-1
 F %6=0:0 S %6=$O(%6(%6)) Q:%6'>0  S %3=%6(%6) D:$D(SPEC(%3))#2 RE1
 S %8="" F %2=1:1:%1 D RE3
 Q %8
 ;
RE1 S %4=$L(%3),%5=0 F  S %5=$F(IN,%3,%5) Q:%5<1  D RE2
 Q
RE2 Q:$E(%7,%5-%4,%5-1)["X"  S %8(%5-%4)=SPEC(%3)
 F %2=%5-%4:1:%5-1 S %7=$E(%7,1,%2-1)_"X"_$E(%7,%2+1,%1)
 Q
RE3 I $E(%7,%2)=" " S %8=%8_$E(IN,%2) Q
 S:$D(%8(%2)) %8=%8_%8(%2)
 Q
 ;
RJ(%,%1,%2) ;Right justify
 N %3
 S:%1["T" %1=+%1,%=$E(%,1,%1)
 S %3=$J("",%1-$L(%)) S:$D(%2) %3=$TR(%3," ",%2)
 Q %3_%
 ;
LJ(%,%1,%2) ;Left justify
 N %3
 S:%1["T" %1=+%1,%=$E(%,1,%1)
 S %3=$J("",%1-$L(%)) S:$G(%2)]"" %3=$TR(%3," ",%2)
 Q %_%3
 ;
CJ(%,%1,%2) ;Center Justify
 N %3,%4
 S:%1["T" %1=+%1,%=$E(%,1,%1) S %3=%1-$L(%) Q:%3<1 %
 S %3=%3\2,%4=$J("",%3+1) I $G(%2)]"" S %4=$TR(%4," ",%2)
 Q $E(%4,1,%3)_%_$E(%4,1,%1-%3-$L(%))
 ;
QUOTE(%) ;Add quotes to value for concatenation
 S %(%)=0,%=$Q(%)
 Q $P($E(%,1,$L(%)-1),"(",2,999)
 ;
TRIM(%X,%F,%V) ;Trim spaces\char from front(left)/back(right) of string
 N %R,%L
 S %F=$$UP($G(%F,"LR")),%L=1,%R=$L(%X),%V=$G(%V," ")
 I %F["R" F %R=$L(%X):-1:1 Q:$E(%X,%R)'=%V
 I %F["L" F %L=1:1:$L(%X) Q:$E(%X,%L)'=%V
 I (%L>%R)!(%X=%V) Q ""
 Q $E(%X,%L,%R)
 ;
SENTENCE(%X) ;
 ; Converts a string into proper sentence case (first letter of each sentence
 ;  upper case, all the others lower case)
 ; Example Usage:
 ; W $$SENTENCE^XLFSTR("HELLO WORLD!!! THIS IS A CAPITALIZED SENTENCE. (this isn't.)")
 ;  produces
 ; Hello world!!! This is a capitalized sentence. This isn't.
 ;
 ; %S = string during conversion
 ; %P = state flag (1 = next letter should be caps)
 ; I = iteration index
 ; C = current character
 ;
 N %I,%C,%S,%P
 S %S=$$LOW(%X),%P=1
 F %I=1:1:$L(%X) D
 . S %C=$E(%S,%I)
 . I %P,%C?1L S $E(%S,%I)=$$UP(%C),%P=0
 . S:".!?"[%C %P=1
 Q %S
 ;
TITLE(%X) ;
 ; Converts a string into TITLE CASE format (first letter of each word is uppercase)
 ; Example Usage:
 ; W $$TITLE^XLFSTR("THIS IS CAPITALIZED. (this isn't.)")
 ; produces
 ; This Is Capitalized. This Isn't.
 ;
 ; %S = string during conversion
 ; %P = state flag
 ; %I = iteration index
 ; %C = current character
 ;
 N %I,%C,%S,%P
 S %S=$$LOW(%X),%P=1
 F %I=1:1:$L(%S) D
 . S %C=$E(%S,%I)
 . I %P,%C?1L S $E(%S,%I)=$$UP(%C),%P=0
 . S:%C=" " %P=1
 . Q
 Q %S



